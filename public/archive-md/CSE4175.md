# 컴퓨터 네트워크  

<br>

컴퓨터에서 중요한 분야는 뭘까? 순서대로 나열해보자. 나무가 뿌리를 내리고 줄기가 뻗어나가는 그림을 상상하면서 보자.  
알고리즘, OS, 아키텍처, 그래픽, 네트워크 통신, DB..  

<br>

컴퓨터 네트워크란 무엇인가?  
교재: Computer Networking - A Top-Down Approach 7th edition  
[요약 티스토리]([컴퓨터 네트워크[A Top-Down Approach] - CH 1. Computer Networks and the Internet (dojinkimm.github.io)](https://dojinkimm.github.io/computer_network/2019/11/16/cnetwork1.html))  
[요약 깃허브](https://github.com/IT-Book-Organization/Computer-Networking_A-Top-Down-Approach/tree/main))  

<br>

Physical 레이어는 다루지 않는다. 이를 제외한 나머지 4개의 레이어에 대해서 배운다.  
Chapter 8. Security  

<br>

한 챕터 당 3개의 강의가 할당된다고 생각하면 될 것 같다.  

<br>

# 1. Introduction  

<br>

- Terminology: 강의에서 약자가 꽤 많이 나오기 때문에 용어에 대해서 익혀 놓는 것이 좋을 것이다.  

<br>

## 1.1 What is the Internet?  

<br>

### 1.1.1 "Nuts and bolts" View  

<br>

``nuts and bolts: 시시콜콜이``  
- **End system** : 에이전트, 즉 일반적인 우리의 디바이스들(PC, laptop) 네트워크의 구성 중에 맨 마지막(end)에 가 있기 때문에 end user가 사용하는 end system이라고 한다.<br> <img src="Docs/Pasted image 20240308151532.png">
  
- Core system은 우리 눈에 보이지 않는 곳에 있다.  
- Communication links: end user들을 연결해주는 링크이다. 예전에는 거의 유선으로 되어있었다. 이 유선은 구리가 광섬유 같은 것으로 구성되어있다. 무선은 radio나 satelite라고 한다. <br><img src="Docs/Pasted image 20240308151631.png">
  
- *Transmission rate: bandwidth, 즉 bps(bit per second)라고 알면 된다. 데이터의 전송량인 것이다. ``무선 통신에서는 bandwidth는 주파수라고 한다.``*  
- Packet switches: Link들을 연결하는 middle agent라 알면 된다. <br><img src="Docs/Pasted image 20240308151347.png">
  
- Router  
- Switches  

<br>

- Internet, internet: Internet은 네트워크들끼리 네트워크를 이루는 것을 가리키는 것, internet은 의미가 조금 다른다  
- *ISP(Internet service provider): 통신사, 딜라이브, kt, 경인방송 등*  
- *Protocols: ``인터넷은 프로토콜이다.`` 인터넷을 돌아가게 하기 위해서 규약을 만들었는데, 각각 layer 별로 프로토콜을 배치한다.*  
- *Skype, TCP, IP, HTTP, 802.11..*  
- *이 프로토콜이 어느 layer의 프로토콜인지 잘 파악할 것*  
- Internet standards<img src="Docs/Pasted image 20240308153020.png">
  
- *RFC(Reauest for comments): 인터넷 기술에 적용 가능한 새로운 연구, 혁신, 기법 등*  
- *IETF(Internet Engineering Task Force): 국제 인터넷 표준화 기*  

<br>

### 1.1.2 A Service View  

<br>

- Infrastucture이 깔리면, 우리는 그곳에 접속을해서 어플리케이션을 쓰면 된다.  
- 하나의 프로토콜을 쓰는 것이 아니다. Layer마다 쓰는 각각의 프로토콜을 모아 돌아가는 것이 어플리케이션이다. 그러나 이걸 다 우리가 제공할 필요는 없고, 기반 프로토콜들이 제공이 된다.  

<br>

### 1.1.3 Protocol  

<br>

<img src="Docs/Pasted image 20240308153842.png">
  
- Human protocol: ``예의를 지켜라.`` 일상을 살아가는 데 필요한 사회적인 규약  
- Network protocol: 컴퓨터 내부에서, 또는 컴퓨터 사이에서 데이터의 교환 방식을 정의하는 규칙 체계  

<br>

## 1.2 Network Edge  

<br>

### 1.2.1 Network Structure  

<br>

- Network edge: 호스트, 테이터 센터의 서버들  
- Access networks, physical media: 유선, 무선 링크들  
- Network core: Router와 switch들  

<br>

### 1.2.2 Access Networks and Physical Media  

<br>

- End system -> edge router?  
- Access networks:   
- DSL(Digital Subscriber Line):  
- ``아주 먼 옛날..``컴퓨터를 전화선에 연결해서 통신하는 것이다. 디지털 신호 -> 아날로그 신호 -> 디지털 신호로 변화해주는 모듈을 컴퓨터에 넣으면 된다.<img src="Docs/Pasted image 20240308154507.png">
  
- Upstream과 Downstream의 속도는 보내는 데이터의 양이 다르게 때문에 unsymmetric하다.  
- Cable networks:  
- Cable headed과 DSLAM과 같은 역할을 하는데, 디지털 통신이 아닌 아날로그 통신으로 통신한다.<img src="Docs/Pasted image 20240308155310.png">
  
- *HFC(hybrid fiber coax): 광통신 섬유, 대용량의 정보를 속도의 감소 없이, 빛의 속도로 전달 할 수 있게 한다. 광섬유는 건물 안에 들어가기 힘들기 때문에, 동축 케이블을 통해서 들어가도록 한다.*  
- *DSL과의 차이* : Dedicated되어있는 DSL과 달리 공유되어있다.  
- Home network   
- <img src="Docs/Pasted image 20240308155900.png">
  
- FTTH(Fiber To The Home):  
- 광통신을 집 안까지 끌어들여 쓰는 것<img src="Docs/Pasted image 20240308155936.png">
  
- *Ethernet:*  
- **LAN(근거리 통신망) 구축을 위해 장치를 연결하는 데 널리 사용되는 네트워킹 프로토콜**로, 장치가 네트워크를 통해 데이터 패킷을 다른 장치와 교환하여 통신하도록 지원한다. <img src="Docs/Pasted image 20240308160402.png">
  

<br>

### 1.2.3 Wireless Access Networks  

<br>

- Wireless LANs: 빌딘 안에 있다. 흔히 Wi-Fi 라고도 부른다.  
- Wide-area wireless access: 셀룰러 네트워크라고도 한다.  

<br>


<br>

### 1.2.4 Host: Sends Packets of Data  

<br>

`시험에 나올 가능성이 커 보이는군`  
- Packet: 정보의 단위, $`L`$ bit로 이루어져 있다  
- 단위 주의할 것... 
```math
\text{packet transmission delay} = \text{time needed to transmit L-bit packet into link} = \frac{\text{L (bits)}}{\text{R (bits/sec)}}
```
  

<br>

### 1.2.5 Physical Media  

<br>

- 전기적인 신호가 올라갔다 내려갔다 하는 것을 구분하여 bit 데이터를 읽어낸다.  
- Guided media: 물리적으로 가는 것  
- Twited pair(TP): 우리가 가장 많이 접하는 guided media로, 저렴하고, 간섭을 줄이며 많은 통신을 하게 만들었다.  
- Unguided media: 무선으로 공기를 통해 가는 것  
- Coaxial cable: 동축 케이블, TP보다 좀 더 비싸다.<br><img src="Docs/Pasted image 20240313150531.png">
  
- Fiber optic cable: 광섬유의 내부 전반사를 이용하여 데이터를 전달하며 성능이 아주 좋다. 부러지기 쉽기 때문에 보통 지하로 통하는 케이블이다. <br><img src="Docs/Pasted image 20240313150556.png">
  
- Radio: 공기라는 매질을 통해서 정보가 전달된다. Wireless communication이 가능해진다.  
- bidirectional: 이 부분이 기술의 핵심이다. 송수신이 가능한 것  
- 유선 통신에 비해서 어렵다. 그 이유로는 세가지가 있는데, 반사, 장애물, 간섭(회전, 굴절) 등의 문제가 있다.  
- 무선 통신에서 제일 어려운 건 직선 경로로 들어오는 정보는 빠르게 들어오는 반면, 반사 돼서 들어오는 정보는 느리게 들어오는데, 이 차이를 다루는 것이 어렵다.  
- radio link type 들  
- terrestrial microwave: 자상파  
- LAN: WiFi 같은 것. 非-license 이다. 이 전파를 사용하기 위해서 굳이 돈을 낼 필요가 없다.  
- Wide-area: 광범위한 영역을 커버해야하기 때문에 LAN과 달리 license가 필요하다. 특정 주파수를 사기 위해서도 돈이 필요하기 때문이다. `주파수 값이 금값이다..`  
- Hand-off service  
- Satellite: Wide-area 보다 더 넓은 영역을 커버한다.  
 <img src="Docs/Pasted image 20240313152123.png">
  
<img src="Docs/Pasted image 20240313152629.png">
  
- 장파(저주파) --- 단파(고주파)  
- 고주파로 가면 갈 수록 굉장히 많은 정보를 한 번에 보낼 수 있다. 하지만 에너지가 몰려있는 만큼 장애물에 부딪히면 반사될 가능성이 높아진다.  
- 가시광선: visible frequency라고도 하며, 적외선 -- 가시광선 -- 자외선 순으로 나열한다.  
- 바다 및으로 광케이블이 지나다니고 있다..! 신기..  

<br>

## 1.3 Network Core  

<br>

Network core란 그물망 형식으로 연결된 라우터  
Packet-switching(패킷 교환): 현재 인터넷의 표준이다. 작은 블록의 패킷으로 데이터를 전송하며 데이터를 전송하는 동안만 네트워크 자원을 사용하도록 하는 방법이다.  

<br>

### 1.3.1 Packet-switching  

<br>

- Store-and-forward:  
- 패킷 사이즈를 L이라고 하면, 이를 bandwidth 사이즈인 R로 나누어주면 시간 단위가 나오는데, 이것이 데이터를 전송할 떄 total delay가 나온다.  
- Queuing delay, loss:  
<img src="Docs/Pasted image 20240313153757.png">
  

<br>

### 1.3.2 Two key network-core functions  

<br>

- Routing:  
- 출발지에서 목적지까지의 경로를 결정하는 것이다. 이 라우팅 알고리즘을 통해 포워딩 테이블이 생성된다.  
- Forwarding:  
- 라우팅 입력 포트에서 포워딩 테이블에 적힌 목적지 주소에 대응된 출력 포트로 패킷을 이동시키는 것을 말한다.  

<br>

### 1.3.3 Alternative Core: Circuit Switching  

<br>

- 오래 전, 전화선을 사용하던 시절 쓰던 방법  
- 리소스가 dedicated 되어있으므로, 내가 독점해서 쓸 수 있다. 단점은 share해서 쓸 수가 없다. `옛날 전화 안내양을 생각해보자..`  
- FDM vs TDM:  
- FDM: 주파수로 나누기 <img src="Docs/Pasted image 20240313155147.png">
  
- TDM: 시간으로 나누기<img src="Docs/Pasted image 20240313155219.png">
  
`Plus alpha: 헷갈리는 정보`  
그냥 이 슬라이드는 Circuit switching에 집중하지 말고 FDM과 TDM의 설명에만 초점을 맞춰라.  

<br>

### 1.3.4 Packet Switching vs Circuit Switching  

<br>

- Packet wsitching은 더 많은 사람이 네트워크를 사용할 수 있도록 해준다.  
- 아! 막 뒤섞어서 써도 0.0004% 밖에 충돌이 안 나니까 packet switching이 났겠다!  
- `Packet switching 이 완전한 승자인가?`: 그렇다. 단점은 한꺼번에 패킷이 몰리면 문제가 발생할 가능성이 있다는 정도?  
- `Circuit switching 은 안씀?`: 흔히 말하는 "핫라인"이 이 방법을 쓴다. 아예 없는 건 아니다.  
- `체인점 vs 예약제 고오급 레스토랑의 차이랄까...`  

<br>

### 1.3.5 Internet Structure: Network of Networks  

<br>

- Access ISPs가 서로서로 연결되어있는 것이다.  
- 기술적인 것만이 아니라 경제적, 국가적 제도도 고려가 된다.  
- 어케함? 걍 다 연결해!! 는 아니고... 특별한 tree 구조를 만들어낸다.<img src="Docs/Pasted image 20240313160510.png">
  
- IXP: 다중의 ISP들이 서로 피어링할 수 있는 만남의 장소  
- Content provider network(CPN): 특정 지역에다 ISP와 협약을 해서 콘텐츠를 임시 저장해놓고 바로바로 연결해주는 것 (e.g. Google, Microsoft, Akamai..) `대기업의 해외지사 정도로 생각하면 되려나`  
- 전체적인 구조는 다음과 같다.<img src="Docs/Pasted image 20240313161006.png">
  
- POP(Point Of Presence): 네트워크 상호간 또는 개별 네트워크에 대한 접속점 또는 접근  

<br>

## 1.4 Delay, Loss, Throughput in Networks  

<br>

- Delay:  
- *Transmition delay:  패킷 헤더를 조사하고 그 패킥을 어디로 보낼지 결정하는 시간ilnk에 dependence하다. 물리적인 한계에 대한 delay이다.*  
- *Queueing delay: 패킷이 큐에서 링크로 전송되기를 기다리는 시간. 거의 90%를 차지한다.*  
- Propagation delay: 거의 빛의 속도로, 무시해도 될 정도  
- Processing delay: 요즘 기술이 발달해서 이것도 거의 무시해도 된다.  
- 결국 Queueing delay를 제일 신경써야한다.  

<br>

### 1.4.1 Four sources of Packet Delay  

<br>


```math
d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}
```


<br>

자동차가 도로를 주행하는 시간: Propagation delay  
자동차가 톨게이트를 넘어가는 데 걸리는 시간: Transmition delay  

<br>

### 1.4.2 Queueing Delay (Revisited)  

<br>

<img src="Docs/Pasted image 20240315151322.png">
  

<br>

### 1.4.3 Packet Loss  

<br>

- 버퍼라는 것은 용량이 한정되어 있다.  
- 만약에 버퍼가 10MB인데 패킷이 그보다 크면 loss가 일어난다.  
- 이미 어떤 특정한 라우터에 큐가 꽉차서 패킷이 전송되지 못하면 (conjestion) 다시 보내줘야한다.  

<br>

### 1.4.4 Throughput  

<br>

- Throughput: 단위 시간 당 얼마나 많은 데이터가 전송이 되었느냐  
- Instantaneous: 특정한 시간의 throughput `최대 어느 속도를 낼 수 있느냐`  
- Average: 평균적인 throughput `전체적으로 어떤 속도를 내느냐`  
- Link들이 연결되어 있을 때, throughput은 그 링크 중 minimum link에 종속적이다.  
- 여러개가 하나의 link를 공유하고 있을 때, 만약 그 link가 성능이 낮으면 그 link를 전체로 나눈 것이 throughput이 된다.  

<br>

## 1.5 Protocal Layers, Service Models  

<br>

### 1.5.1 Protocol "Layers"  

<br>

- 계층구조는 크고 복잡한 시스템의 잘 정의된 특정 부분을 논의할 수 있게 해주며, 이런 단순화는 매우 중요하다.  
- 시스템이 계층 구조를 가질 때, 그 계층이 제공하는 서비스의 구현을 변경하는 것도 매우 쉽다. 즉, 유지보수가 쉽고 발전이 빨라진다는 것이다.  
- 어떤 한 계층의 구현이 변하더라도 나머지 부분은 변하지 않는다는 것이다.  
- Protocol layer(프로토콜 계층화):  
- 네트워크 프로콜의 설계 구조를 제공하기 위해 설계자가 프로토콜을 구성하는 HW와 SW를 계층으로 조직한 것.  
- 각 계층은 서비스를 실행하며, 다른 계층의 일에는 전혀 관심이 없다. 하위 계층의 서비스를 사용하기도 한다.  
- 계층화의 단점을 굳이 찾자면,   

<br>

### *1.5.2 Internet Protocol Stack*  

<br>

- 인터넷 프로토콜 스택은 5개 계층으로 구성된다.<br><img src="Docs/Pasted image 20240315152710.png">
  
- Application:  
- 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳이다.  
- FTP, SMTP,HTTP  
- Transport:  
- 클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송하는 서비스를 제공한다.  
- TCP, UCP  
- Network:  
- 한 호스트에서 다른 호스트로 `데이터그램(datagram, IP의 전송 단위)`을 라우팅하는 책임을 진다.  
- IP  
- Link:   
- 전체 프레임을 한 네트워크 요소에서 이웃 네트워크 요소로 이동시킨다.  
- Wifi(802.111), PPP, Ethernet  
- Physical:   
- 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동시킨다.  

<br>

### 1.5.3 *ISO/OSI Reference Model*  

<br>

- ISO/OSI reference 모델은 다음과 같은 7개 계층으로 구성된다.<br><img src="Docs/Pasted image 20240315153359.png">
  
- Presentation:  
- Session:  

<br>

### 1.5.4 *Encapsulation*  

<br>

<img src="Docs/Pasted image 20240315153543.png">
  
- Source (Message -> segment -> datagram -> frame)를 만들고 destination을 통해 다시 message로 단순화한다.  

<br>

## 1.6 History  

<br>

### 1.6.1 Internet History  

<br>

- 역사가 그다지 길지 않고, preset부터 6G까지 발전이 매우 눈부시다.  

<br>

# 2. Application Layer  

<br>

## 2.1 Principles of Network Applications  

<br>

### 2.1.1 Some Network Apps  

<br>

- 이런 애플리케이션이 어떻게 인터넷에 적용이 될까?  

<br>

### 2.1.2 Creating a Network App  

<br>

- Application 계층에서 종사하는 개발자들을 "end programmar"라고 한다. `끝에서 종사하니까` 이 사람들은 high-level의 언어를 쓴다. `python, c++ 등..`  
- Network-core device를 신경쓰지 않고 개발하면 되는데, 뒤가 어떻게 돌아가는지 모르고 그저 그 함수만 가져다 쓸 수 있다는 것은 매우 빠르게 애플리케이션을 만들 수 있다.  

<br>

### 2.1.3 Application Architectures  

<br>

- Client Server 구조: 항상 동작하고 있는 서버가 존재하고, 클라이언트라는 다른 호스트들로부터 서비스 요청을 받는다.  
- Server: IP address가 고정되어 자료르 가지고 데이터 센터의 역할을 한다.  
- Clients: IP address가 고정되어 있지 않아 서버와 통신을 주고받는다.  
- P2P 구조: 토렌트, 블록체인 등 중앙집중화된 서버가 존재하지 않는것  
- 각각의 node들이 임시로 연결되어 하나의 네트워크를 구축한다.  
- End system들이 인위적으로 왔다갔다하며 구조를 유지한다.  
- 어? 그러면 클라이언트 서버를 왜 쓰지? A. 요즘 서버가 워낙 성능이 좋아서 병목현상을 커버하고도 남는다..  

<br>

`Plus alpha: Program 와 process의 차이`  
- Program: 하드웨어에 모여있는 명령어의 모음  
- Process: 죽어있는 명령이 로더에 의해서 메모리에 올라가서 CPU가 명령어롤 돌리면 살아난다.  

<br>

### 2.1.4 Sockets  

<br>

- 소켓은 문이다.<img src="Docs/Pasted image 20240315155912.png">
  
- 아래 계층에서 위 계층과 소통을 할 때는 반드시 소켓을 통해 소통해야한다.  

<br>

### 2.1.5 Addressing Processes  

<br>

- 프로세스가 수행되고 있는 다른 패킷으로 프로세스를 보내기 위해서는 수신 프로세스가 주소를 갖고 있어야 한다. 수신 프로세스를 식별하기 위해서는 다음 두가지 정보가 필요하다.  
1. IP 주소: 호스트의 주소  
2. Port 번호: 호스트 내의 수신 프로세스를 명시하는 식별자 `65535개의 프로세스까지 지정 가능하다..!`  

<br>

### 2.1.6 App-Layer Protocol Defines  

<br>

- Open Protocols: 오픈 소스코드 같은 거, 무료 HTTP, SMTP 등  
- Properistary protocols: 그 프로토콜을 쓰려면 특정 회사에게 돈을 내야하는 것 Skype등  
- 어떤 프로토콜이 필요할까? 할 때 고려해야할 것들<img src="Docs/Pasted image 20240315161411.png">
  
- Data integrity(신뢰적 데이터 전송): 데이터가 손실되지 않도록 하는 것  
- Timing(시간): 긴급 전화나 멀티 게임 같이.. 타이밍이 생명인거  
- Throughput(처리율):   
- Security(보안):   
- 이렇게 처리가 돼서 개발에 들어간다.  

<br>

### 2.1.7 Internet Transport Protocols Services  

<br>

- TCP service:   
- 신뢰적인 데이터 전송 서비스  
- 혼잡 제어 방식  
- UDP service:   
- 비연결형  
- 혼잡 제어 방식을 포함하지 않는다  

<br>

## 2.2 Web and HTTP  

<br>

- 웹페이지는 객체들(objects)로 이루어져 있다.  
- 객체는 다음과 같은 것들이 될 수 있다.  
- HTML 파일, JPED 이미지, Java applet, 오디오 파일..  

<br>

### 2.2.1 HTTP Overview  

<br>

- HTTP: hypertext transfer protocol  
- 웹 애플리케이션 계층 프로토콜은 웹의 중심이다.  
- 클라이언트/서버 모델:  
- 클라이언트:   
- 서버:   
- TCP 프로토콜:  
- HTTP 서버는 TCP를 전송 프로토콜로 사용한다.  
1. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다.  
2. 연결이 이루어지면, 브라우저와 서버 프로세스는 각각의 소켓 안터페이스를 통해 TCP로 접속한다.  
3. 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고, 소켓 인터페이스로부터 HTTP 응답 메시지를 받는다.  
- 비상태(stateless) 프로토콜:  
- HTTP 서버는 클라이언트에 대한 정보를 유지하지 않는다.  
- 특정 클라이언트가 몇 초 후에 같은 객체를 두 번 요청해도 서버는 전에 보냈다고 알려주지 않고 객체를 또 보낸다.  

<br>

### 2.2.2 HTTP Connections  

<br>

- 비지속(non-persistent) 연결:<img src="https://user-images.githubusercontent.com/76640167/210491569-3638ca03-2d17-4eea-8a5f-d984bb831d00.png">
  
- 하나의 객체를 보기 위해 TCP connection을 한 번 한다.  
- 2 * RTT + file transmision time  
- 지속(persistent) 연결:  
- 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다. 즉, 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다.  

<br>

### 2.2.3 User-Server State: Cookies  

<br>

- HTTP 서버는 상태를 유지하지 않는다.  
- 로그인을 안해도 사용자에 관한 정보를 제공하자. 어떻게? IP를 통해 전에 무엇을 봤는지 파악해서.<img src="https://user-images.githubusercontent.com/76640167/210499304-190c6dc5-ab64-4864-9f25-bb27fc63f460.png">
  
- Set-cookie: 고유 번호  
- Cookie header line을 통해 정보를 전달하고, 서버는 그 쿠키 파일을 통해 backend database로 사용자 추천 알고리즘을 띄운다.  

<br>

### 2.2.4 Web Caches (Proxy Server)  

<br>

<img src="https://user-images.githubusercontent.com/76640167/210502046-6dbbe817-240d-401d-8ec6-f3a73210e48d.png">
  
- 멀리 떨어져 있는 정보 중 가장 많이 사용하는 정보를 가까이 두게 하자.  
- 장점은 다음과 같다.  
- 클라이언트 요구에 대한 응답 시간을 줄일 수 있다.  
- 웹 캐시는 한 기관에서 인터넷으로의 접속하는 링크 상의 웹 트래픽을 대폭 줄일 수 있다.  
- 인터넷 전체의 웹 트래픽을 실질적으로 줄여주어 모든 애플리케이션의 성능이 좋아진다.  
- 캐싱의 예시는 다음과 같다.  
- 캐싱을 사용 안 했을 때:<img src="https://user-images.githubusercontent.com/76640167/210504713-f02f053c-e503-413f-8cbc-046c55082359.png">
  
- 캐싱을 사용 했을 때:<img src="https://user-images.githubusercontent.com/76640167/210506730-5cb70fea-a9ed-4817-afe0-4463bfd24a4a.png">
  
- 자세한 계산은 깃허브를 참고하자.  
- Queueing theory 상 60% 는 90%에 비해 그다지 부담이 없다.  

<br>

### 2.2.5 Conditional GET  

<br>

- 프록시 서버에서 정보가 modification이 되었는지 주기적으로 확인하는데, 그때의 명령어가 GET이다.  

<br>

## 2.3 Electric Mail: SMTP, POP3, IMAP  

<br>

- SMTP: 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜이다.  

<br>

`Plus alpha: How to Remind`  
- 아 SMTP는 전자메일의 대표적인 프로토콜이고 따라서 애플리케이션 계층이구나!  
- SMTP가 뭐 7 but ASCII 코드를 사용했고 TCP를 사용하고~ 이런 건 굳이 외울 필요 없다.  

<br>

### 2.3.1 Mail Servers  

<br>

<img src="https://user-images.githubusercontent.com/76640167/210542924-1107ca75-eee8-45f6-829a-df0d0df81c15.png">
  
- Mailbox: 수신자의 메시지를 유지하고 관리한다.  
- Message queue: 메일을 수신자의 메일 서버로 전달할 수 없다면 그 메시지를 보관하는 곳.  
<img src="Docs/Pasted image 20240320155525.png">
  

<br>

## 2.4 DNS(Domain Name System)  

<br>

-  호스트 이름(hostname):  
- 사람 호스트의 식별자는 SSN, 이름, 여권 번호 등이다.  
- 인터넷 호스트의 식별자는 `www.goole.com`, `www.facebook.com` 등의 호스트 이름이다.  
- 하지만 호스트의 이름은 인터넷에서의 호스트 위치에 대한 정보를 거의 제공하지 않는다. 또한 가변 길이의 알파뉴메릭 문자로 구성되므로 라우터가 처리하는 데 어려움이 있다.  
- 따라서 우리는 `IP 주소`로 호스트를 식별한다.  
- 사람은 `www.google.com`과 같은 호스트 네임을 선호하지만, 라우터는 고정 길이의 계층구조를 가진 IP 주소를 선호한다. 따라서 이 차이를 절충하기 위해 호스트 이름을 IP 주소로 변환해주는 디렉터리(directory) 서비스가 필요하다. 이 서비스가 바로 **DNS**이다.  
- 따라서 DNS는 애플리케이션 계층의 프로토콜이며, `포트번호 53`을 이용한다.  

<br>

### 2.4.1 DNS: Distributed, Hierarchical Database  

<br>

<img src="Docs/Pasted image 20240320160416.png">
  
`아 끝이 org네? 기관이구나 -> ...`  

<br>

- Root server는 다음과 같은 영역을 커버한다.<img src="Docs/Pasted image 20240320160456.png">
  
- 한국은 `kr`  

<br>

- Root server -> TLC servers -> Authoritative DNS servers  
- 이렇게 찾는다는 건 아니고, local DNS 서버에서 모두 해결이 된다. 웬만한 query는 여기서 커버가 되기 때문이다. 서강대도 DNS 서버가 있다.  

<br>

- DNS 예시<br> <img src="https://user-images.githubusercontent.com/76640167/210620114-71bda09c-0995-410a-b8e1-70ee1c5b76bd.png">
  
- 위 그림에서 `cse.nyu.edu`가 `gaia.cs.umass.edu`의 IP 주소를 원한다고 가정해보자.  
1. 자신의 로컬 DNS 서버에 질의를 보낸다. 이때 변환하고 싶은 호스트의 이름을 같이 보낸다.  
2. 로컬 DNS 서버는 그 질의 메시지를 루트 DNS 서버에게 전달한다.  
3. 루트 DNS 서버는 `edu`를 인식하고, `edu`에 대한 책임을 가진 TLD 서버의 IP 주소 목록을 로컬 DNS 서버에 보낸다.  
4. 로컬 DNS 서버는 TLD 서버에 질의를 보낸다.  
5. TLD 서버는 `umass.edu`를 인식하고, `dns.umass.edu`로 이름 지어진 책임 DNS 서버의 IP 주소로 응답한다.  
6. 로컬 DNS 서버는 작접 책임 DNS 서버로 질의 메시지를 다시 보낸다.  
7. 최종 `gaia.cs.umass.edu`의 IP 주소를 응답한다.  
8. 호스트에 최종 IP 주소를 응답한다.  
- 여기서는 총 8번의 DNS 메시지가 보내졌다.  
- 일반적으로 TLD 서버는 위의 예시와 같이 책임 DNS 서버를 알지 않고, 책임 DNS 서버를 아는 중간 DNS 서버를 알고 있다.  
- 즉, 해당 질의 과정 까지 포함되면 전체 10번의 메시지를 보내게 된다.  
- 위 예는 `재귀적 질의`와 `반복적 질의`를 사용한다.  
- `cse.nyu.edu`로부터 `dns.nyu.edu`로 보내는 질의는 자신을 필요한 매핑을 대신하여 얻도록 `dns.nyu.edu`에 요구하므로 재귀적 질의이고, 나머지는 반복적 질의다.  

<br>

- TTL 서비스: 호스트 DNS와 IP 사이의 매핑과 호스트는 영구적이지 않기 때문에 어떤 기간이 지나게 되면 저장된 정보를 제거한다.  

<br>

## 2.5 P2P Applications  

<br>


<br>


<br>

### 2.5.6 P2P File Distribution: BitTorrent  

<br>

- 비트토렌트(BitTorrent):  
- 비트토렌트는 파일 분배를 위한 인기 있는 P2P 프로토콜이다.  
- 토렌트(torrent):  
- 비트토렌트 용어로 특정 파일의 분배에 참여하는 모든 피어의 모임을 토렌트라고 부른다.  
- 청크(chunk):  
- 파일을 같은 크기(256KB)로 잘게 쪼갠 것이다.  
- 트래커(tracker):  
- 각 토렌트는 트래커라고 부르는 인프라스트럭처 노드를 가지고 있다.  
- P2P - BitTorrent:  
1. p2p방식  
2. 파일을 여러개의 typical size의 chunks로 나누어 peer들에게 배분한다.  
3. peer들끼리 세션을 생성하여 자신이 소유한 chunk정보를 알려주고 상대 peer로부터 필요한 chunk를 요청하여 받는다.  
4. peer가 많아질수록 peer간의 세션 수는 증가하고, 사용자의 다운로드 속도도 늘어나게 된다.  
- 만약 peer가 모든 파일을 받으면, 떠나거나(selfish) 토렌트에 남아 자신이 파일을 업로드(altruistically)해줄 수 있다.  
- Tit-for-tat(현명한 교역):  
- 어느 요청에 응답할지 결정할 때 앨리스가 가장 빠른 속도로 그녀에게 데이터를 제공하는 이웃에게 우선순위를 주는 것이다.  
- 계속해서 비트를 수신하는 속도를 측정하고 가장 빠르게 전송하는 4개의 피어를 결정하고, 이 4개의 피어(unchoked)에게 chunk를 보냄으로써 보답한다.  
- 이는 10초마다 계산하여 집합을 수정한다.  

<br>

## 2.6 Video Streaming and CDNs  

<br>

<img src="Docs/Pasted image 20240322152346.png">
  
- Video traffic:  
- 인터넷 bandwidth 중에서 주요 고객층을 가지고 있다.  
- Challenge:  
- 어떻게 억에 달하는 유저들에게 도달할 것인가?  
- Heterogenenity: 인터넷 환경이 사람마다 느리거나 빠르거나 다 다르다.  
- Solution:  
- Distributed, application-level infrastructure  

<br>

### 2.6.1 Streaming Stored Video  

<br>

### 2.6.2 Streaming Multimedia: DASH  

<br>

- DASH(Dynamic, Adaptive Streaming over HTTP)  
- 기존의 문제점:  
1. 클라이언트는 서버에게 TCP 연결을 설립하고 해당 URL에 대한 HTTP GET 요청을 발생시킨다.  
2. 서버는 기본 네트워크 프로토콜 및 트래픽이 허용되는 대로 HTTP 응답 메시지 내에서 비디오 파일을 전송한다.  
3. 애플리케이션 버퍼에 전송된 바이트가 저장된다.  
4. 버퍼의 바이트 수가 미리 정해진 임계값을 초과하면 재생을 시작한다.  
- 특히, 버퍼에서 주기적으로 비디오 프레임을 가져와 프레임을 압축 해제한 다음 사용자의 화면에 표시한다.  
- 가용 대역폭이 달라도 똑같이 인코딩된 비디오를 전송 받는다는 문제가 있다.  
- DASH:  비디오는 여러가지 버전으로 인코딩 되며, 각 버전은 비트율과 품질 수준이 서로 다르다.  
- 클라이언트는 동적으로 서로 다른 버전의 비디오를 몇 초 분량의 길이를 갖는 비디오 조각 단위로 요청한다.  
- 가용 대역폭이 충분할 때는 높은 비트율의 비디오 버전을 요청하며, 가용 대역폭이 적을 때는 낮은 비트율의 비디오 버전을 요청한다.  
- 즉, 클라이언트는 자신의 상황에 알맞은 비디오 버전을 요청한다.  
- 각 비디오 버전은 HTTP 서버에 서로 다른 URL을 가지고 저장된다.  
- HTTP 서버는 비트율에 따른 각 버전의 URL을 제공하는 `매니페스트(manifest) 파일`을 갖고 있다.  
- 클라이언트는 이 매니페스트 파일을 제공받고,    
- 이에 따라 매번 원하는 버전의 비디오 조각 단위를 선택하여 HTTP GET 요청 메시지에 URL과 byte-range를 지정하여 요청한다.  
- 그러니까, 480p, 1080p 등을 맞춤형으로 제공한다는 것이다. `어 왜 화질 떨어졌어 와이파이 느리나?`  
- "Intelligence" at client:  
- When: `언제 chunk를 요청할거냐`  
- What: `어떤 퀄리티의 인코딩 rate를 요청할 것이냐`  
- Where: `어디에 있는 chunk를 받아올 것이냐`  

<br>

### 2.6.3 Content Distribution Networks  

<br>

> 어떻게 수많은 사용자에게 동영상을 보낼 것인가?  

<br>

- Solutoin: CDN(콘텐츠 분배 네트워크)  

<br>

#### CDN  

<br>

>CDN은 다수의 지점에 분산된 서버들을 운영하며, 비디오 및 다른 형태의 웹 콘텐츠 데이터의 복사본을 이러한 분산 서버에 저장한다.  

<br>

- "Over the Top", OTT challenge: 단순히 케이블 TV만 보는 것이 아니라 유튜브, 위성 방송 등을 모두 볼 수 있는 것  

<br>

## 2.7 Socket Programming with UDP and TCP  

<br>

<img src="Docs/Pasted image 20240322155316.png">
  

<br>

#### Socket  
> 쉽게 말하면 함수라고 생각하면 된다.  

<br>

## 2.8 Charpter 2 Summary  

<br>

<img src="Docs/Pasted image 20240322155741.png">
  
- control vs. messages: 전문가들에게만 중요하지 학부생에겐 실질적으로 중요하지는 않다.  

<br>

#### 예제 1  
Suppose two hosts $`A`$ and $`B`$, are seperated by $`10,000 km`$ and are connected by a dirext link of $`R = 1 Mbps`$.  
Suppose the propagation speed over the link is $`2.5 \cdot 10^8 m/s`$  

<br>

Caculate the bandwidth-delay product, $`R \cdot d_{prop}`$  

<br>


```math
1Mbps \times \frac{10^7m}{2.5 \times 10^8 m/s} = 10^6 bps \times 0.04s = 40,000 \ bits
```

Consider sending a file of $`400,000 \ bits`$ from Host A to Host B. Suppose the file is sent continuously as one large message. What is the maximum number of  bits that will be in the link at any given time?  

<br>


```math
40,000 \ bits
```

Provide an interperetation of the bandwidth-delay product.  
In data communications, the bandwidth-delay product is the product of a data link's capacity(in bits per second)  

<br>

# 3. Transport Layer  

<br>

[컴퓨터 네트워크 3. Transport Layer(1) (velog.io)](https://velog.io/@kms9887/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-3.-Transport-Layer1)  

<br>

## 3.1 Transport-Layer Services  

<br>

논리적으로 직접 연결된 것처럼 생각해라  
정보의 덩어리 **Message**r가 소켓을 통해 들어와서 작게 쪼게진 다음에 **segment** 단위로 쪼개진다. 이 segment에 헤더 정보를 붙여주는데, 이를 **datagram**이라고 한다.  
이제 이게 패킷 단위로 전달된다. 헤더파일을 때고, segment를 다시 붙여줘서 receive된다.  

<br>

TCP/UDP: Transport layer의 표준이다.  

<br>

#### Transport vs. Network Layer  

<br>

- Network layer: hosts 간 통신  
- Transport layer: processes 간 통신  
- Network layer: IP  
- Transport layer: TCP/UDP  

<br>

#### Transport-layer Protocols  
- TCP: 신뢰성 있게 전달, 보낸 그대로 도착하도록, 보낸 순서대로 받는 사람이 받음  
- congestion control (전송 속도 조절)  
- flow control (전송 속도 조절)  
- connection setup (커넥션을 맺어야 통신 가능)  
- UDP: 신뢰성 없음, 중간에 날아갈 수 있음. 보낸 순서 상관 없이 도달  
- no-frills extexsion of "best-effort" IP (그저 전달 역할만 수행한다.)  
- 두 서비스 모두 안 해주는 것들:  
- 딜레이 보장 (언제까지 도달하도록 보장 해주는 것)  
- 속도 유지 보장  

<br>

## 3.2 Multiplexing / Demultiplexing  

<br>

#### Multiplexing at sender  
> 여러 소켓에서의 데이터를 다루기 위해 port 헤더를 붙여서 보내준다.  

<br>

#### Demultiplexing at receiver  
> 헤더를 보고 어느 소켓으로 보낼 지 결정한다.  

<br>

- IP 주소와 port 번호(dest.port#)를 조합하여 처리한다.  
- Connection-oriented Demux:<img src="Docs/Pasted image 20240327153656.png">
  
- 똑같은 소켓 넘버가 있어도 보내는 쪽의 IP 주소와 port번호를 통해서 누가 보낸 것인지를 구분할 수 있다.  
- 즉, Source IP, source port#, dest IP, dest port# 총 네 개의 조합을 통해 구별하게 된다.  

<br>

## 3.3 Connectionless Transport: UDP  

<br>

#### UDP  
> User Datagram Protocol  

<br>

- No frills, bare bones  
- Best effort: 최선만 다함(보장은 안됨)  
- Connectionless  
- DNS, SNMP 이 두 프로토콜이 UDP로 구현되어있다.  
- UDP에 신뢰를 보장하는 방법?: 위에 있는 application layer를 통해서 추가적인 기능을 지원하도록 한다.  

<br>

#### Why Use UDP?  
> Simple, small  

<br>

- 오버헤드가 줄고, connection이 없다는 점이 오히려 장점이 될 수도 있다.  
- 헤더 크기가 작다.  
- TCP는 너무 섬세하게 다뤄진다. 하지만 UDP는 그냥 네트워크 상태에 따라 쏟아부을 수 있다.  

<br>

### 3.3.1 UDP: Segment Header  
<img src="Docs/Pasted image 20240327154342.png">
  
#### Checksum  
> Transmitted된 segment에서 에러 탐지  

<br>

- 16-bit가 두 개만 있다고 가정한다.<img src="Docs/Pasted image 20240327154947.png">
  
- Multiple 에러는 잡아낼 수 없다.  

<br>

## 3.4 Principles of Reliable Data Transfer  

<br>

<img src="Docs/Pasted image 20240327155519.png">
  
- Transfort에서 어떤 작업을 통새 network layer에는 없는 신뢰도를 생성해내는 것이다.  

<br>

#### FSM  
> Finite State Machins는 시스템 동작을 설명하는 방법이다.  

<br>

#### rdt2.0  
- 문제점, duplicate:  
- receiver는 ACK신호를 보내주는 데 이게 NAK신호로 바뀌어버림.  
- handling: add sequence number  

<br>

#### rdt2.1  
- 기존에 있었던 것이 확장되면서 늘어난 것 뿐이다.  
- state가 두 배로 확장된다.  
- 문제점, NAK신호는 필요가 없다.  
- 잘 받았으면 ACK 잘 못받았으면 NAK인데 굳이 ACK가 필요가 있나?  
- -> sequence가 한 번 더 나가면 NAK으로 간주하자  

<br>

#### rdt2.2  
- 문제점, 패킷 loss가 일어나는 경우를 고려를 안 했다.  
- overflow가 일어나 패킷이 없어지는 것  
- 영원히 기다리는 문제점이 기다리는 경우가 생긴다.  
- -> timer를 놓자. 일정 시간이 지나도 아무 역할이 없으면 다시 신호를 보내자.  

<br>

#### rdt3.0  
- timer가 설정되었다. (`timeout`이 추가되었다.)  
- 이제 실생활에 쓸 수 있는 정도이다.  
- duplicate가 일어나도 패킷 넘버(sequence number)가 존재하기 때문에 우리가 그냥 지워주면 된다.  
- 문제점, premature timeout  
- **패킷 두 개가 duplicate된다. (패킷 두 개가 버려진다는 뜻이다.)**  
- time out 때문에 타이밍이 엇갈리는 것이라고 생각하면 된다.  

<br>

이렇게 하면 인터넷이 돌아는 감  
rdt3.0은 correct하나, 퍼포먼스는 최악이다.  

<br>


```math
\frac{15ms}{1Gbps}
```


```math
\frac{8000bits}{1Gbps}
```

단위가 8 *microsec*로 바뀐다.
<br>

$`U_{sender}`$: utilization-단위시간 동안 얘가 어느정도로 사용이 되느냐

```math
U_{sender} = \frac{L/R}{RTT + L/R} = \frac{.008}{30.008} = 0.00027
```

$`RTT`$: 갔다 오는 데 걸리는 시간 ($`15 \times 2ms`$)
$`30msec`$마다 $`1KB`$의 패킷이 생긴다. 초당 $`33kB/sec`$가 생성된다는 뜻이다.
`plus alpha: 단위`  
<img src="Docs/Pasted image 20240403152841.png">
  
위 단위는 잘 알아두자. (nano ~ tera)  
#### Pipeline Protocols  
- rdt3.0은 RTT 동안 아무것도 안 하고 있어서 비효율적이다.  
- 구현하는 방법에는 다음 두 가지가 있다.  
1. **go-Back_N**  
2. **selective repeat**  
- **go-Back-N**:  
- 송신자는 확인 응답을 기다리지 않고 여러 패킷을 전송(가능할 때) 할 수 있다.  
- 그러나 파이프라인에서 확인응답이 안 된 패킷의 최대 허용 수 N 보다 크기 말아야 한다.  
- **selective repeat**:  
- 수신자에서 오류(손실되거나 변조된)가 발생한 패킷을 수신했다고 의심되는 패킷만을 재전송한다.  
- 이를 통해서 SR은 불필요한 재전송을 피한다.  
- 필요에 따라 각각의 개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 개별적인 확인 응답을 요구할 것이다.  
- timer와 이를 저장할 buffer가 필요하다. (overhead.. 말고도 더 치명적인 문제가 있다.)  
- 문제점, window size가 3이고 패킷 3개가 다 잘 들어왔음. 3개의 ACK를 보냈는데 3개의 ACK가 다 loss가 일어남. sender는 receiver의 상황을 모름. sender의 입장에서는 도착하는 ACK의 상황만 보고 상황을 추측함. ACK에 의해 window가 이미 움직인 상태인데 패킷이 안 들어갔다고 생각하고 다시 보냄, 동일한 채킷이 또 들어오게 되는 문제가 생긴다.  
- **What relationship between seq# size and window size to avoid problem?**:  
- 윈도우 사이즈를 줄여야 함 동시에 보낼 수 있는 패킷의 1/2 또는 조금 더 적으면 된다.  
- **What method is used in world-wide?**  
-   

<br>

## 3.5 Connection-Oriented Transport: TCP  

<br>

#### TCP  
> TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스에게 보내기 전에, 두 프로세스가 서로 ’핸드셰이크’를 먼저 해야 하므로 `연결지향형(connection-oriented)`이다.  

<br>

- TCP의 특징은 다음과 같다.  
1. point-to-point  
2. reliable, in-order byte steam  
3. piplined  
4. **full duplex data**  
5. connection-oriented  
6. flow controlled  

<br>

<img src="Docs/Pasted image 20240403155831.png">
  
- port 넘버가 위에 있다.  
- sequence number와 acknowledgement number  

<br>

### 3.5.1 TCP seq. Numbers, ACKs  

<br>

*이 둘, 매우 중요하다!*  
#### Sequence number  
> TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다. (`귤 다섯 개 사과 두 개가 아니라 과일 7개..`)
<br>


```math
\text{sequence number} \neq \text{packit number}
```

#### Acknowledgement Number  
> Sequence number of nuxt byte expected from other side  
> Cumulative ACK  
- 이거 잘 받았으니까 다음으로 받을 seq의 # 라고 생각하면 된다.  

<br>

### 3.5.2 TCP Round Trip Time, Timeout  

<br>

왜 4를 곱하냐? 적당히 톱밥으로 때리는 것..  
물리엔진의 쿠션값이라고 생각하면 되겠음  

<br>

~  

<br>

#### Causes/Costs of Congestion  
#### Scenario 2  
- throuput 패킷이 duplicate 되던 말던 도착한 것만을 세서 계산한 것  
- goodput contents 내용을 보고 duplicate된 것을 빼고 계산한 것  
- 내 전송에 대한 goodput은 변함이 없는데 다른 사람의 goodput은 내려가게 한다 `민폐`  

<br>

#### Scenario 3  
- 어느 부분까지는 $`\lambda _{in}`$을 늘릴 수록 효과가 증가하지만 어느 시점에 도달하면 오히려 효율이 떨어진다.  
- 어느정도 traffic congestion이 일어났으면 $`\lambda _{in}`$을 줄이라는 뜻이다.  

<br>

-> Congestion을 줄여야 한다!  
그렇다면 TCP에서는 이 conjestion을 어떻게 줄일까?  

<br>

## 3.7 TCP Congestion Control  

<br>

#### AIMD  
> **AIMD(additive increase multiplicative decrease)**  
- 처음에는 야금야금 올린다.  
- 만약 congestion이 난 것 같으면 지금까지 한 것의 반을 뚝 잘라버린다.  
- 이 congestion window를 갔다가 조금씩 늘리거나 자르거나 하는 것이다.<img src="Docs/Pasted image 20240405155242.png">
  
- 문제점, Slow Start:  
- congestions wimdow는 거의 1000 크기로 되게 큰데 이 방법은 0부터 시작해서 느리게 올라간다.  
- -> 1, 2, 4, 8 식으로 증가시키자. (TCP Slow Start)  

<br>

#### Slow Start  
> 0부터 시작할 때(slow start)는 1씩 증가시키지 말고 지수함수로 증가시키자.  

<br>

### 3.7.1 ★ Detecting, Reacting to loss  

<br>

- 공통점은 다음과 같다.  
- slow start라면 지수함수로 증가시키자.  
- threshold 값에 도달하면 거기서는 linearly 하게 증가시키자.  
- 차이점은 다음과 같다.<img src="Docs/Pasted image 20240405160333.png">
  

<br>

#### TCP RENO  
> 3 duplicate 일 경우에는 0으로 내리지 말고 window size를 반토막 낸다.  
- thresh는 직전에 정한다 (반토막)  

<br>

#### TCP Taohe  
> timeout /3 duplicate 모두 0으로 내려온다.  
- thresh는 fix 되어있다.  

<br>

### 3.7.2 TCP Fairness  

<br>

- 어떤 bandwidth를 할당하는 것이 fairness를 유지할까?  
- 2개의 연결이 있다면 결국 중심점을 찾을 것이다.<img src="Docs/Pasted image 20240405161127.png">
  
- UDP랑 만나면 UDP가 너무 많이 보내기 때문에 fairness가 성립하지 않는다.  
- TCP라고 fairness를 보장하는 것은 아니다:  
- 만약에 9명이 거의 동일한 수준의 패킷을 생성해서 보내면 9명 사이의 fairness는 보장되지만 1명이 난입하여 거의 10배가 되는 패킷을 요구하면 난입한 1명이 일방적으로 이득을 본다.  

<br>

#### Explicit Congestion Notifination (ECN)  
> Network-assisted congestion control, packet loss 말고도 congestion을 control하는 방법  

<br>

# 4. Network Layer: The Data Plane  

<br>

## 4.3 IP: Internet Protocol  

<br>

현재 인터넷은 GBN으로 이루어져 있습니까 SR로 이루어져있습니까?  
현재 인터넷은 TCP/IP로 이루어져 있다.  
현재 TCP는 GBN 기법으로 / SR 기법으로 이루어져 있다. (둘 다 false)  

<br>

waited queue 비어있다면 넣어주고 아니라면 대기하고 있는 것 `일단 대기표에 넣어두겠습니다.`  
priority queue  

<br>

#### The Internet Network Layer  
> 어떤 네트워크에 어떤 프로토콜이 있는지 알자!  
- network layer에 IP protocol이 있다.  
- network layer에 ICMP: Internet control massage protocol  

<br>

#### IP Datagram Format  
- length가 bit 단위가 아니라 byte 단위로 들어간다.  
- TCP의 오버헤드는 20 byte + IP의 오버헤드는 20 byte  
- 32 bit source IP address  
- 32 bit destination IP address  

<br>

#### IP Fragmentation, Reassembly  
> 하나의 IP datagram을 link의 MTU에 맞게 잘라주는 것이다.  
- Link의 사이즈가 다 다르다. -> 각 링크마다 MTU를 정해놓는다.  
- reassembly를 통해 다시 모은다  

<br>

여기서 offset이 뭐냐?   

<br>

### 4.3.2 IP addressing:   

<br>

#### CIDR: Classless InterDomain Routing  
> 32bit를 둘로 나누어 subnet part와 host part로 나눈다. 8비트 단위로 쪼개서 10진수로 표기한다. `/` 다음의 숫자는 몇 개의 숫자가 subnet part를 지정하는 데 쓰였는지를 나타낸다.  

<br>

### 4.3.3 IP Addresses: How to Get One?  

<br>

방법은 hard-coded가 있고 또...  

<br>

#### *DHCP: Dynamic Host Configuration Protocol*  
> aplication layer로, 서버로부터 주소를 dynamic하게 받는 것이다.  
- 자동으로 새로운 client가 오면 broadcasting을 해준다.  
- plus alpha의 정보를 더 주는데  
- 가장 가까이에 있는 라우터의 주소를 알려준다.  
- DNS 시스템 서버의 이름과 IP 주소를 알려준다.  
- 네가 존자 하고 있는 network address는 어디까지란다.  
- Demultiplexing: overhead가 제거되는 것  

<br>

#### IP Addressing  
> **ICANN**라는 국제 협회에서 주소를 받는다.  

<br>

#### IP Subnetting  
> Subnetwork가 있어야하는 이유? 보안이 좋아지고, 트래픽 control 하기도 좋고 overhead가 준다.  
- A, B, C, D, E 5개의 class로 나눈다. `D와 E는 특별한 경우를 위해 만든 거기 때문에 몰라도 된다.`  
- A: 8 bit (0xxxxxxx) 0 ~ 127 `앞의 8비트만 읽는다면`  
- B: 16 bit (10xxxxxx) 128 ~ 191  
- C: 24 bit (110xxxxx) 192 ~ 223  
- IPv4 subnet mask: subnet 주소 부분만 1(network information)로 하고 나머지는 0(host information)으로 한 뒤 & 연산을 함  
- `90개는 2^6이 아닌 2^7가 커버된다.` 효율을 늘리기 위해 class C에서 1 bit 씩 subnet으로 늘린다. **host의 개수에서 2개는 무조건 뺀다.** 예를 들어 4 bit이면 14개, 6 bit이면 62 개... 그래서 host가 줄면 지수함수 그래프로 주는 것이다.  
- `자세한 내용은 lms 추가 강의자료 예제를 확인하자.`  

<br>

### 4.3.3 NAT: Netwotk Address Translation  

<br>

private IP -> virtual IP  
IP 사오기 아깝다! subnetwork를 net을 설치해서 IP 하나만으로 커버하자.  
port 번호를 붙여서 subnet에서만 돌게하자.  

<br>

IP address와 port 번호를 붙인 걸 가지고 translation을 한다.  
<img src="Docs/Pasted image 20240419151629.png">
  
- port 번호는 16-bit이므로 60,000에 달하는 연결을 하나의 IP로 커버 가능하다.  
- 문제점(철학적), 라우터는 반드시 network layer에서만 작동을 하는데 applicaton 영역을 침법할 수 있다.  
- 문제점, P2P application을 만들 때 충돌할 수 있다.  
- 문제점, 속도가 느려진다.  

<br>

### 4.3.4 IPv6: Motivation  

<br>

늘렸다! 그리고 format을 좀 바꿨다!  
- 40 byte의 헤더파일  
- No fragmentation allowed. source에서 fragmentation을 해서 보내버린다.  

<br>

#### Transition from IPv4 to IPv6  
- IPv6로 신나게 라우터로 보내다가 IPv4 만 라우터에 걸림 -> Tunueling  
- Tunneling:<img src="Docs/Pasted image 20240419152832.png">
  
IPv4로 encapsulation을 시킨다.  

<br>

- IPv6는 한참 업그레이드 중이다. 25% 정도를 점유했다. 왜 이렇게 느리냐? data link layer의 문제이다. higher level에서는 빨리 빨리 바뀌는데 core level에서는 느리게 바뀐다.  

<br>

## 4.4 Generalized Forward and SDN  

<br>

SDN: remote controller  
forwarding table에 색다른 기능 끼워넣어보자.  
-> OpenFlow protocol  

<br>

#### OpenFlow Data Plane Abstraction  
> match + action  
- Router match + action  
- match: longest destination IP prefix  
- action: forward out a link  
- Switch match + action  
- match: destination MAC address  
- action: forward or flood  
- Firewall(방화벽) match + action  
- match: IP addresses and TCP/UDP port numbers  
- action: permit or deny  
- NAT match + action  
- match: IP address ad port  
- action: rewrite address and port  

<br>

물론 overhead가 있지만 이를 통해 얻는 이익은 상당하다.  

<br>

#### Example  

<br>

# 5. Network Layer: The Control Plane  

<br>

Routing algorithm에 대해서 배울 것이다.  
OSPF, BGP, OpenFlow, ODL, ONOS controllers, ICMP, SNMP  

<br>

## 5.1 Introduction  

<br>

#### data plane  
> packet에 어떤 적절한 inupt link로 들어와서 output link로 나가느냐  
> forwarding  

<br>

#### control plane  
> routing 알고리즘으로 source에서 destination까지의 경로를 결정하는 것  
> routing  

<br>

두 가지 접근 방식이 있다.  
1. per-router control: 각각의 individual한 router가 각각의 방법을 가지고 운영하는 것 (전통적 방법)  
2. logically centralized control: 거대한 영역 중의 하나를 책입지고 운영하는 것 (SDN, software defined networking). control plane에 renote하게 떨어져 나갔다(remote conrtoller). 이들이 router 안에 있는 CA(control agent)와 통신하며 포워딩 테이블을 계산한다.  

<br>

## 5.2 Routing Protocols  

<br>

#### Routing protocols  
> determin 'good' path  
- 좋은 경로의 기준은 다음과 같다.  
- least cost, fastest, least congestion  
- SDN은 이 중 어느 기준을 택할지 결정할 수 있다.  

<br>

#### Graph Abstrction of Network  
> Network에서는 다음과 같은 정형화된 표현들을 따른다.  
- graph: G = (N, E)  
<img src="Docs/Pasted image 20240503152301.png" width="300">
  
- N(Node) = set of routers = {u, v, w, x, y, z}  
- E(Edge) = set of links = {(u, v), (u, x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z)}  
- cost: bandwidth과 비례, conjestion과 반비례 관계에 있다. 좋은 link는 이 cost가 minimize 되어야한다.  
- $`\text{cost of path}(x_1, x_2, x_3, ..., x_p) = \Sigma c(x_a, x_b)`$  
- routing algorithm은 여기서 least cost path를 찾는 것이다.  

<br>

#### Routing Algorithm Classification  
> Global / Decentralized information  
> Static / Dynamic  
- Global: 모든 link와 router에 대한 정보를 가지고 있어야 한다.  
- **Link state** algorithms `Dijkstra algorithm`  
- Decentralized: 자기 주변에 있는 정보(neighbor)만 가지고 routing path를 찾는다. 이웃의 정보를 업데이트 해나간다.  
- **distance vector** algorithms `Bellman-Ford algorithm`  
- `Static(천천히 바뀜), Dynamic(바로 바뀜)`  

<br>

### 5.2.1 Link State Algorithm  

<br>

#### Link State Algorithm  
> 네트워크 topology와 모든 link cost가 알려져 있다는 가정 하게 link state 알고리즘의 입력값으로 사용될 수 있다.  

<br>

#### Dijkstra Algorithm  
> 다익스트라 알고리즘은 하나의 노드(출발지, `u`라고 지칭)에서 네트워크 내 다른 모든 노드로의 최소 비용 경로를 계산한다.  
- 모든 정보를 가지고 있다는 가정 하에, 각각의 노드는 자신을 root라고 생각하고 tree를 만든다. 그 tree 정보를 가지고 forwarding table을 만든다.  
- Notation  
- `c(x, y)`: 연결되어있지 않으면 infinity를 넣는다.  
- `D(v)`: 알고리즘의 현재 반복 시점에서 출발지 노드부터 `목적지 v`까지의 최소 비용 경로의 비용  
- `p(v)`: 출발지에서 v까지의 현재 최소 비용 경로에서 v의 직전 노드  
- `N'`: 최소 비용 경로가 확실하게 알려진 노드의 집합  

<br>

<img src="Docs/Pasted image 20240503154638.png" width="600">
  
```
0: 직접 연결된 v, w, x를 제외한 y, z에는 infinity를 부여한다.
1: 7, 3, 5 중 minimum을 찾아 해당 노드를 N'에 넣고 (경로 결정 완료), v의 값이 w 경로를 통한 최적 값인 6으로 바뀐다. 또한 y로 가는 경로가 생긴다.
2: 6, 5, 11 중 minimim을 찾아 해당 노드를 N'에 넣고 (경로 결정 완료), z로 가는 경로가 생긴다.
3: 6, 11, 14 중 minimum을 찾아 해당 노드를 N'에 넣는다 (경로 결정 완료).
4, 5 반복
```
-> root node를 제외한 node 개수만큼 반복하면 유일한 경로가 결정이 된다.  

<br>


<br>

<img src="Docs/Pasted image 20240503155437.png" width="600">
  
```
같은 값 2, 4, 2이 있다. 사실 어느 것을 뽑아도 최적 경로를 결정하는 데는 문제가 없다.
```

<br>

최종 forwarding table은 다음과 같이 나타낼 수 있다.<img src="Docs/Pasted image 20240503155735.png" width="300">
  

<br>

#### Performance (n nodes)  
> $`O(n^2)`$ (worst case)  
> $`O(n \log n)`$ (more efficient implementation)  
- 문제점, oscillation:  
- 만약 support link cost가 carried traffic과 동일한 경우, 트래픽의 방향이 시계방향, 반시계방향을 반복하며 계속 업데이트된다.  

<br>

### 5.2.2 Distance Vector Algorithm  

<br>

#### Distance Vector Algorithm  
> 오늘날 실제로 사용되는 알고리즘으로써, DV 알고리즘이라고도 한다.  
> Link state 알고리즘과 달리 반복적이고 비동기적이며 분산적이다.  
1. 분산적(distributed): 각 node는 하나 이상의 직접 연결된 이욱으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 이웃들에게 베포한다.  
2. 반복적(iterative): 이웃끼리 더 이상 정보를 교환하지 않을 때까지 process가 지속된다.  
3. 비동기적(asynchronous): 모든 node가 서로 정확히 맞물려 동작할 필요가 없다.  
- *link cost가 실시간으로 바뀐다는 큰 특징이 있다.*  

<br>

#### Bellman-Ford Equation
<br>

$`d_x(y) = min_v \ \{c(x, v) + d_v(y)\}`$
- `min_v`: x의 모든 이웃 v에서   
- `c(x, v)`: neighbor v로 가는 cost  
- `d_v(y)`: v에서 y로 오는 cost  

<br>

<img src="https://user-images.githubusercontent.com/86337233/213214092-9b56f797-4182-43fa-baff-98f56be140a8.png" width="300">
  
#### 문제점, Count-to-Infinity  
> x로 가기 위해 y는 z로 경로 설정을 하고, z는 y로 경로 설정을 하는 routing loop가 발생한다.  

<br>

#### 해결, Poisoned Reverse  
> 만약 z가 y를 통해 목적지 x로 가는 경로 설정을 했다면, z는 y에게 x까지의 거리가 무한대라고 알린다.  

<br>

### 5.2.3 LS vs DV  

<br>

|                      | LS                                                                     | DV                                                                          |  
| :------------------: | :--------------------------------------------------------------------- | :-------------------------------------------------------------------------- |  
|  message complexity  | $`O(nE)`$                                                                | convergence $`t`$ varies                                                      |  
| speed of convergence | $`O(n^2)`$ ($`O(n(\log n)`$)까지 가능)                                         | routing loop -> count-to-infinity                                           |  
|      robustness      | - node는 잘못된 cost 정보를 broadcast할 수 있다.<br>- 각 node는 자기 자신의 table만 계산한다. | - node는 잘못된 최소 cost 경로를 broadcast할 수 있다.<br>- 각 node의 table이 다른 node에서 쓰인다. |  

<br>

## 5.3 Intra-AS Routing in the Internet: OSPF  

<br>

네트워크를 동일한 routing algorithm을 수행하는 동종의 router 집합으로 간주하는 관점은 다음의 두 가지 문제점이 존재한다.  
1. Scale(확장):  
Router의 수가 증가함에 따라 routing 정보의 통신, 계산, 저장에 필요한 overhead가 걷잡을 수 없이 증가한다.  
2. Adminitrative Autonomy(관리 자율성):  
각 network 관리자는 자신의 network에서 routing을 제어하기를 원할 수 있다.  

<br>

#### Autonomous System, AS  
> 위의 문제점들을 router들을 자율 시스템(autonomous system)으로 조직화하여 해결할 수 있다.  
- 각 AS는 동일한 관리 제어 하에 있는 router의 그룹으로 구성된다.  
- 각 AS는 고유한 AS 번호, ASM으로 식별된다.  
- 같은 AS 안에 있는 router들은 동일한 routing algorithm을 사용하고 상대방에 대한 정보를 갖고 있다.  
- AS 내부에서 동작하는 routing algorithm을 Intra-AS라고 한다.  

<br>

#### Intra-AS Routing, IGP  
<img src="Docs/Pasted image 20240508155721.png" width="350">
  

<br>

### 5.3.1 OSPF (Open Shortest Path First)  

<br>

#### OSPF  
> Link state 정보를 플러딩(flooding)하고 Dijkstra 알고리즘을 사용하는 link state algorithm이다.  
- Hierarchical OSPF  
1. Two-level hierarchy: Local area, backbone  
Link-state는 지역 내에서만 advertise한다.  
각각의 node는 세부 area topology가 있다. 다른 area의 net에 대한 방향(최단 경로)만 알고 있다.  
2. Area border routers: 자신의 지역에 있는 neㅅ까지의 거리를 요약하고 다른 지역 border router에 advertise한다.  
3. Backbone routers: OSPF routing을 쓰는 경계  
4. Boundary routers: 다른 AS로 연결  

<br>

## 5.4 Inter-AS Routing among the ISPs: BGP  

<br>

#### BGP Terms  
- AS-PATH:  
prefix advertisement가 통과하는 AS들이 list를 담는다.  
메시지의 loop를 감지하고 방지하기 위해 활용한다.  
- NEXT-HOP:  
AS-PATH가 시작되는 router interface의 IP adress  

<br>

#### BGP Route Selection  
> Intra-routing과는 다르게 굉장히 정치적인 고려를 해야한다.  
1. 로컬 기본 설정 값 속성: 정책 결정  
2. 최단 AS-PATH  
3. 가장 가까운 NEXT-HOP router: `hot potato routing`  
4. 추가적 기준..  

<br>

#### Hot Potato Routing  
> 가능한 모든 경로 중, 경로 각각의 시작점인 NEXT-HOP 라우터까지의 경로 비용이 최소가 되는 경로를 선택한다. (거시적으로 봤을 때 손해이더라도)  
- Hot potato routing은 오로지 자신의 경로 중에서 자기 AS 내부 비용만 줄이려는 이기적인 알고리즘이다.  
- 이를 사용하면 한 AS 내 2개의 router가 동일한 목적지 주소에 대해 각기 다른 AS 경로를 선택할 수도 있다.  

<br>

#### Advertisement를 통한 policy 달성  
> ISP가 가능한 path를 자신의 이익에 따라 막아버리는 것이다. (보내는 쪽도 받는 쪽도 내 고객이 아님)  

<br>

#### Intra-AS routing vs Inter-AS routing  
|             |    Inter-AS    |       Intra-AS       |  
| :---------: | :------------: | :------------------: |  
|   Policy    |       O        |          X           |  
|    Scale    |                |                      |  
| Performance | Policy effects | Focus on performance |  

<br>

## 5.5 The SDN Control Plane  

<br>

#### Software Defined Networking(SDN)  
20 세기 monolithic router: 하나의 라우터로써 완벽한 것  
20 세기 말 network layer를 두개로 나누자! -> SDN  

<br>

##### Data Plane & Control Plane  
- Data Plane:   
네트워크릐 스위치들로 구성된다.  
자신들의 flow table 내용을 기반으로 'match plus action'을 수행한다.  
- Control Plane:   
서버와 스위치들의 flow table을 결정, 관리하는 SW로 이루어진다.  

<br>

### 5.5.1 OpenFlow Protocol  

<br>

#### OpenFlow Protocol  
> SDN 컨트롤러와 SDN으로 제어되는 스위치 또는 OpenFllow API를 구현하는 다른 장치와의 사이에서 동작한다.  
- OpenFlow protocol은 TCP 상에서 default port number `6653`을 가지고 동작한다.  

<br>

##### Analogy for Understanding: Mainframe to PC  
- Mainframe:  
{ App, OS, Hardware } `Vertically integrated`  
Slow innovation, Small industry  
- PC:  
App | OS | Microprocessor `Horizontal Open Interfaces`  
Rapid innocation, Huge industry  

<br>

##### Traffic Engineering  
- Link weight에만 집중하는 control이 좀 잘못된 것 같다.  
- 서로 다른 경로로 load balancing을 맞춰서 전달하고 싶다.  
- Priority가 같더라도 경로가 다를 때 이를 별개로 취급하고 싶다.  
-> SDN으로 해결 가능  

<br>

<img src="Docs/Pasted image 20240510154702.png" width="550">
  
<img src="Docs/Pasted image 20240510154755.png" width="550">
  

<br>

northbound API: control plane과 통신  
south bound API: data plane과 통신  

<br>

##### Data Plane Switches  
> SDN control이 되어있는 스위치 기능을 해주는 하드웨어들  
##### SDN Controller  
> Network OS  
##### Control Applications  
> Routing, load balance, access control과 같은 부분이 있다.  

<br>

<img src="Docs/Pasted image 20240510155037.png" width="250">
 <img src="Docs/Pasted image 20240510155052.png" width="180">
 <img src="Docs/Pasted image 20240510155109.png" width="180">
  

<br>

reference  
[네트워크 : SDN - (2) (tistory.com)](https://inyongs.tistory.com/75)  

<br>

#### ICMP: Internet Control Message Protocol  
> Host와 router가 서로 간에 network layer 정보를 주고받기 위해 사용된다.  
- ICMP massage는 type과 code 필드가 있고, ICMP message의 발생 원인이 된 IP datagram의 header와 첫 8bute를 갖는다. `송신자가 오류를 발생시킨 packet을 알 수 있도록 하기 위해서 또는 다른 목적`  
- 중요한 ICMP message types: <br><img src="https://user-images.githubusercontent.com/86337233/213726337-f62a70cd-a7c6-4384-91e5-c692228d6fa0.png" width="300">
  

<br>

#### Network Management and SNMP  
> Management Information Base(MIB)  
- MIB:  
MIB 객체는 SMI라고 하는 데이터 기술 언어로 명세되는데, 이 이름은 그 기능에 대한 아무런 힌트를 주지 않는 다소 엉뚱한 이름의 netwotk management framework 구성요소이다.  

<br>

# 6. The Link Layer and LANs  

<br>

## 6.1 Introduntion, Services  

<br>

## 6.2 Error Detection, Correction  

<br>

## 6.3 Multiple Access Protocols  

<br>

### 6.3.1 Types of Links  

<br>

#### Point-to-Point Link  
> 링크의 한쪽 끝에 한 송신자와 링크의 다른 쪽 끝에 한 수신자가 있다.  
- Ethernet 스위치 사이에 존재한다.  

<br>

#### Broadcast Link  
> 동일한 하나의 공유된 Broadcast 채널에 다수의 송신 노드 및 수신 노드가 연결된다.  
- 옛날 Ethernet 이다.  
- 업스트림 HFC  
- 802.11 무선 LAN  

<br>

### 6.3.2 Multiple Access Protocol  

<br>

**문제점, Collision**:  
한 개의 매질을 두 개의 노드가 동시에 쓰려고 시도하여 발생하는 문제  
즉, 전송된 프레임들이 각 수신자에서 충돌하게 되고 어떤 수신 노드도 전송된 프레임의 의미를 파악할 수 없게 된다.  

<br>

**해결책, Multiple Access Protocol (MAC)**:  
노드가 채널을 공유하는 방법을 결정하는 분산 알고리즘  
즉, 노드가 언제 전송할 수 있는지를 결정하는 알고리즘이다.  
- in of band: 채널 공유에 대한 커뮤니케이션은 채널 자체를 사용해야 하는 것  

<br>

#### Ideal Multiple Acess Protocol  
> Broadcast channel of rate $`R \ bps`$  
1. 단 하나의 노드가 전송할 데이터가 있을 때는 그 노드가 $`R \ bps`$의 처리율을 갖는다.  
2. $`N`$개의 노드가 전송할 데이터가 있을 때는 각 노드가 $`R/M \ bps`$의 처리율을 갖는다.  
3. Fully decentralized:  
- 분산되어 있어 고장으로 인해 전체 시스템을 정지시킬 수 있는 마스터 노드가 없다.  
- Clock과 slot의 synchronization이 없다.  
4. 단순해서 구현하는 데 비용이 적게 든다.  

<br>

#### Taxonomy: MAC protocol  
> 세 개의 broad class가 있다.  
- Channel partitioning:  
채널을 특정 기준(time slots, frequency, code)에 따라 조각내는 것이다.  
- TDMA(시분할 다중화)  
시간을 time frame으로 나누고 각 frame을 N개의 time slot으로 나눈 뒤 N개의 노드에게 slot을 각각 할당한다.  
- FDMA(주파수 분할 다중화)  
R bps의 채널을 R/N의 대역폭을 갖는 다른 주파수로 나눠서 각 주파수를 N개의 노드에게 각각 할당한다.  
- Random access  
채널을 조각내지 않고 충돌을 허용하고 충돌이 일어나면 "recover"한다.  
- slotted ALOHA  
Collision이 일어나면 각각의 노드를 모두 보내질 때까지 p만큼의 확률로 보낸다.  
+) 구현이 간단  
+) 노드가 하나면 100%의 효율을 낼 수 있다.  
-) collision, slot 낭비  
-) cloak sync  
- ALOHA  
- CSMA, CSMA/CD, CSMA/CA  
- "Taking turns"  
노드가 차례를 잡는다. 보낼 것이 더 많은 노드는 더 오래 걸릴 수 있다.  

<br>


<br>

#### Random Access: CSMA/CD  
- binary bcakoff 알고리즘 알기  
- ALOAHA보다 간단하고 싸고, decentralized하다.  

<br>

#### Random Access: CSMA/CA  
- refernce - LMS의 youtube 링크  

<br>

#### "Taking turns"  
- 트래픽이 높을 때는 효율적이다.  
- 트래픽이 낮을 때는 random access하게 한다.  
-> 이 두 가지의 장점을 수용하여 Taking turns를 만들어보자!  

<br>

1. Polling: 순차적으로 polling에서 보낼 사람이 있다면 access하게 하는 것.  
제어하는 게 있어야되기 때문에 좋지 않다.  
2. Token Passing: 보낼 게 없으면 다음 사람에게 권한을 넘긴다.  
제어하는 게 없어도 된다.  
그러나 token이 왔다갔다 하는 것이 overhead이다.  

<br>

## 6.4 LANs  

<br>

### 6.4.1 Addressing, ARP  

<br>

우리가 여지껏 알 던 address는 IP였다. 그러나 이 외에도 IP address(Network Layer)와 묶여 쓰이는 MAC address(Data link Layer)가 있다.   

<br>

#### MAC addresses & ARP  
> Network 계층에서 쓰이는 주소이다.  
> Switch output에서 어느 link로 가야하는지 알려주는 address이다.  
- 48 bit, flat address(not hierarchy)  
- IP 주소는 dynamic하게 바꿀 수 있지만, MAC 주소는 fix 되어있다.`LAN 카드에 있음, LAN address` (IP 주소는 우편 주소 같은 것, MAC 주소는 주민등록번호 같은 것)  
- MAC 주소는 IEEE에서 관리한다. LAN 카드를 만드는 회사에서 고유 번호를 부여해달라고 여기에 부탁하는 것이다.  

<br>

아, 각각의 Host는 IP와 MAC, 이 두 가지 주소가 조합되어 만들어지는구나.  

<br>

#### ARP: Address Resolution Protocol  
> 쉽게 말하면 database로, IP address와 one-to-one mapping이 되는 MAC, 그리고 TTL이 들어간다.  
- 라우터 같은 데다가 ARP table을 자동적으로 생성하고 유지하게 해준다.  
- TTL(Time To Live): 20분 정도 안 쓰인(hit이 일어나지 않음) IP와 MAC을 자동적으로 삭제해주는 것  
- A라고 하는 Device가 어떤 Data를 B로 보내고 싶을 때 맨 처음에는 B의 MAC address를 모른다. B의 IP주소는 알고있기에 이로 `FF-FF-FF-FF-FF-FF` broadcast를 해 MAC address를 찾는다. 모든 device에게 보내는 것이다. 다른 device는 이를 무시하고, 자신의 IP 주소를 본 B는 자신의 MAC 정보를 A에게 다시 알려준다. `plug-and-play: 걍 알아서 해줄게~`  
- A에서 B로 가는 건 한 hop이 아니기 때문에 (중간에 라우터 있음) **한 hop 갈때마다 MAC이 한 번씩 쓰이고 버려진다.** R에서 비어있는 MAC의 자리를 dest IP를 보고 채워준다.  

<br>

### 6.4.2 Ethernet  

<br>

#### Ethernet  
> 기술 이름으로, wired LAN을 위한 기술을 통칭하는 이름이다. 천하통일 한 기술이다.  
- LAN 카드 안에서 구현될수도, single 칩으로 구현될 수도 있고 가볍고 싸다.  
- 10 Mbps - 10 Gbps까지 커버한다.  
- Topology  
1. Bus(옛날): Collision이 일어나 속도가 줄어드는 문제가 있었다.  
2. Star(현재): Bus에 비해 충돌이 적게 일어난다. 각각의 host와 연결된 spoke가 분리된 ethernet protocol을 운영한다.`장비빨..`  

<br>

### 6.4.3 Switches  

<br>

#### Switch(Ethernet Switch)  
> Data link 계층을 대표하는 장치로, Ehernet이 천하통일 했기 때문에 Ethernet switch라고도 불린다.  
- CSMA/CD로 구현되어 있다.  
- plug-and-play, self-learning  
- Switch forwarding table  
A가 A'로 가는 link를 어떻게 알지?  
-> self running을 통해서 ARP table을 만들어서 안다.  
1. (A, 1, 60): Sorce A가 1번 interface에 연결되어 있다.  
2. Broadcasting (나머지 정보는 다 버린다. `A': 나 여깄어요~`)  
3. (A', 4, 60): A'으로 갈 때는 4번 interface로 가자.  
4. ...  
이런 식으로 APR table이 쭉 쌓이는데, 연결된 device가 많다보니 정보 과부하가 걸릴 수 있어 TTL로 정보를 삭제해주는 것이다.  
- Frame filtering/forwarding  
너 A'에 간다 했는데 dest가 같은 LAN에 존재하는 거 같은데? -> drop frame  
cable이 존재하지 않음 -> flood  
- Self-learning, forwarding  

<br>

#### Switches vs. Routers  
|                       Switch                       |                Router                |  
| :------------------------------------------------: | :----------------------------------: |  
|                     Link Layer                     |            Network Lager             |  
| Computing이 되어 forwarding table이 계산이 된다(다익스트라 알고리즘) | Running이 되어 forwarding table이 만들어진다. |  

<br>

### 6.4.4 VLANS  

<br>

난 CS인데 물리적으로 EE에 있음... 근데 떨어져있는 CS와 한 곳에 있는 것처럼 연결되고 싶음  
-> 물리적으로 떨어져 있지만 논리적으로 하나의 LAN으로 연결해서 운영하고 싶다.  

<br>

이전에는 Local network area는 physically 연결되어 있었다.  

<br>

#### VLANS  
> 물리적으로 하나인 Switch를 두 개인 것처럼 나눠서 쓰자! 를 소프트웨어적으로 구현한 것  
- Port-based VLAN  
<img src="Docs/Pasted image 20240524160252.png" width="300">
  
Switch 안에서 분리되어있는 port 사이를 넘어가고 싶으면 router를 통해서 들어가야 한다. 먼 길을 돌아가는 것이다.  
- Truck port: 여러 물리적 스위치를 통해 정의된 VLAN 간에 frame을 전송한다.  
<img src="Docs/Pasted image 20240524160315.png" width="500">
  

<br>

## 6.5 Link Virtualization: MPLS  

<br>

이전에는 LAN을 Virtualization을 해봤다. 이제 Link를 Virtualization 해보자.  

<br>

#### MPLS: Multiprotocol Label Switching  
> 프로토콜 이름이 아니라 기술 이름으로, 공용선(back-bone 망)를 전용선을 쓰는 것 처럼 virtualize하는 것이다.  
- 특별한 Router를 깔고, 그에 반응하는 MPLS header라는 20비트 헤더를 만들고 그 안의 `label`을 읽어들여서 전용선처럼 보내는 것이다.  
- Label-switched router: IP address만 읽지 않고 MPLS header가 있으면 그걸 읽어들인다.  
- MPLS forwarding table: 자기들만의 라우팅 table을 또 새로 만든다.  
- 어느정도의 퀄리티 서비스를 보장한다.  
- 어떤 router가 망가지거나 conjestion이 일어날 것 같으면 어디로 가야할 지 추가적인 경로가 미리 설정되어있어 빨리 대응할 수 있다.`traffic engineering`  

<br>

#### MPLS vs IP  
|          IP          |               MPLS               |  
| :------------------: | :------------------------------: |  
| Dest 주소만으로 경로가 결정된다. | Source 및 dest 주소를 기준으로 경로가 결정된다. |  

<br>

#### MPLS Signaling, Forwarding Tables  
- Forwarding table:  
한 forwarding table의 output label이 dest router의 forwarding table의 input label이 된다.  

<br>

## 6.6 Data Center Networking  

<br>

#### Data Center  
> 한마디로 큰 건물로, 층층이 컴퓨터가 들어가 있다. `씬커에서 테러 당했던 건물을 생각해보자.`  
> 중앙관제센터 같은 것이다.  
- 냉각을 위한 전기에너지 소모율이 어마어마하다.  
- Networks, Load balancer:  
한쪽 서버에 traffic이 몰리지 않도록, 서버가 동일한 overhead를 가지도록 관리해줘야 한다. 다음과 같은 계층 구조를 가진다.  
- Tier-1 switches  
- Tier-2 switches  
- TOR switches  
- Server racks  

<br>

## 6.7 A Day in the Life of a Web Request  

<br>

여태까지 배웠던 것을 예시를 들어 총정리 해보자.  

<br>

카페에 들어가서 와이파이에 접속하고 구글에 들어가보자.  

<br>

카페에 왔다.  
노트북 전원을 켜서, network 연결 버튼을 누르면 DHCP protocol이 application 계층에서 돌아간다. UDP -> IP -> Ethernet을 거쳐 brodcast가 된다.  
host는 임시 IP address를 할당해달라고 요청한다.  
DHCP 서버는 이를 받아 받은 패킷을 denux한다.  
서버가 IP 주소를 할당해준다. 다시 헤더파일이 붙어 encapsulation된다.  
first-hop router의 주소와 DNS서버의 IP 주소를 포함한다.  
이를 받아 host는 자신의 임시 IP 주소와 first-router 주소를 알게 된다.  
first-hop router주소의 MAC 주소를 알아야 된다. `ARP protocol`  
divice가 first-hop router의 MAC 주소를 알면 이를 이용하여 DNS 서버에 google의 주소를 알려달라한다.  
DNS 서버는 이를 받아 받은 패킷을 denux한다.  
google의 주소를 host에게 보내준다.  
HTTP 서비스를 하기 위해서 TCP IP connection을 해야된다.  
TCP SYN segment를 보내면 handshake를 통해 google로 접속해도 된다는 connection이 완성된다.  
첫번째 화면에 대한 요청, HTTP request가 들어간다.  
구글 서버는 이를 받아 허용하는 패킷을 보내주면 host는 이를 받아 demux하여 드디어 google front page를 열 수 있게 된다.  

<br>

웟더..  

<br>

사실 여기서 종강해도 된단다. `(해줘)`  
하지만 아직 배우지 못한게 남아있다. `(Why..)`  

<br>

# 7. Wireless and Mobile Networks  

<br>

`죽여줘`  

<br>

#### Background you Need  
- 20년 전만해도 $`wireless:wire = 5:1`$이었다. 현재는 더 하다는 뜻이다.  
- Wireless == Mobility? No!:  
Wireless: wireless link에 대한 이야기이고, 주로 전자공학과가 배우는 것이기에 많이 알 필요 없다.  
Mobility: CS가 기여할 수 있는 분야가 바로 이것이다. 여기저기를 돌아다녀도 통신이 끊이지 않고 서비스 할 수 있도록 하자는 것이다. 역사가 실지 않고 비교적 최근 주제이다.  

<br>

## 7.1 Introduction  

<br>

#### Wireless Network  
> 우리가 무선으로 통신하는 것은 맨 끝단의 one hop이고, 나머지는 모두 유선으로 통신된다.  
- 핸드폰 보면서 걷지는 않지 않는가? wireless 기기를 가지고 있어도 움직이지 않는다면 그것은 stationary한 상태라고 한다.  
- Base station:  
Access point라고도 하며, wireless 통신 임계점 너머 Wired network로 넘어가는 부분이다.   
- Wireless Link:  
전자파 적인 것이라고 생각하자.  
Multiple access protocol로 제한되어있는 link access를 효율적으로 사용하자.  
접근도 힘들고 인구가 적은데 굳이 기간망을 설치해야 합니까? -> base station끼리 무선으로 연결하자! (Mash net)  
`8p.표 x축: data rate wireless link가 커버하는 영역 (802.11, 802.15(불루투스))`  
- Handoff: 연결할 base station을 넘어갔는데 할당 할 수 있는 가용 network가 없을 때 생긴다.  
- Blocking: 처음 연결이 안되는 것  
- Dropping: 전화하다 끊기는 것  
-> Bandwidth reservation을 해야 된다.  
- Ad hoc mode:  
Mobile device끼리 임시로 모여서 운영하다 다시 흩어지는 network, infrasturcture가 필요없다.  
<img src="Docs/Pasted image 20240529160441.png" width="500">
  
infrastructure도 없는데 통신 (파도타기 느낌인가..?)  
- MANET(Mobile Ad hoc Network)  
- VANET(자동차 끼리의 통신)  
- Wifi < WiBro < WiMax  

<br>

## 7.2 Wireless Link Characteristics  

<br>

- Decreased signal strength:
<br>

$`\text{거리}^2`$d에 비례해서 강도가 기하급수적으로 감소한다.  
- Interference from other sources:  
같은 주파수를 쓰게되면 간섭이 일어나는 것.  
- Multipath Propagation:  
장애물에 부딪혀 반사가 일어나서 시간차를 두고 접속하게 되는 것.  

<br>

#### SNR & BER  
> SNR과 BER은 반비례 관계에 있다.  
- 통신 link에서 비트 오류율(BER)에는 신호 대 잡음비(SNR, Signal-toNoise Radio)가 영향을 미친다. `다른 부가적 영향도 있다. 송수신 간 거리, link 상태 등..`  
- A와 C는 장애물이 있어 통신을 할 수 없어 어쩔 수 없이 B를 통해 통신하게 된다. 이 때 collision이 일어난다.  

<br>

### 7.2.1 Code Division Multiple Access (CDMA)  

<br>

#### CDMA  
> 여러 사용자가 단일 통신 자원(주파수 대역)을 공유하면서 동시에 이용하기 위한 방식 중 하나로, 사용자마다 고유한 코드를 이용한다.  
- 한정된 자원을 굉장히 효울적으로 쓸 수 있는 기술로, 이론상으로 도청이 불가능하다.  
- CDMA encode/decode  
- Encode signal: 사용자마다 sequence code가 부여되고 이를 이용해 encoding해서 암호처럼 변환되어 나간다. 따라서 도청해도 불가능 한 것이다. `original data * chipping sequence`  
- Decoding: encoding된 코드를 sync를 맞춰서 decode해서 original 정보가 그대로 들어온다. `외국에 가서 시끄러운 거리를 걷는데 한국어가 문득 들리는 상황을 상상해보자.`  

<br>

#### Simple Idea of Communication with code  
```
-1 1(+1, +1, +1, +1)
    (-1, -1, -1, -1)

-1 2(+1, -1 +1, -1)
	(-1, 1, -1, 1)

 0 3(+1, +1, -1, -1)
	( 0,  0,  0,  0)

+1 4(+1, -1, -1, +1)
	(+1, -1, -1, +1)
---------------------
*   (-1, -1, -3, +1)   --> 뭔 뜻임? (도청해봤자 모름)

    (-1, -1, -3, +1)   2번째 device의 receiver
    (+1, -1, +1, -1)   chip sequence
---------------------
    (-1, +1, -3, -1) = -4 / 4 (total user) = -1
```

<br>

## 7.3 IEEE 802.11 wireless LANs ("Wi-Fi")  

<br>

#### IEEE 802.11 Wireless LAN  
> 802.11은 Wireless LAN을 커버하는 Protocol로, CSMA/CA 기술을 사용한다.  
- Wireless host  
- base station(access point)과 통신한다.  
- Infrastucture가 없다는 것은 hub, switch or router가 없다는 것이다.  
- Access Point(AP)가 있고 device가 있다.  
- Passive Scanning: 연결 시 Access Point가 먼저 신호를 보내는 경우  
- Active Scanning: Device가 먼저 신호를 보내는 것이 있다.  
- Collision을 피하기 위해 CSMA/CA(Collision Avoidance)를 사용한다.  
- Mobility:  
AP가 두 개 있다고 가정해보자. 이 두 AP 사이에 mobility를 보장하자는 것이다.  

<br>

#### 802.11 MAC Protocol: CSMA/CA  
- First Attempt:  
- DIFS 정도의 시간 동안 기다려준다.(무선이기 때문에 기다린다.)  
- Data가 가면 SIFS 정도의 시간 동안 기다린 뒤 ACK를 받는다.  
- 하지만 이렇게 해도 collision이 일어날 수 있다.  
- Second Attempt:  
- RTS와 CTS 라는 작은 packet을 만들어 collision을 피하자.  
<img src="Docs/Pasted image 20240531154556.png" width="400">
  

<br>

#### 802.11 MAC Protocol: Power Management  
> 다른 사람과의 간섭을 어떻게 보전할 것인가    
- 문제점:  
어떤 device가 더 높은 퀄리티의 통신을 쓰겠다고 power를 높인다.    
다른 device도 걍쟁하느라 덩달아 올려서 간섭이 같아지기 때문에 품질이 결국 같아진다.  
-> 쓰지 않을 때 sleep 모드로 들어가고, 다시 사용할 때 awake 해주자.    
-> 에너지 절약을 위한 power control algorithm    
  
<br>

#### 802.15    
802.11은 간단히 말하면 wifi다. 그럼 802.15를 간단히 말하자면 무엇일까?    
> pernal area network, 즉 Bluetooth이다.  

<br>

## 7.4 Cellular Network    
  
<br>

Cellular network의 idea가 뭘까?    
bandwodth는 귀하지만 일정 거리 이상으로 떨어지면 간섭이 줄어들어 다시 쓸 수 있다. >> reuseability    
그럼 인접 영역끼리는 다른 bandwodth를, 거리가 먼 영역에서는 재사용 가능하도록 하자.    
이런 식으로 하면 한정적인 자원을 무제한으로 쓸 수 있다.    
땅따먹기식 운영이라 생각하면 될듯...    
각 영역 당 base station을 할당해서 관리한다.    
여기서 base station이란 802.11의 AP와 완전히 같은 개념이다.    
Basestation 위에는 mobile switching station이 있다.    
Cellular network의 핵심이다!    
  
<br>

Term    
39p. Mobile Switching Station    
  
<br>

Cellular network의 first hop은 어쩌구    
  
<br>

#### 1세대 network    
아날로그 통신 FDMA기반으로 한 라디오 튱신 기반    
전화가 된다는 것만해도 감지덕지.. 음성통신만 됨    
  
<br>

#### 2세대 network    
아날로그 -> 디지털    
FDMA -> TDMA    
base station - mobile switching station - internet    
이것도 음성 통신만 됨    
  
<br>

#### 3세대 network    
CDMA    
이제 Data 통신이 가능하다! 문자가 된다는 것이다.    
어떻게 하느냐? 음성 신호는 기존 network을 이용, 문자는 따로 빼서 internet 이용    
  
<br>

#### 4세대 network    
음성과 문자를 하나로 묶어서 서비스하기 시작했다. public internet으로    
LTE    
이름이 좀 바뀌었다. 이유는 rebranding..?    
mobile switching center -> Mobility management entity    
base station -> eNodeB    
  
<br>

#### 5세대 network    
eMBB    
mMTC    
.. 등의 특징이 있다. 외울필욘 없음    
  
<br>

가상화 통신!    
  
<br>

#### 6세대 Network    
완벽히 정의 되지는 않았지만..    
위성통신과 드론..?을 이용해서 커버하지 못한 영역을 커버하자.    

<br>

## 7.5 Mobility: Principles  
  
<br>

우리가 만들어 갈 분야!  

<br>

#### Mobility  
>   
- DHCP Protocol  
- High Mobility: 제일 어렵다. 통신 중 움직인다. hand-off service를 제공해야 한다.  

<br>

#### Vocabulary  
- Home Network  
- Hone Agent  
- Permanent Address  
- Visited Network  
- Care-of-Address  
- Foreign Agent  
- Correspondent  

<br>

#### Approaches  
1. Let routing handle it: 이건 안 한다.  
- end system은 아무것도 안 한다.  
2. Let end-systems handle it: 실질적으로 이걸 한다.  
end system이 지저분한 일을 하게 해서 network의 부담을 줄이자  
1. Indirect routing: Home agent `triangle routing`  
2. Direct routing: Foriegn agent  

<br>

#### Indirect Routing  
- 여기서 Transparent하다 라는 것은 뭐냐면 안 보인다는 것이다. 즉, mobile의 위치를 상대는 모른다는 것이다.  
- triangle routing의 단점은 비효율적이라는 것이다. 통신 주체들이 같은 netwok에 있다고 생각해봐라..  
- foreign agent가 home agent와 통신하고, home agent가 care-of-address를 업데이트한다.  

<br>

#### Direct Routing  
- Indirect routing의 비효율성을 극복했다. 그러나 care-of-address를 가지고 직접 통신하기 때문에 transparency가 보장되지 않는다.  
- 네트워크를 이동 또 이동하면 어떻게 하냐? 중간에 들른 네트워크의 foreign agent를 anchor로 삼는다. ~~땜빵~~  

<br>

## 7.6 Mobile IP  

<br>

#### Mobile IP  
> Mobility를 보장한 IP Protocol을 Mobile IP라고 한다.  
- Indirect routing 시 Mobile IP:  

<br>

## 7.7 Handiling Mobility in Cellular Networks  

<br>

- Home Network  
- HLR: Database, 요금 정보도 있고.. current location 정보 중요하다. 내 물리적 위치가 바뀌면 정보가 업데이트된다.  
- Visited Network  
- VLR: Database, 위에 HLR 같은 것이다. 방문자 기록용 같은 것  

<br>

67p.의 4번처럼 cell에서 cell로 이동하는 것이 handoff라는 것인데, 이게 진짜 지저분하다.  

<br>

#### GSM: Handoff with Common MSC  
> Goal: Route call via new Base Station(without interruption)  

<br>

## 7.8 Mobility and Higher-Layer Protocols  

<br>

강의자료 참고  

<br>

# 9. Multimedia Networking  

<br>

앞서 배웠던 단원들에 비해 비교적 중요도가 적다.  
`시험에 나올 가능성이 적으니 가볍게 듣자`  

<br>

## 9.1 Multimedia Networking Applications  

<br>

#### Audio  
- 아날로그 오디오 -> 디지털 오디오:  
- 인간의 가청 주파수 영역을 256 영역으로 나누자. 그럼 1byte가 필요하다.  
- 이제 시간을 잘게 쪼개서 연속 그래프를 적분하듯이 mapping을 통해 아날로그를 디지털로 바꾸자.  
- 단점은 미묘하게 original 음이 손실(quantization error)이 일어날 수 있다는 점이지만.. 우리 귀가 구별을 못한다.  
- 통화 시에는 1초를 8000대로 쪼개고, CD는 1초를 44,100대로 쪼갠다.  
- 초당 8000개를 셈플링하고 256개로 쪼개면 음질은 64,000 bps, 즉 64kbps이다.  

<br>

#### Video  
- frame 마다 pixel 단위로 디지털화해서 보내면 된다.  
- frame 마다 변화가 적으므로 인코딩을 좀 효율적으로 해보자. 같은 부분은 안보내고 달라진 부분만 보내는 식(spatial coding, temporal coding)  
- CBR: 그냥 쌩으로 보낼 때  
- VBR: 효율적으로 보낼 때  

<br>

#### Application Types  
- Streaming stored audio, video `유튜브, 넷플릭스`  
- Conversational voice/video over IP `스카이프, 줌`  
- Streaming live audio, video `위버스`  

<br>

## 9.2 Streaming Stored Video  

<br>


<br>

## 9.3 Voice-Over-IP  

<br>


<br>

## 9.4 Protocols for Real-Time Conversational Applications  

<br>


<br>

## 9.5 Network Support for Multimedia  

<br>

#### Dimensioning Best Effort Networks  
- Best Effort Service다.  
- Dimensioning: 가장 중요한 것은 how much bandwidth is "enough?"  
- 이를 위해 traffic을 어느정도 예측해야한다.  

<br>

#### Providing Multiple Classes of Service  
- Multiple Class Service다.  

<br>

#### Scheduling and Policing Mechanisms  

<br>
