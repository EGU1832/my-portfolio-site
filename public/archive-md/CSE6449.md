# ì‹¤ì‹œê°„ ë Œë”ë§  

<br>

# Reflection Refraction Diffuse  

<br>

Reflect + Transmit (Diffuse / Refract)  

<br>


<br>

ë¹›ì´ ë“¤ì–´ì™€ì„œ ì¼ë¶€ëŠ” ë°˜ì‚¬ë˜ëŠ”ë° ì—ë„ˆì§€ ë³´ì¡´ì˜ ë²•ì¹™ì— ì˜í•´ì„œ 1ì´ë¼ëŠ” ë¹›ì´ ë“¤ì–´ì˜¤ë©´ ë°˜ì‚¬ë˜ëŠ” ì–‘ê³¼ íˆ¬ê³¼ë˜ëŠ” ë¹›ì˜ ì–‘ì´ ì´í•© 1ì´ì—¬ì•¼ í•  ê²ƒì´ë‹¤.
<br>


```math
light := 1 = \gamma + (1 - \gamma)
```

$`\gamma`$ì˜ ë¹„ìœ¨ì€ ë¬¼ì²´ì˜ ì„±ì§ˆì— ë”°ë¼ $`k_{d\gamma}`$ ì¸ìì— ì˜í•´ ì¡°ì •ëœë‹¤.

<br>

ReflectëŠ” ë§ê·¸ëŒ€ë¡œ ê±°ìš¸ ê°™ì´ ë¹›ì´ ë°˜ì‚¬ë˜ì–´ ë‚˜ê°€ëŠ” ì •ë°˜ì‚¬ì´ë‹ˆ ë„˜ì–´ê°€ê³ ,  
Transmit ë¶€ë¶„ì— ëŒ€í•´ì„œ ì¢€ ë” ì‚´í´ë³´ì.  

<br>

Transmit - Refraction  
Snellì˜ ë²•ì¹™ìœ¼ë¡œ êµ´ì ˆê° ê³„ì‚°  

<br>

Transmit - Diffuse  
Ideal Diffuse objectë¥¼ ìƒê°í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.  
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSea0Mp4gy43R9pBzRC430Ma6Be_FLctKBrEg&s">
  

<br>

ê·¼ë° ì‹¤ì œ ì„¸ê³„ì—ì„œ ì´ìƒì ì¸ ëª¨ë¸ì´ ìˆì„ë¦¬ê°€ ì—†ë‹¤.  
ë”°ë¼ì„œ ê·¸ë˜í”½ìŠ¤ì—ì„œëŠ” Micrafacet Modelì„ ì´ìš©í•œë‹¤.  
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQoaVOS9LpFc_nnnsMWHX6y4Io-60YbFtoa0g&s">
  
ë‹¤ìŒê³¼ ê°™ì´ ë¹›ì´ ë‚˜ê°€ëŠ” ë°©í–¥ì´ ë‹¬ë¼ì§„ë‹¤ë¥¼ ì¸¡ì •ì„ í•´ì„œ ì ìš©ì‹œí‚¨ë‹¤.  

<br>

Snellì€ êµ´ì ˆê°ì„,  
Fresnelì€ êµ´ì ˆ ë¹„ìœ¨ì„,  
Schlickì€ êµ´ì ˆ ë¹„ìœ¨ì˜ ê·¼ì‚¬ë¥¼.  

<br>

ìœ„ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì½”ë“œë¡œ êµ¬í˜„í•œ ê²ƒì´ë‹¤.  
```cpp
float FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)
{
	// Schlick aproximation
	float r0 = (n1-n2) / (n1+n2);
	r0 *= r0;
	float cosX = -dot(normal, incident);
	if (n1 > n2)
	{
		float n = n1/n2;
		float sinT2 = n*n*(1.0-cosX*cosX); // ì‹¤ì§ˆì ìœ¼ë¡œ sinT2ì˜ ì œê³±ì„ ê³„ì‚° ì¤‘ì´ë‹¤.
		// Total internal reflection
		if (sinT2 > 1.0) // ì–´ì°¨í”¼ ì œê³±ë„ ìµœëŒ€ ë²”ìœ„ëŠ” 1ì´ë‹¤.
			return 1.0;  // floating ì—°ì‚°ì„ ì¤„ì´ëŠ” ì¤‘ì¸ ê²ƒ ê°™ë‹¤.
		cosX = sqrt(1.0-sinT2);
	}
	float x = 1.0-cosX;
	float ret = r0+(1.0-r0)*x*x*x*x*x;
	
	// adjust reflect multiplier for object reflectivity
	ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);
	return ret;
}
```

<br>

$`R + T = 1.0`$
$`T = 1.0 - R`$
$`C_{ray} = R \cdot C_{R} + T \cdot C_{T}`$

<br>

Ray Tracingì—ì„œ Diffuseë¥¼ ê³„ì‚°í•  ë•Œ, ìš°ë¦¬ëŠ” Phongì˜ ì¡°ëª… ëª¨ë¸ì„ ë– ì˜¬ë¦´ ìˆ˜ ìˆë‹¤.  

<br>

Phong  
Diffuse + Spec  

<br>

Microfacet Modelì„ ì“°ëŠ” ëŒ€ì‹  ë‹¨ìˆœí™”í•˜ì—¬ Phongì˜ ì¡°ëª… ëª¨ë¸ì—ì„œ ì‹ì„ ê°€ì ¸ì˜¤ê¸°ë„ í•œë‹¤.  

<br>

$`k_t\gamma`$ ê°’ì€ ì–´ë–»ê²Œ ì¤ë‹ˆê¹Œ? -> ì ë‹¹íˆ ì¤˜ë¼

<br>

local shadingê°™ì€ ê²½ìš°ëŠ” phongì˜ local illumination modelì„ ì ì ˆíˆ ë³€í˜•í•´ì„œ ì¼ìœ¼ë‚˜ ê°„ë‹¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“œëŠ” ê²½ìš°ê³  ìš”ì¦˜ì€ ì´ë ‡ê²Œ í•˜ë©´ ìš• ë¨¹ëŠ”ë‹¤  

<br>

ìš”ì¦˜ì€ PBR(Physically Based Rendering)ì„ ì£¼ë¡œ ì“°ëŠ”ë°  
Rendering Equationì„ ì™„ì „íˆ ì ìš©í•˜ë©´ ì¢‹ê² ì§€ë§Œ ì§€ê¸ˆì€ ê³„ì‚°ì ìœ¼ë¡œ ë¬´ë¦¬  
[Reference - PBR](https://youtu.be/RRE-F57fbXw?si=qK-1RISLn6AUjJBp)  

<br>

Ray Generationì—ì„œ
<br>

$`p(t, e, d) = p(t) = e + td`$
$`t > 0`$ ëˆˆ ì•
$`t = 0`$ ëˆˆ
$`t < 0`$ ëˆˆ ë’¤

<br>

#### `OptiXshading.cu`  
> Optix Shaderë¥¼ ê°„ë‹¨í•˜ê²Œ ë´ë³´ì.  

<br>

**`closesthit_metal_raadiance`**: ê·¸ë¦¼ ìƒì˜ í•˜ëŠ˜ìƒ‰ metal êµ¬ë¥¼ raytracingí•˜ëŠ” shader  
ì–¸ì œ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëƒ?  
ë¬¼ì§ˆì´ metalì¸ ê²½ìš°  
ë‚´ê°€ í˜„ì¬ ì²˜ë¦¬í•˜ëŠ” Rayê°€ Primary Rayì¼ìˆ˜ë„ ìˆê³  Refelction Ray ì¼ìˆ˜ë„ ìˆê³ ..  
Closest-hit shaderëŠ” ì•„ë§ˆ ë³¸ Raytracing ê°•ì˜ì˜ ë§ˆì§€ë§‰ì—ì„œ ë‹¤ë£° shader ì¼ê²ƒì´ë‹¤.  

<br>

`nDl > 0`(backlightê°€ ì•„ë‹ˆë¼ frontlight)ì´ë©´ shadow rayë¥¼ ì˜ëŠ” ê²ƒì´ë‹¤.  

<br>

`0.01f`: $`t_{min}`$  
`Ldist`: $`t_{max}`$  
ì™œ Rayì˜ ìµœì†Œ ê¸¸ì´ì¸ $`t_{min}`$ì„ 0.0fë¡œ ì£¼ì§€ ì•Šëƒ?  
íŠ•ê²¨ì ¸ ë‚˜ê°€ê¸°ë„ ì „ì— ë¬¼ì²´ í‘œë©´ì—ì„œ ë‹¤ì‹œ ë¶€ë”ªíˆê¸° ë•Œë¬¸ì´ë‹¤. ì•½ê°„ zitter ê°™ì€ ê²ƒì´ë¼ê³  ìƒê°í•˜ë©´ ë  ê²ƒ ê°™ë‹¤.  

<br>

`light_attenuation`: ë¹›ì´ ë©€ë©´ ë©€ìˆ˜ë¡ ì•½í™”ì‹œí‚¤ëŠ” ê²ƒ  

<br>

local shading  
ì§ì ‘ì¡°ëª… + ê°„ì ‘ ì¡°ëª…
<br>

$`I_{\lambda}(P) = I_{a\lambda}\cdot k_{a\lambda} + S_i \{ I_{l\lambda} \cdot k_{d\lambda}(N\circ L) + I_{l\lambda} \cdot k_{s\lambda}(N \circ H)^n \}`$

<br>

Payload: Rayë§ˆë‹¤ ë¶™ì–´ë‹¤ë‹ˆëŠ” ë¬´ì–¸ê°€  
`result`ë¥¼ í˜„ì¬ ë…¸ë“œì˜ payloadì— ë‹´ì•„ ë³´ë‚´ì£¼ë©´ ëœë‹¤.  

<br>

`tracRadianceRay` Reflection Ray ì´ê°€ì§€ê³  ë“¤ì–´ì˜¤ëŠ” ë¹›ì˜ ìƒ‰ê¹”  

<br>

ì–´? ê·¸ëŸ¼ Rayë¥¼ ì–´ë””ì„œ ë©ˆì¶”ì§€? ìš°ë¦¬ê°€ í–ˆë˜ ê±´ depth ë³€ìˆ˜ë¥¼ 1ì”© ëŠ˜ë¦¬ë©´ì„œ ë©ˆì¶œì§€ ë§ì§€ë¥¼ íŒë‹¨í–ˆëŠ”ë°?  
`phngShade()`í•¨ìˆ˜ë¥¼ í™•ì¸í•´ë³´ì.  
`prd` ë³€ìˆ˜ì— `prd.importance`ì™€ `prd.depth`ë¡œ ì¡´ì¬í•œë‹¤. `prd.importance`ëŠ” ë¹›ì˜ ì•½í™”ì™€ ê´€ë ¨ëœ ë³€ìˆ˜ê³  `prd.depth`ëŠ” ë¹›ì˜ ë°˜ì‚¬ íšŸìˆ˜ì™€ ê´€ë ¨ëœ ë³€ìˆ˜ì´ë‹¤.  

<br>

**`closesthit_glass_radiance`**: ê·¸ë¦¼ ìƒì˜ ì†ì´ ë¹ˆ ìœ ë¦¬ êµ¬ë¥¼ raytracingí•˜ëŠ” shader  
ì„¸ìƒ ì¢Œí‘œê³„ WCë¥¼ ê¸°ì¤€ìœ¼ë¡œ o, d, t, Nì„ ê°–ê³  ì˜´.  
hit pointë¥¼ ê³„ì‚°  
`HitType` Front Face(ìœ ë¦¬êµ¬ìŠ¬ ë°”ê¹¥)ì„ ë•Œë ¸ëŠ”ì§€ Back Face(ìœ ë¦¬êµ¬ìŠ¬ ì•ˆìª½)ë¥¼ ë•Œë ¸ëŠ”ì§€ ì—¬ë¶€ë¥¼ ì²´í¬í•˜ëŠ” ë³€ìˆ˜`ì¼ê²ƒì„`  
- front_hit_point  
- back_hit_point  

<br>

`beer_attenuation`: Beer's Law (ê°•ì˜ìë£Œ 5 ì°¸ê³ ) íŠ¹ì • íŒŒì¥ì˜ ë¹›ì´ ë¬¼ì§ˆì„ í†µê³¼í•  ë•Œ í¡ìˆ˜ë˜ëŠ” ì–‘ì´ ê·¸ ë¬¼ì§ˆì˜ ë†ë„ì™€ í†µê³¼í•œ ê²½ë¡œì˜ ê¸¸ì´ì— ë¹„ë¡€í•œë‹¤ëŠ” ì›ë¦¬
<br>

$`\text{beer effect} = e^{\sigma_t\cdot ray_t}`$
$`\sigma_t`$ê°€ í´ìˆ˜ë¡ ë¶ˆíˆ¬ëª…í•˜ë‹¤ëŠ” ê²ƒ
`dot(n, ray_dir) > 0`: íˆ¬ëª…í•œ ë¬¼ì²´ì˜ ì•ˆ ìª½ì´ëƒ? -> Extinction Effectë¥¼ ì¤˜ì•¼í•œë‹¤.  

<br>

ê·¸ëŸ¼ ì´ì œ Refractionì„ í•´ë³´ì.  
`refract()`: êµ´ì ˆ ë°©í–¥ê³¼ ì„¸ê¸°ë¥¼ Snellê³¼ Fresnelì˜ ë²•ì¹™ì— ì˜í•´ ê³„ì‚°  

<br>

` prd_radiance.importance * ( 1.0f - reflection ) * luminance( glass.refraction_color * beer_attenuation );`  
ì•½í•´ì§„ ì •ë³´ì¸ importance + 1 - reflection + beer_attenuationì„ luminanceë¥¼ ì´ìš©í•´ gray scale ë°”ê¿ˆ = ê¸°ì¤€ë³´ë‹¤ ë¯¸ë¯¸í•˜ë©´ ê³„ì‚°í•˜ì§€ ë§ˆë¼  

<br>

$`(1 - k_r)L_{refr}\cdot C_{glass, refr}\cdot e^{\sigma_t\cdot ray_t} + k_r \cdot L_{refl} \cdot C_{glass, refl} \cdot e^{\sigma_t\cdot ray_t}`$
`ë­¥...ë¯¸`  

<br>


<br>

# PBR  

<br>

ìš°ë¦¬ê°€ í•™ë¶€ ë•Œ ë°°ìš´ ëª¨ë¸ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.  

<br>

/ *Phong BRDF Model*
<br>


```math
\begin{align}
I_\lambda &= I_{a\lambda} \cdot k_{a\lambda}+I_{l\lambda} \cdot k_{d\lambda} \cdot (N \circ L)+I_{l\lambda} \cdot k_{s\lambda} \cdot (R \circ V)^n \\
&= \text{embient reflection} + \text{diffuse reflection} + \text{specular reflection}
\end{align}
```

/ *Blinn Phong BRDF Model* `with halfway vector`
<br>


```math
I_\lambda = I_{a\lambda} \cdot k_{a\lambda}+f_{att}(d) \cdot I_{l\lambda} \cdot \{ k_{d\lambda} \cdot (N \circ L)+k_{s\lambda} \cdot (N \circ H)^n \}
```


<br>

ì¡°ì¡í•˜ê¸° ê·¸ì§€ ì—†ëŠ” ì˜›ë‚  ëª¨ë¸ë“¤ì´ë‹¤..  

<br>

ìµœê·¼ì—” ë‹¤ìŒê³¼ ê°™ì€ ëª¨ë¸ì„ ì“´ë‹¤.  

<br>

/ *PBR(Physically Based Rendering)*  
reference: Map_Physically Based Rendering Cocos Creator.pdf  

<br>

<img src="Docs/Pasted image 20240919165321.png" width="450">
  
- Albedo Map  
- Roughness Map  
- Metallic Map  
- Ambient Occlusion `ê·¸ë¦¼ ê·¸ë¦´ ë•Œ ê·¸ë¦¼ì ê°•ì¡°ë¥¼ ìœ„í•´ ì“°ëŠ” ê³±í•˜ê¸°ë‚˜ ê²€ì • ì˜¤ë²„ë ˆì´ ê°™ì€ê±°`  
- Normal Map  
- Emissive Map: ë°œê´‘  
- Stemcil Map (Alpha Channel): ìµœì í™”ë¥¼ ìœ„í•´ ë©€ë¦¬ ìˆëŠ” ë¬¼ì²´ë¥¼ ë‹¨ìˆœí™”í•´ì„œ ê·¸ë¦¬ëŠ” ê²ƒ  

<br>

PBR-Specular Workflow  
PBR-Metalic Workflow  

<br>

/ *Rendering Equation*
<br>


```math
\begin{align} L_{out}(x, \vec \omega) &= L_e(x, \vec\omega) + L_r(x, \vec\omega) \\ &= L_e(x, \vec\omega) + \int_\Omega f_{BRDF}(x, \vec\omega', \vec\omega)L_{in}(x, \vec\omega')(\vec\omega'\cdot\vec{n})d\vec\omega' \\ &= \text{xê°€ ì¹´ë©”ë¼ ë°©í–¥ìœ¼ë¡œ ìŠ¤ìŠ¤ë¡œ ë‚´ëŠ” ë¹›} + \text{xì—ì„œ ì¹´ë©”ë¼ ë°©í–¥ìœ¼ë¡œ ë°©ì‚¬ë˜ëŠ” ë¹›}&\end{align}
```

<img src="Docs/Pasted image 20240715152030.png" width="300">
  

<br>

Reference  
Advanced Global Illumination.pdf - 2.3 Radiometry  
flux, radiance, iradiance  
Videos.txt ê¼­ ì‹œì²­í•´ë³´ê¸°  
#4, #9  

<br>

### ğŸ“ Pdf: Slide_Rendering Equation - Image Synthesis - Part 3 - Chapter 1_p  

<br>

/ *Angle & Solid Angle*  
<img src="https://qph.cf2.quoracdn.net/main-qimg-0083ec41ebff340b26b633e285b35d31.webp" width="300">
  

<br>

Angle(2D) $`\theta`$  
ìµœëŒ€ $`2\pi`$ (ë°˜ì§€ë¦„ì´ 1ì¸ ì›ì˜ ì§€ë¦„)  

<br>

/ *Solid Angle(3D)* $`\ohm`$  
ìµœëŒ€ $`4\pi`$ (ë°˜ì§€ë¦„ì´ 1ì¸ êµ¬ì˜ ë©´ì )  
ë°˜êµ¬, Hemisphere($`\ohm`$)ì˜ ê²½ìš° $`2\pi`$ì¸ ê²ƒì´ë‹¤.
<br>

$`\int_{\ohm}\sin{\theta}\ d\theta\ d\phi = \int_{0}^{2\pi}\int^{\frac{\pi}{2}}_{0}{\sin{\theta}\ d\theta\ d\phi} = 2\pi`$

<br>

/ *Radiant Flux* $`\Phi`$  
ë‹¨ìœ„ ì‹œê°„ ë‹¹ ì–´ë–¤ ê°•ë„ë¡œ ë¹› ì—ë„ˆì§€ê°€ ë‚˜ê°€ê³  ìˆëŠ”ê°€  
ë‹¨ìœ„: Watt $`[W = \frac{J}{S}]`$  

<br>

/ *Radiant Intensity* $`I`$
<br>

$`I(w) = \frac{d\Phi}{d\omega}`$
íŠ¹ì • Solid Angle $`d\omega`$ ë¡œ ë‚˜ê°€ê³  ìˆëŠ” Radiance Flux  
ë‹¨ìœ„: Watt per Steradian $`[\frac{W}{sr}]`$  

<br>

/ *Irradiance* $`E`$
<br>

$`E(x) = \frac{d\Phi}{dA}`$
ë‹¨ìœ„ ë©´ì  $`dA`$ ë‹¹ ë“¤ì–´ì˜¤ëŠ” Radiant Flux, ë‚˜ê°€ëŠ” ê²ƒë„ ìˆë‹¤. `Radiant Exitant/Radiosity`  
ë‹¨ìœ„: Watt per square Metre $`[\frac{W}{m^2}]`$  

<br>

/ *Radiance* $`L`$
<br>

$`L(x, w) = \frac{d^2\Phi}{dA\ \cos{\theta}\ d\omega}`$
íŠ¹ì • Solid Angleê³¼ Projected Areaë¡œ ë‚˜ê°€ê³  ìˆëŠ” Radiance Flux  
ë‹¨ìœ„: Watt per Steradian per square Metre $`[\frac{W}{sr\ m^2}]`$  

<br>

$`\Phi \propto dA\ d\omega`$, FluxëŠ” ë©´ì ê³¼ ê°ë„ì— ë¹„ë¡€í•˜ë‹¤ê³  ë³¼ ìˆ˜ ìˆëŠ”ë°
`íŠ¹ì • ì§€ì ì—ì„œ íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ë¹›ì´ ì–¼ë§ˆë‚˜ ì„¸ê²Œ ë‚˜ê°€ê³ ìˆëŠ”ê°€`  
ì •í™•íˆ ì—¬ê¸°ì„œ $`dA`$ëŠ” ë‹¤ìŒê³¼ ê°™ì´ progectionëœ ë©´ì ì´ë‹¤.  
ë”°ë¼ì„œ $`\cos{\theta}`$ë¥¼ ê³±í•´ì£¼ëŠ” ê²ƒì´ ì—ë„ˆì§€ê°€ ì •í™•íˆ ìˆ˜ì§ ë°©í–¥ìœ¼ë¡œ ë“¤ì–´ê°€ëŠ” ë©´ì ì´ë‹¤.  
<img src="Docs/Pasted image 20240919173726.png">
  

<br>

> ì™œ Radianceê°€ ì¤‘ìš”í• ê¹Œ?  
- í•œ ì§€ì ì—ì„œ íŠ¹ì • ë°©í–¥ìœ¼ë¡œ $`L`$ì´ë¼ëŠ” Radianceê°€ ë‚˜ê°€ë©´ Radianceì˜ ê¸¸ì´ê°€ ì–´ë–»ê²Œ ë˜ë˜ ë°›ì•„ë“¤ì´ëŠ” ì§€ì ê³¼ ë°©ì¶œí•˜ëŠ” ì§€ì ì˜ ê°’ì´ ë˜‘ê°™ì„ ê²ƒì´ë‹¤.  
- ì´ë¥¼ ì´ìš©í•´ Ray Tracingì„ í•˜ëŠ” ê²ƒì´ë‹¤.  
- ë¬¼ë¡  ì§„ê³µ ìƒíƒœë¼ëŠ” ê°€ì • í•˜ì´ê³ , ì—°ê¸°ë‚˜ ê³µê¸°ê°€ ì¤‘ê°„ì— í¬í•¨ë˜ë©´ ì–˜ê¸°ê°€ ë˜ ë‹¬ë¼ì§„ë‹¤.  
- ìˆ˜í•™ì ì¸ ì¦ëª…ë°©ë²•ì€ Advanced Global Illuminationêµì¬ 24p. ì°¸ê³   

<br>

**Rendering Equation** `ì•ì„œ í•„ê¸°í•œê±°ë‘ ì‚´ì§ ë‹¤ë¥´ê¸´ í•œë° ì¼ë‹¨ ë³´ì`  

<br>

$`x`$ë¼ëŠ” ì§€ì ì—ì„œ $`\omega_i`$ë¡œ ë¹›$`L(\omega_i)`$ì´ ë“¤ì–´ì˜¤ê³ , $`\omega_o`$ë¡œ ë‚˜ê°€ëŠ” ë¹›ì˜ ì„¸ê¸°ë¥¼ ê³„ì‚°í•´ë³´ì.

```math
\begin{align} L_{o}(\omega_o) &= L_e(v) + \int_\ohm f_{r}(\omega_i, \omega_o)L_{i}(\omega_i)\cos{\theta}_i\ d\omega_i \\
L_i(l) &= \frac{d^2\Phi}{dA\cos\theta\ d\omega} \\
\frac{d^2\Phi}{dA}= d(\frac{d\Phi}{dA}) &= L_i(l)\cos\theta\ d\omega \\
&= dE(l) \text{(irradiance)}
 \\ \therefore L_o(\omega_o) &= L_e(v) + \int_\ohm{f_r(\omega_i, \omega_o)\ dE(\omega_i)}\end{align}
```

- ë”°ë¼ì„œ BRDFì‹ì„ ë¹¼ë©´ Equationì— Irradianceë§Œ ë‚¨ëŠ”ë‹¤.  
- irradianceì— $`f_r(v, l)`$ë¥¼ ê³±í•˜ê³  $`\ohm`$ ë§Œí¼ ë‹¤ ë”í–ˆë”ë‹ˆ Radianceê°€ ë‚˜ì˜¨ ê²ƒì´ë‹¤. ë”°ë¼ì„œ $`f_r(v, l)`$ì˜ ë‹¨ìœ„ëŠ” $`\frac{\text{Radiance}}{\text{Irradiance}} = \frac{1}{sr}`$ê°€ ë  ê²ƒì´ë‹¤.  
- $`f_r(v, l)`$: Bidirectional Reflection Distribution Function (BRDF), ì–˜ë¥¼ ì–´ë–»ê²Œ ëª¨ë¸ë§ í•˜ëŠëƒì— ë”°ë¼ Phong, PBR ë“±ì´ ë‚˜ì˜¤ëŠ” ê²ƒì´ë‹¤.  

<br>

#### BRDF  
> $`f_{r}(\omega_i, \omega_o)`$, Material Property  

<br>

$`\omega`$ëŠ” ë°©í–¥ì´ë¯€ë¡œ íŒŒë¼ë¯¸í„°ê°€ ë‘ ê°œì´ë‹¤. ë”°ë¼ì„œ BRDF ì‹ì€ 4ì°¨ì› í•¨ìˆ˜ì´ë‹¤.
ë§Œì•½ ë°˜êµ¬ $`\ohm`$ì„ 1024ê°œë¡œ samplingí•œë‹¤ê³  ì¹˜ë©´ (ë“¤ì–´ì˜¤ëŠ” ê²ƒ) $`\times`$ (ë‚˜ê°€ëŠ” ê²ƒ) í•´ì„œ ë²Œì¨ $`2^{20}`$ì´ë‹¤.  
Ideal Diffuse Material: ì´ìƒì ì¸ ë‚œë°˜ì‚¬ì²´ì˜ ê²½ìš° BRDFê°€ ìƒìˆ˜ê°€ ëœë‹¤., $`f_r(\omega_o, \omega_i) = k_d`$  

<br>


```math
\begin{align}\rho_d &= \frac{\int_\ohm\ \{\int_\ohm f_{r}(\omega_i, \omega_o)L_{i}(\omega_i)\cos{\theta}_i\ d\omega_i \}\ \cos\theta_o\ d\omega_o}{\int_\ohm{L(\omega_i)\ \cos\theta_i\ d\omega_i}} \\ \text{Albedo (Diffuse Color)} &= \frac{\int_\ohm L(\omega_o)M(x)}{E(x)}\end{align}
```

Albedo(Diffuse Color)  
ì–´ë–¤ í•œ ì§€ì ì˜ ë“¤ì–´ì˜¤ëŠ” Flux ëŒ€ë¹„ ì–¼ë§Œí¼ì˜ Fluxê°€ ë‚˜ê°€ëŠ”ê°€  
ì—ë„ˆì§€ ë³´ì¡´ì˜ ë²•ì¹™ì— ì˜í•´ ë¬´ì¡°ê±´ 1ë³´ë‹¤ ê°™ê±°ë‚˜ ì‘ì•„ì•¼ í•œë‹¤.  

<br>

ê·¸ë ‡ë‹¤ë©´ Ideal Diffuse Material ì¼ë•Œì˜ Albedoë¥¼ ê³„ì‚°í•´ë³´ê³  ì‹¤ì œì— ìƒì‘í•˜ëŠ” ê°’ ë‚˜ì˜¤ëŠ” ê²ƒì„ ê´€ì°°í•´ë³´ì.
<br>


```math
\begin{align}\rho_d &= k_d\int_\ohm\cos\theta_o \ d\omega_o \\ &=k_d\int^{2\pi}_0\int^{\frac{\pi}{2}}_0\cos\theta_o\sin\theta_o\ d\theta\ d\phi \\ &= k_d\int^{2\pi}_0[\frac12\sin^2\theta_o]^{\frac{\pi}{2}}_0\ d\phi \\ &= k_d \int^{2\pi}_0\frac12 \ d\phi = k_d \cdot \pi\end{align}
```

`ì²« ë²ˆì§¸ì—ì„œ ë‘ ë²ˆì§¸ ì¤„ë¡œ ë„˜ì–´ê°€ëŠ” ê³¼ì •ì´ ì´í•´ê°€ ì•ˆ ê°€ë©´(ì´ì¤‘ì ë¶„) pdf 13p.ë¥¼ ë³´ê³ ì˜¤ì.`  
ë”°ë¼ì„œ Ideal Diffuse Materialì˜ ê²½ìš° BADFì˜ ê°’ì„ Albedo ê°’ìœ¼ë¡œ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
<br>


```math
k_d = \frac{\rho_d}{\pi}
```

í•™ë¶€ë•Œ ë°°ìš´ phong ì¡°ëª… ëª¨ë¸ ë‚œë°˜ì‚¬ ë¶€ë¶„ì˜ ê³µì‹ì˜ $`k_{d\lambda}`$ì— í•´ë‹¹í•œë‹¤.  

<br>

/ *BRDF Properties*  
BRDFê°€ ì‹ìœ¼ë¡œì¨ ì¸ì •ì„ ë°›ìœ¼ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤. `pdf 23p.`  
- Positivity: í•¨ìˆ˜ê°’ì€ í•­ìƒ 0ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì•¼í•œë‹¤.  
- Helmholtz Reciprocity: $`l \rightarrow v = v \rightarrow l`$ ì¦‰, Bidirectional í•´ì•¼í•œë‹¤.  
- Energy Conservation: ì‚¬ë°©ì—ì„œ 1ë§Œí¼ì˜ ë¹›ì´ ë“¤ì–´ì˜¤ë©´ ë‚˜ê°€ëŠ” ê²ƒì€ 1ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì•„ì•¼ í•œë‹¤.  

<br>

ê·¸ë ‡ë‹¤ë©´ Phongì˜ ëª¨ë¸ì„ BRDFë¡œ í•´ì„í•˜ì—¬ ì–¼ë§ˆë‚˜ ì¡°ì•…í•œ ëª¨ë¸ì´ì—ˆëŠ”ì§€ë¥¼ ì‚´í´ë³´ì.
<br>


```math
\begin{align}I_\lambda &= I_{l\lambda} \cdot \{ k_{d\lambda} \cdot (N \circ L)+k_{s\lambda} \cdot (R \circ V)^n \} \\ &= \{ k_{d\lambda} + \frac{k_{s\lambda}(R\circ V)^n}{(n\circ L)} \} \ I_{l\lambda} \cdot (N\circ L) \\ &= f_r(\omega_i, \omega_o) \ L(\omega_i)\cdot \cos\theta_i\end{align}
```

Blinn-Phong Modelë„ $`(R\circ V)`$ê°€ $`(N\circ H)`$ë¡œ ë°”ë€Œì—ˆì„ ë¿ ë³„ ë‹¤ë¥¼ ê²ƒë„ ì—†ë‹¤.  

<br>

### ğŸ“Pdf: Slide_PBR Materials - Image Synthesis - Part 3 - Chapter 3_p  

<br>

#### BRDF
<br>


```math
\begin{align}&L(v) = L_e(v) + L_r(v)\\ &L(v) = L_e(v) + \int_\ohm f_{r}(v, l)L(l)\cos{\theta}\ dl \\ &f_r(v, l) = f_d(v, l) + f_s(v,, l)\end{align}
```


<br>

#### Cook-Torrance Model  

<br>

/ *Material Parameter*  
1. metallic(metalness) = m  
```
m = 1 // metal
0 <= m <= 1
m = 0 // non-metal = dielectrics
```

<br>

ì™œ 1ê³¼ 0ì‚¬ì´ ê°’ì´ ì¡´ì¬í• ê¹Œ? ë¬¼ì²´ì˜ í‘œë©´ì— metalì¸ ë¶€ë¶„ê³¼ metalì´ ì•„ë‹Œ ë¶€ë¶„ì´ í•œ í”½ì…€ì— ê´€ì°°ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.  

<br>

mì˜ ê°’ì— ë”°ë¼ specular ë°˜ì‚¬ë¥¼ ê³ ë ¤í•˜ëŠëƒ, ì•ˆ í•˜ëŠëƒê°€ ê²°ì •ëœë‹¤.
<br>

$`m = 1, f_r(v, l) = f_s(v, l)`$
$`m = 0, f_r(v, l) = f_d(v, l) + f_s(v, l)`$
ë”°ë¼ì„œ ì‹¤ì œ ì½”ë“œì—ì„œëŠ” m paramì˜ ë¹„ìœ¨ì„ ë°˜ì˜í•´ì„œ í•˜ë‚˜ì˜ ì‹ìœ¼ë¡œ í•©ì³ì„œ ì“´ë‹¤.
<br>

$`f_r(v, l) = \frac{\rho_d}{\pi}(1 - m) + f_s(v, l)`$

<br>

2. Roughness  
```
0 <= r <= 1
```

<br>

3. Reflectance  
```
0 <= l <= 1
```

<br>

/ *Metal-Roughness Model vs Specular - Glossinness*  
ë‘˜ ì¤‘ ì–´ëŠ ë°©ë²•ìœ¼ë¡œ ê°€ëŠëƒì— ë”°ë¼ ì‚¬ìš©í•  mapë“¤ì´ ë‹¬ë¼ì§„ë‹¤.  

<br>

#### ğŸ“ Base_s2013_pbs_physics_math_notes  

<br>

/ Surface Scattering  
Fresnel Equationì„ ìƒê¸°í•´ë³´ì.  
incoming light = reflection + trasmission(refraction)  

<br>

ë¹›ì´ ë“¤ì–´ì™”ì„ ë•Œ Fresnel Equationì— ì˜í•´ì„œ íŠ¹ì • ë¹„ìœ¨ë§Œí¼ì€ reflectë˜ê³  ë‚˜ë¨¸ì§€ëŠ” trasmissionëœë‹¤.  

<br>

<img src="Docs/Pasted image 20240926165445.png" width="300">
  
ğŸ”µ  
ê·¸ëŸ°ë° transmissionëœ ë¹›ë“¤ ì¤‘ì—ì„œëŠ” ë‚´ë¶€ì—ì„œ ë°˜ì‚¬ë˜ê³  ë°˜ì‚¬ë˜ì„œ ë¬¼ì²´ì˜ ìƒ‰ìƒì„ ë¨¸ê¸ˆê³  ë‹¤ì‹œ í‘œë©´ ìœ„ë¡œ íƒˆì¶œí•˜ëŠ” ë¹›ë“¤ì´ ìˆë‹¤.  
ì´ ë¹›ë“¤ì„ surface-scattered lightë¼ê³  í•œë‹¤.  

<br>

ì´ê²ƒì´ non-metalì—ì„œ ê°€ì •í•˜ëŠ” diffuse lightì´ë‹¤.  

<br>

ğŸŸ¡  
specular reflectionì˜ ê²½ìš° metalê³¼ ê°™ë‹¤.  

<br>

<img src="Docs/Pasted image 20240926165431.png" width="300">
  
ğŸŸ   
ë°˜ë©´ metalì—ì„œëŠ” ì´ëŸ° í˜„ìƒì´ ì—†ê³  transmissionëœ ë¹›ë“¤ì´ ê·¸ëƒ¥ ë‚´ë¶€ì—ì„œ í¡ìˆ˜ë˜ë²„ë¦°ë‹¤.  

<br>

ğŸŸ¡  
ì´ì œ metalì—ì„œ ë§í•˜ëŠ” specular reflectionì— ëŒ€í•´ì„œ ì–˜ê¸°í•´ë³´ì.  
ì´ë¡ ìƒìœ¼ë¡œëŠ” ë§ˆì¹˜ ê±°ìš¸ì²˜ëŸ¼ perfect specularì´ ë˜ì–´ì•¼ í•˜ì§€ë§Œ ì‹¤ì œë¡œëŠ” ë°˜ì‚¬ê°ê³¼ ë™ì¼í•œ ë°©í–¥ìœ¼ë¡œ ì‚´ì§ í¼ì ¸ì„œ ë¹›ì´ ë‚˜ê°„ë‹¤.  

<br>

ì´ í™”ì‚´í‘œì˜ í­ì´ ì¢ì•„ì§€ëŠ” ê²½ìš°ë„ ìˆê³  í¼ì§€ëŠ” ê²½ìš°ë„ ìˆë‹¤.  
- í­ì´ ì¢ìŒ  
- í­ì´ ë„“ìŒ  
- í­ì´ ì—†ìŒ: perfect specular  
ì´ë¥¼ ëª¨ë¸ë§í•˜ëŠ” ê²ƒì´ **Microfacet Model**ì´ë‹¤.  

<br>

ë‹¤ì‹œ ë³¸ Pdfë¡œ ëŒì•„ì™€ë³´ì.  

<br>

/ *Microfacet BRDF*  
í™•ë¥ ì ìœ¼ë¡œ ë¹›ì´ ë“¤ì–´ì™€ì„œ íŠ¹ì • êµ´ê³¡ì„ ë•Œë¦¬ë©´ ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ ë¹›ì´ ë‚˜ê°ˆì§€ ê°ê°ì˜ êµ´ê³¡ ê°ê°ì€ perfect specular reflectionìœ¼ë¡œ ë‚˜ê°„ë‹¤ê³  ê°€ì •í•œë‹¤.  

<br>

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQiWsHtE33XAfxD6njyQ9bpOfoZL7_2T3kcxQ&s">
  
ì´ êµ´ê³¡, Microfacetì˜ ì •ë„ë¥¼ í™•ë¥ ì ìœ¼ë¡œ ì¡°ì ˆí•˜ëŠ” ê²ƒì´ Roughness Parameterì´ë‹¤.  

<br>

ì‹¤ì œ ì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
<br>


```math
\begin{align}&f_s(v, l) = \frac{F(v, h)\ D(h)\ G(l, v)}{4\ \langle n\cdot l\rangle \langle n\cdot v\rangle} \\ &F: \text{Fresnel reflectance} \\ &D: \text{Normal distribution function (NDF)} \\ &G: \text{Geometry term}\end{align}
```


<br>

ê·¸ëŸ¼ Fresnel Reflectanceì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì.  
ì•„ê¹Œ ìœ„ì—ì„œ í–ˆë˜ í™”ì‚´í‘œë“¤.. ì‹œì‘í•˜ê¸° ìœ„í•´ì„  ìš°ì„  ì–¼ë§ˆë‚˜ ë°˜ì‚¬ë˜ê³  ì–¼ë§ˆë‚˜ ë“¤ì–´ê°€ëŠ”ì§€ ì•Œì•„ì•¼ í•˜ëŠ” ê²ƒì€ ìëª…í•˜ë‹¤.  
ì´ë¥¼ ìœ„í•œ ê²Œ Fresnel Reflectanceì´ë‹¤.  

<br>

ê¸°ë³¸ ê°œë…ì€ ì „ì— í–ˆìœ¼ë‹ˆ, non-metalê³¼ metalë¡œ ë‚˜ëˆ„ì–´ parameterì˜ êµ¬ì²´ì ì¸ ê°’ì„ ìœ„ì£¼ë¡œ ë³´ì.  
/ *Fresnel Reflectance: Non-Metal*  
<img src="Docs/Pasted image 20240926171537.png" width="450">
  
<img src="Docs/Pasted image 20240926171645.png" width="450">

<br>

$`F_0`$: ìˆ˜ì§ê´‘ì¼ ë•Œì˜ ë¹„ìœ¨ì´ë‹¤.
ëŒ€ë¶€ë¶„ì˜ non-metalì€ ëŒ€ê²Œ 0~4%ë¡œ, ê±°ì˜ ë‹¤ í¡ìˆ˜í•œë‹¤ëŠ” ê²ƒì„ ë³¼ìˆ˜ìˆë‹¤. `ë‹¤ì´ì•„ëª¬ë“œëŠ” ì˜ˆì™¸`  

<br>

/ *Fresnel Reflectance: Metal*  
<img src="Docs/Pasted image 20240926171557.png" width="450">
  
<img src="Docs/Pasted image 20240926172429.png" width="450">
  

<br>

ë”°ë¼ì„œ ëª¨ë¸ë§ì„ í•  ê²½ìš° Non-Metalì¸ ê²½ìš°ëŠ” ê·¸ëƒ¥ ê°’ì„,  
Metalì¸ ê²½ìš°ëŠ” í¬ê¸°ê°€ 3ì¸ Vectorê°€ í•„ìš”í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. `(Linear, Float)`  

<br>

ì ê¹ ë‹¤ìŒ ì‹ì„ ìƒê¸°í•˜ì.
<br>

$`m = 1, f_r(v, l) = f_s(v, l)`$
<br>

$`m = 0, f_r(v, l) = f_d(v, l) + f_s(v, l)`$  
ë³´í†µ Albedo Mapì„ ë³´ë©´ ê¸°ë³¸ ì»¬ëŸ¬ëŠ”  
Non-Metalì€ $`\rho_d`$ê°€,  
Metalì€ $`F_0`$ê°’ì´ ë“¤ì–´ê°„ë‹¤.  

<br>

ìµœì¢…ì ìœ¼ë¡œ ìš°ë¦¬ëŠ” ì˜ˆì „ì— ë°°ì› ë˜ Schilick Approximationì„ ì“´ë‹¤. `ë¹¨ë¼ì„œ`
<br>


```math
F_{schlick}(v, h) = F_0 + (1.0 - F_0)(1.0 - \langle v\cdot h \rangle)^5
```

Non-Metalì˜ ê²½ìš° vector $`F_0`$ì— ëª¨ë‘ ê°™ì€ ê°’ (0.04, 0.04, 0.04)ì´ ë“¤ì–´ê°€ì„œ ê³„ì‚°ëœë‹¤.  

<br>

```
vec3 f0 = vec3(0.16 * (reflectance * reflectance));
```
-> ì´ë ‡ê²Œ í•˜ë©´ (Non-Metalì˜ ê²½ìš°) 0~16% ì‚¬ì´ì—ì„œ ê°’ ì¡°ì ˆì´ ê°€ëŠ¥í•˜ë‹¤. `ë‹¤ì´ì•„ëŠ” ì˜ˆì™¸`  
```
f0 = mix(f0, baseColor, metalic);
```
Linear Interpolationì„ í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë‹¤.
<br>


```math
F_0 - \text{Base Color} \propto \text{metalic}(0.0 -1.0)
```


<br>

ì´ì œ ë‹¤ìŒ, $`D`$ í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì.  
/ *Normal Distribution Function (NDF)*  
ì´ í•¨ìˆ˜ëŠ” 3ê°œ ì •ë„ê°€ ìˆë‹¤.
<br>


```math
\begin{align}&D_{Blinn}(h)\\ &D_{Backmann}(h)\\ &D_{GGX}(h)\end{align}
```

ì—¬ê¸°ì„œëŠ” GGXë¥¼ ì“´ë‹¤.  
```glsl
float D_GGX(float NoH, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float denom = NoH * NoH * (a2 - 1.0) + 1.0;
    return a2 / (PI * denom * denom);
}
```

<br>

/ *Geometry Term*  
microfacetë“¤ë¼ë¦¬ ê°„ì„­ì„ ì¼ìœ¼í‚¨ë‹¤.  
<img src="Docs/Pasted image 20240926174826.png" width="600">
  
- Masking Effect  
- Shadowing Effect
<br>


```math
G_{Cook-Torrance}(l, v) = min(a, ..)
```

ì—¬ê¸°ì„œëŠ” Smithë¥¼ ì“´ë‹¤.  
```glsl
float G_Smith(float NoV, float NoL, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    float gv = NoV / (NoV * (1.0 - k) + k);
    float gl = NoL / (NoL * (1.0 - k) + k);
    return gv * gl;
}
```

<br>

ìµœì¢…ì ìœ¼ë¡œ PBR BRDFëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±ëœë‹¤.  
```glsl
vec3 CookTorranceBRDF(vec3 N, vec3 V, vec3 L, vec3 baseColor, float metallic, float roughness) {
    vec3 H = normalize(V + L);
    float NoV = max(dot(N, V), 0.0);
    float NoL = max(dot(N, L), 0.0);
    float NoH = max(dot(N, H), 0.0);
    float VoH = max(dot(V, H), 0.0);

    // F0 setup
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, baseColor, metallic);

    // BRDF terms
    vec3 F = F_Schlick(VoH, F0);
    float D = D_GGX(NoH, roughness);
    float G = G_Smith(NoV, NoL, roughness);

    vec3 numerator = D * F * G;
    float denominator = 4.0 * NoV * NoL + 0.001;

    vec3 specular = numerator / denominator;

    // diffuse
    vec3 kd = (1.0 - F) * (1.0 - metallic);
    vec3 diffuse = kd * baseColor / PI;

    return (diffuse + specular) * NoL;
}
```

<br>

### ğŸ“Pdf: CSE6449_ê°•ì˜ìë£Œ_RT_2  

<br>

Reference: 3-summer/Raytracing.md  

<br>

# Texture Mapping  

<br>

### ğŸ“Pdf: CSE4070_ê°•ì˜ìë£Œ08  

<br>

Texture Mapping  
- Filtering  
- Shadow Mapping  
- Reflection / Refraction Mapping  
- Normal Mapping (Bump Mapping)  

<br>

Rendering  
- Rasterization  
- Ray Tracing  
- WS  
- Path Tracing  
- Distributed Ray Tracing  

<br>

ì°¸ê³ ë¡œ ê°•ì˜ìë£ŒëŠ” ê±°ì˜ 10ë…„ ì „ì— ë§Œë“¤ì–´ì§„ ê²ƒì´ë‹ˆ ì ë‹¹íˆ ì°¸ê³ í•˜ì..  

<br>

```
"í…ìŠ¤ì²˜ ë§¤í•‘ì€ ì»´í“¨í„° ê·¸ë˜í”½ìŠ¤ì˜ ê½ƒì´ë‹¤."
/ ihm
```

<br>

1. Texture Mapping:  
- ìš°ë¦¬ê°€ ì•Œê³ ìˆëŠ” ê·¸ í…ìŠ¤ì²˜  
2. Bump Mapping (Normal Mapping):  
- í‘œë©´ì˜ ìš°ë‘˜íˆ¬ë‘˜í•œ ë¶€ë¶„ì„ í‘œí˜„í•˜ê³  ì‹¶ì„ ë•Œ  
- Ray Tracingì—ì„œë„ ì¤‘ìš”í•œ Mapì´ë‹¤.  
3. Environmental Maaping:  
- ì£¼ë³€ ë°°ê²½ `cube map`  
4. Shadow Mapping:  
- ê·¸ë¦¼ì  
5. Displacement Maaping:  
- Normal Mapì²˜ì²¨ ë¬´ì§€ê°¯ë¹›ì´ë‹¤. ê·¼ë° ìš©ë„ê°€ ë‹¤ë¥´ë‹¤.  
- Normal Mapì€ ë¬¼ì²´ ìì²´ë¥¼ ë°”ê¾¸ì§„ ì•Šì§€ë§Œ ì–˜ëŠ” ë¬¼ì²´ ìì²´ë¥¼ ë³€í˜•í•´ë²„ë¦°ë‹¤.  
- í‹€ì— ë³¸ì„ ë”´ë‹¤ê³  ìƒê°í•˜ë©´ ë ê±° ê°™ë‹¤.  

<br>

ì—¬ê¸°ê¹Œì§€ëŠ” ì „í˜•ì ì¸ í…ìŠ¤ì²˜ ë§¤í•‘ì˜ ì¢…ë¥˜ì´ê³ , ë” ë‚˜ì•„ê°€ì„  ìƒìƒë ¥ì„ ë°œíœ˜í•´ì„œ ë§ˆë²•ì„ ë¶€ë¦¬ëŠ” ì•„í‹°ìŠ¤íŠ¸ë“¤ë„ ìˆë‹¤.  

<br>

`8p.`  
ê·¸ëŸ¼ í…ìŠ¤ì²˜ ë§¤í•‘ì€ ì–´ë–»ê²Œ í•˜ëŠ”ê±¸ê¹Œ?  

<br>

<img src="Docs/Pasted image 20241017170323.png" width="600">
  

<br>

1. í‘œë©´ ë§¤ê°œí™” (Surface Parameterization)  
2. ê¸°í•˜ ë³€í™˜  
3. ë˜ìŠ¤í„°í™”  
4. í…ìŠ¤ì³ ìƒ‰ê¹” ê³„ì‚°: í”½ì…€ ìœ„ì¹˜ê°€ ê²°ì •ë˜ë©´ Texture Spaceë¡œ ë‹¤ì‹œ ëŒì•„ì™€ì„œ ë‹¤ì–‘í•œ ë°©ë²•ìœ¼ë¡œ ìƒ‰ê¹” ê²°ì • `NEAREST, LINEAR, MIPMAP`  

<br>

<img src="Docs/Pasted image 20241024164601.png" width="450">
  
- Texel Generation: `glTexParameter*(*)` `NEAREST, LINEAR, MIPMAP..`  
- ~~Texture Application~~: Texelì˜ ìƒ‰ê¹”ì„ í˜„ì¬ fragmentì˜ ìƒ‰ê¹”ê³¼ ì–´ë–»ê²Œ ì„ì„ ê²ƒì¸ê°€? ì´ê±´ ê·¼ë° ì´ì œ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.  

<br>

`22p.`  
`glTexParameter`ì— ë„˜ê²¨ì£¼ëŠ” ë‹¤ì–‘í•œ ì¸ìë“¤ì´ ì •ì˜ë˜ì–´ìˆë‹¤.  
- GL_TEXTURE_WRAP_S:  
- GL_CLAMP: ì¼ì • ë²”ìœ„ ë‚´ë¡œ CLAMP ì‹œí‚´  
- GL_REPEAT: OpenGL êµì¬ ì•ë©´ì²˜ëŸ¼ ì´ë¯¸ì§€ë¥¼ ë°˜ë³µì‹œí‚´  

<br>

í…ìŠ¤ì²˜ ì¢Œí‘œ address node  
normalized coordinate  

<br>

`plus alpha: Texture in CUDA`  
CUDAì—ì„œì˜ Texture Mappingì— ëŒ€í•´ì„œ ì ê¹ ë“¤ì—¬ë‹¤ë³´ì.  
ğŸ“ CUDA C++ Programming Guide Release 12.3, Texture Object API  
í˜„ì¬ëŠ” Texture Readë§Œ ê°€ëŠ¥í•˜ê¸´ í•˜ë‹¤.  

<br>

texture coordinate attributeë¼ëŠ” ë¬¼ì²´ì˜ ì ì˜ attributeë¥¼ ê¸°ë°˜ìœ¼ë¡œ í…ìŠ¤ì²˜ë¥¼ ë¶™ì´ê²Œëœë‹¤.  

<br>

`10p.`  
PreImage: í”½ì…€ì´ë€ ì¡°ê·¸ë§Œ ì°½ë¬¸ì„ í†µí•´ì„œ ë°”ë¼ë³´ëŠ” ë¬¼ì²´ì˜ ì˜ì—­  
Texture Image ì›ë³¸ì— ì ‘ê·¼í•´ì„œ ëŒ€ì‘ë˜ëŠ” Texelì˜ Interpolationì„ ê³„ì‚°í•œë‹¤ <- ì´ ë¶€ë¶„ì´ ê³„ì‚°ì´ ë³µì¡í•´ì§€ëŠ” ê³¼ì •ì´ë‹¤!  
Pixel í•˜ë‚˜ì— ëŒ€ì‘ë˜ëŠ” Texelì´ í•œ ê°œì¼ìˆ˜ë„ ìˆê³  ì—¬ëŸ¬ ê°œ ì¼ìˆ˜ë„ ìˆëŠ”ë° ì—°ì‚° ì†ë„ëŠ” ê°™ì•„ì•¼ í•œë‹¤ëŠ” ì ì´ ì´ë¥¼ ì–´ë µê²Œ ë§Œë“œëŠ” ê²ƒì´ë‹¤.  

<br>

`34p.`  
#### Texture Filtering  
> ì–´ë–»ê²Œ í•˜ë©´ í”½ì…€ì— ëŒ€ì‘ë˜ëŠ” Preimageì˜ì—­ì˜ ìƒ‰ê¹”ì„ ê°€ê¸‰ì  ì •í™•í•˜ê³  ë¹ ë¥´ê²Œ ì¶”ì •í•  ìˆ˜ ìˆì„ê¹Œ?  

<br>

ë¬¼ì²´ í™•ëŒ€ ì‹œ Pixel í•˜ë‚˜ì— ëŒ€ì‘ë˜ëŠ” Texelì´ ì ì–´ì§€ê³ , -> MAG_FILTER ì‚¬ìš©  
ë¬¼ì²´ ì¶•ì†Œ ì‹œ Pixel í•˜ë‚˜ì— ëŒ€ì‘ë˜ëŠ” Texelì´ ë§ì•„ì§„ë‹¤. -> MIN_FILTER ì‚¬ìš©  

<br>

ê·¸ëŸ¼ ì–¸ì œ ë‘ í•„í„° ì‚¬ìš©ì„ ì „í™˜í• ê¹Œ?  
**1 Pixel <-> 1 Texel** ì¼ë•Œ!  

<br>

Ex)  `40p.`  
Mgnification: Nearest(ê°ì§„ê±°)  
Minification: Linear(ë¶€ë“œëŸ¬ìš´ê±°) `ìœˆë„ìš° í™”ë©´ ì¤„ì´ëŠ” ê²ƒë„ Minificationì— í•´ë‹¹í•œë‹¤!`  
*ì–´? ê·¼ë° ì£¼ì „ìë¥¼ ëŒë ¤ë³´ë©´ ì£¼ì „ìì˜ ì‹¤ë£¨ì—£ ë¶€ë¶„ì—ì„œ, ì‹¤ë£¨ì—£ ë¶€ë¶„ì€ minificationì´ë‹ˆê¹Œ ë¶€ë“œëŸ¬ì›Œ ë³´ì—¬ì•¼í•  ê²ƒ ê°™ì€ë° ê°ì ¸ë³´ì¸ë‹¤.*  
ì™œê·¸ëŸ´ê¹Œ? ì´ì— ëŒ€í•´ì„  ì°¨ì°¨ ë°°ìš°ë©´ì„œ ì•Œì•„ë³´ì.  

<br>

`36p.`  
ì¼ë‹¨ Preimageë¥¼ ì •ì‚¬ê°í˜•ì´ë¼ê³  ê°€ì •í•˜ì. `ì‹¤ì œë¡œëŠ” ì•ˆ ê·¸ë ‡ë‹¤.`  
<img src="Docs/Pasted image 20241017172526.png" width="450">
  
ì•ì„œ ë§í–ˆë‹¤ì‹œí”¼ í™•ëŒ€, ì¶•ì†Œì— ë”°ë¼ ëŒ€ì‘ë˜ëŠ” ê°œìˆ˜ê°€ ì°¨ì´ê°€ ë‚œë‹¤.  

<br>

`22-23p.`ë¡œ ê°€ë©´ openGLì—ì„œ ì‚¬ìš©í•˜ëŠ” ì´ì™€ ê´€ë ¨ëœ í•¨ìˆ˜ê°€ ë‚˜ì™€ìˆë‹¤.  
`Gen -> Bind -> TexImage2D CPUì—ì„œ GPUë¡œ load ->... `  

<br>

/ *Mipmap Filter*  
GL_LINEAR_MIPMAP_LINEAR  
ì´ í•„í„°ë¥¼ ì£¼ë¡œ ì“´ë‹¤. í˜¼í•© í•„í„°ê°™ì€ ê²½ìš°ëŠ” ë§ì´ ì“°ì§„ ì•ŠëŠ”ë‹¤.  
```cpp
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, ??? ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ??? );
```

<br>

/ GL_NEARESTì™€ GL_LINEAR ìš”ì•½  
GL_NEARESTëŠ” ê·¸ëƒ¥ ë‹¨ìˆœíˆ pixelì„ ë‹¿ëŠ” Texelë¡œ ì¹ í•´ë²„ë¦¬ëŠ” ê²ƒì´ê³  `NoisyğŸ‘ / CrispyğŸ‘`  
GL_LINEARëŠ” Linear Interpolationì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤. `SoftğŸ‘ / BlurredğŸ‘`  

<br>

GL_LINEARë¥¼ ì¨ë„ ì¶©ë¶„í• ê±° ê°™ì€ë° ì™œ Mipmapì´ ê°œë°œë˜ì—ˆì„ê¹Œ? ë‹¤ìŒ ì§ˆë¬¸ì„ ë³´ì.  

<br>

`ì–´? ê·¼ë° ì£¼ì „ìë¥¼ ëŒë ¤ë³´ë©´ ì£¼ì „ìì˜ ì‹¤ë£¨ì—£ ë¶€ë¶„ì—ì„œ, ì‹¤ë£¨ì—£ ë¶€ë¶„ì€ minificationì´ë‹ˆê¹Œ ë¶€ë“œëŸ¬ì›Œ ë³´ì—¬ì•¼í•  ê²ƒ ê°™ì€ë° ê°ì ¸ë³´ì¸ë‹¤.`  
ë‹¤ìŒ ì˜ë¬¸ì„ ìƒê¸°í•˜ë©° ì§ˆë¬¸ì„ ë˜ì ¸ë³´ì.  

<br>

ê³¼ì—° ì¶•ì†Œ ìƒí™©ì´ ì‹¬í•´ì ¸ë„ GL_LINEARê°€ ë„ì›€ì´ ë ê¹Œ?  
-> ì¶•ì†Œ ìƒí™©ì´ ì‹¬í•´ì§€ë©´ êµ¬ì¡°ì ìœ¼ë¡œ GL_LINEAR í•„í„°ë„ ë¶ˆì¶©ë¶„í•˜ë‹¤.  
ì™œëƒí•˜ë©´ Interpolationì„ í•œë‹¤ê³  í–ˆì„ ë•Œ, ì¤‘ê°„ì— ìƒëµë˜ëŠ” Texelë“¤ì´ ë§ì•„ì§€ê¸° ë•Œë¬¸ì´ë‹¤.  
<img src="Docs/Pasted image 20241017174002.png" width="200">
 (GL_LINEARëŠ” ë‘˜ëŸ¬ì‹¼ Texel 4ê°œë§Œ ì”€!)  

<br>

ê·¸ë˜ì„œ GL_LINEAR_MIPMAP_LINEARë¥¼ ì“°ëŠ” ê²ƒì´ë‹¤. `Mipmap`  
ì´ì œ ì´ MIPMAPì— ëŒ€í•´ì„œ ìì„¸íˆ ì•Œì•„ë³´ì.  

<br>

/ *MIPMAP*  
<img src="Docs/Pasted image 20241024170033.png" width="600">
  
L0($`1024 \times 1024`$) -> L1($`512\times 512`$) -> L2($`256\times 256`$) ->...  
ë˜‘ê°™ì€ ì´ë¯¸ì§€ë¥¼ í‰ê·  ë‚´ì„œ ë” ì‘ì€ í•´ìƒë„ì˜ ì´ë¯¸ì§€ë¥¼ ë§Œë“¤ê³  ë¯¸ë¦¬ Texture Mapì— ë„£ì–´ë†“ëŠ”ë‹¤.  
`43-45p.`  
- Box Filter í¬ê¸°ì˜ ì¶”ì •: ì„¸ ì¶”ì • ë°©ë²• ì‚¬ì´ì— ì–´ë–¤ ì°¨ì´ê°€ ìˆì„ê¹Œ?  
- (Square) ë”±ë”±í•¨ --> ë¶€ë“œëŸ¬ì›€ (Trapezoid)  
- Mipmap Levelì˜ ê²°ì •:  
- `dFdx() dFdy()`: Pixelì´ í•œ ì¹¸ ì›€ì§ì¼ ë•Œ Texture ì¢Œí‘œê°€ ì–¼ë§ˆë‚˜ ì›€ì§ì´ëŠ”ê°€  
- Trilinear Interpolation (ì‚¼ì„ í˜• ë³´ê°„):  
- ê°ê°ì˜ Texelì´ Sizeê°€ PreImageì˜ ì •ì‚¬ê°í˜•ì˜ í¬ê¸°ë³´ë‹¤ ì‘ê±°ë‚˜ í° ê²½ê³„ë¥¼ ì°¾ëŠ”ë‹¤.  
- ì‚¼ì„ í˜• ë³´ê°„: $`k_0, k_1`$ì—ì„œ ê°ê° Linear Interpolation`(1)`, ì •ì‚¬ê°í˜•ì˜ í¬ê¸°ì˜ ë¹„ìœ¨ë¡œ ë˜ ë‹¤ì‹œ Linear Interpolation`(2)` í•˜ëŠ” ê²ƒ `GL_(1)_MIPMAP_(2)`  

<br>

ì´ì œ ì´ MIPMAPì„ ì‹œê°í™”í•œ ê°•ì˜ìë£Œ `46p.`ë¥¼ ì‚´í´ë³´ì.  
ì´ˆë¡ìƒ‰, íŒŒë€ìƒ‰, ë¹¨ê°„ìƒ‰ -> ë¯¼íŠ¸ìƒ‰  
L0 -> L1 -> L2 -> L3  
`NEAREST_*`: ê°ê°ì˜ Levelì´ ë”±ë”±í•œ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.  
`LINEAR_*`: ê°ê°ì˜ Levelì´ ë¶€ë“œëŸ¬ìš´ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.  
`*_NEAREST`: ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°ˆ ë–„ ë”±ë”±í•˜ê²Œ ë„˜ì–´ê°€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.  
`*_LINEAR`: ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°ˆ ë•Œ ë¶€ë“œëŸ½ê²Œ ë„˜ì–´ê°€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.  

<br>

`48p.`  
Box Filter í¬ê¸°ì˜ ì¶”ì •ê³¼ ê´€ë ¨í•˜ì—¬ ê°ê¸° ë‹¤ë¥¸ MIPMAPì˜ ì–‘ìƒì„ ë´ë³´ì.   
**Isotropic**: ê¸¸ì­‰í•˜ê²Œ ëŠ˜ì–´ë‚œ ì´ë¯¸ì§€ë¥¼ ì •ì‚¬ê°í˜•ìœ¼ë¡œ ì¶”ì •í•˜ê² ë‹¤.  
- ì •ì‚¬ê°í˜•ì¸ Texture Imageë§Œ í•„ìš”í•˜ë‹¤.  
**Anisotropic**: ê¸¸ì­‰í•˜ê²Œ ëŠ˜ì–´ë‚œ ì´ë¯¸ì§€ë¥¼ ê°€ë¡œ ì„¸ë¡œê°€ ë‹¤ë¥¸ ì§ì‚¬ê°í˜•ìœ¼ë¡œ ì¶”ì •í•˜ê² ë‹¤. -> ë¹„ìŠ¤ë“¬íˆ ë³´ê²Œë˜ëŠ” ë¶€ë¶„ì´ ë¿Œì˜‡ê²Œ ë³´ì´ì§€ ì•Šê³  ì„ ëª…í•˜ê²Œ ë³´ì´ê²Œëœë‹¤.  
- ê°•ì˜ìë£Œì˜ ê·¸ë¦¼ì²˜ëŸ¼ ê° ë°©í–¥ìœ¼ë¡œ ìª¼ê·¸ë¼ë“œëŠ” Texture Imageë¥¼ ë§Œë“¤ì–´ë†”ì•¼í•˜ê¸° ë•Œë¬¸ì— ê³„ì‚°ê±ê³¼ ë©”ëª¨ë¦¬ê°€ ë§ì´ ë“ ë‹¤.  

<br>

ì´ì œ Shadow Mappingì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì.  
Ray Tracingì„ í•˜ëŠ” ì‚¬ëŒë“¤ì€ ì›ƒì„ ê²ƒì´ë‹¤. `ê·¸ëƒ¥ Shadow Ray ì˜ë©´ ë˜ì–ì•„..`  
í•˜ì§€ë§Œ ì¼ë‹¨ì€ Renderingì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ê²ƒì´ë¯€ë¡œ ì•„ë¬´ë¦¬ ì‹œëŒ€ê°€ ë³€í™”í•´ê°„ë‹¤ê³  í•˜ë”ë¼ë„ ì•Œì•„ë‘ëŠ” ê²ƒì´ ì¢‹ì„ê²ƒì´ë‹¤.  
ReferenceëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.  
OpenGL 2 Shading Language Cookbook (2nd ed. Chapter 7)  
ë³¸ ê³¼ëª© ì œê³µ OpenGL ì½”ë“œ  
OpenGL 4 Shading Language Cookbook ì œê³µ ê´€ë ¨ ì½”ë“œ  
Learn OpenGL - Graphics Programming Chapter 35  
Leran OpenGL- Graphics Programming ì œê³µ ê´€ë ¨ ì½”ë“œ  
ë³¸ ê³¼ëª© ì œê³µ Vulkan ì‰ì´ë”  

<br>

`55p.`  

<br>

# Shadow Mapping  

<br>

#### Shadow Mapping  
ê¸°ë³¸ì ì¸ Stepì€ GPTë¥¼ ì°¸ê³   
Shadow Mappingì˜ Idea ìì²´ëŠ” ê°„ë‹¨í•˜ë‹¤.  
ê´‘ì›ì„ ê¸°ì¤€ìœ¼ë¡œ Shadow mapì„ ë§Œë“¤ê³ , Camera ì‹œì ì—ì„œ ë³´ëŠ” ì§€ë©´ì˜ ì (ê·¸ë¦¼ìê°€ ì§ˆ ê³³) ê´‘ì›ì— íˆ¬ì˜í•´ì„œ Shadow Mapì„ ì°¸ê³ í•˜ì—¬ Depth ë¹„êµë¥¼ í†µí•˜ì—¬ ê·¸ë¦¼ìë¥¼ ìƒì„±í•œë‹¤.  
`58p.`ì— ìˆëŠ” ì‹ì„ ì •í™•íˆ ì´í•´í• ìˆ˜ë§Œ ìˆë‹¤ë©´ Shadow Mappingì€ ëë‚œë‹¤.  

<br>

Shadow Mappingì˜ ê³¼ì •ì„ ê°„ëµíˆ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.  
1. Pixelì„ í†µí•´ì„œ ë³´ì´ëŠ” ê°€ì¥ ê°€ê¹Œìš´ ì§€ì ê¹Œì§€ì˜ ê±°ë¦¬ì— ëŒ€í•œ Map, ì¦‰ Shadow MApì„ ë§Œë“ ë‹¤.  
2. Shadow Mapì„ ì ìš©í•´ì„œ ì¹´ë©”ë¼ ê´€ì ì—ì„œ Sceneì„ ê·¸ë¦°ë‹¤. ì¹´ë©”ë¼ì—ì„œ ì˜ê³  Surfaceì—ì„œ ë°˜ì‚¬ë¼ì„œ ë¹›ìœ¼ë¡œ ê°€ëŠ” ê·¸ ê¸¸ì´ê°€ Depth Mapì˜ ê°’ë³´ë‹¤ í¬ë©´ ê·¸ë¦¼ìê°€ ìƒê¸°ëŠ” ê²ƒì´ë‹¤.  

<br>

Cameraë¥¼ êµ¬ì„±í•˜ê³  ìˆëŠ” ìš”ì†ŒëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.  
- Viewing Transformation (Extrinsics Parameter)  
- Projection Transformation (Intrinsic Parameter)  

<br>

ê·¼ë° ì´ì œ ì—¬ê¸°ì„œ ë‹¤ìŒê³¼ ê°™ì€ ìš”ì†Œë¥¼ ê³ ë ¤í•´ì•¼ëœë‹¤.  
Framebuffer  
- FB(Default): Color Buffer, Depth Buffer, Stencil Buffer `Depth Bufferì™€ Stencil BufferëŠ” Depth-Stencil Bufferë¡œ í•©ì¹  ìˆ˜ ìˆë‹¤.`  
- FBO: FBì™€ëŠ” ë‹¬ë¦¬ Render Targetì„ ë©”ëª¨ë¦¬ì˜ íŠ¹ì • Textureë¡œ ì„¤ì •í•´ ì¤‘ê°„ ë Œë”ë§ ê²°ê³¼ë¥¼ ì €ì¥í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤. ê·¸ëŸ¬ë‹ˆê¹Œ ì‰½ê²Œ ë§í•´ `ì•„..ì”¨ ë‚´ê°€ êµ¬í˜„í•´ë³´ê³  ì‹¶ì€ ê²Œ FBë¡œëŠ” ì•ˆ ë ê±° ê°™ì€ë°...` ì¼ë•Œ ì“°ëŠ” ê²ƒì´ë‹¤. ë‹¤ìŒê³¼ ê°™ì´ ìƒê²¼ë‹¤. `glDrawBuffer(n, attachments[n])`ë¥¼ í†µí•´ì„œ Link í•´ì¤˜ì•¼ í•˜ëŠ”ë° `Attachment 0, 1, 2..`ë¡œ ì§€ì •í•´ì¤€ ê²ƒì´ `attachment(GL_COLOR_ATTACHMENTS, ...)` ê°ê°ì˜ Indexë¡œ Mapping ë˜ëŠ” ì‹ì´ë‹¤. ì‰½ê²Œ ë§í•´ ë²ˆê±°ë¡­ê³  ê·€ì°®ì€ ê³¼ì •ì„ ê±°ì³ì•¼í•˜ëŠ” ê²ƒì´ë‹¤. `advanced_lighting_5.1.deffered_shading/deffered_shading.cpp ì°¸ê³ ` <img src="https://www.researchgate.net/publication/267830465/figure/fig5/AS:384241901817860@1468621816848/Figura-5-Esquema-representando-a-estrutura-de-um-Frame-Buffer-Object-Green-2005.png" width="450">
  
Renderbuffer Objectì™€ Texture Objectsì˜ ì°¨ì´ëŠ” ë¬´ì—‡ì¸ê°€?  
- TOëŠ” ì•„ë¬´ë°ë‚˜ ì ‘ê·¼ì„ í•´ë„ MIN/MAX_FILTER ë“±ìœ¼ë¡œ ì•Œì•„ì„œ ìƒ‰ê¹”ì´ ì¶”ì¶œë¼ì„œ ë‚˜ì˜¨ë‹¤.  
- RBOëŠ” Dataì˜ ë°°ì—´ì´ê¸° ë•Œë¬¸ì— ì¤‘ì•™ì—ë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. í•œ ë²ˆ Rendering ê³„ì‚°ì´ ëë‚˜ë©´ ë²„ë¦´ ê²ƒì´ê¸° ë•Œë¬¸ì— ê·¸ëƒ¥ ì°¨ë¼ë¦¬ ë¹ ë¥¸ RBOë¥¼ ì“°ì. ë¼ëŠ” ëŠë‚Œì´ë‹¤.  

<br>

ì•„ì§ ë„˜ì–´ê°€ê¸´ ì´ë¥´ë‹¤.  
OpenGL Geomerty Pupeline Overviewë¥¼ ë‹¤ì‹œ ìƒê¸°í•˜ê³  ê°€ì. `ğŸ“CSE4100 ê°•ì˜ìë£Œ 4 ì°¸ê³ `  

<br>


<br>


<br>

**(1) Shadow Map Generation**  

<br>

`5.5.0.Tiger_Texture_Shadow_PS_GLSL` ì°¸ê³   
```
Texture Unit
GL_TEXTURE0 + N_NORMAL_TEXTURES_USED
0
1
2 <=> Shadow Map
```
Shadowì˜ í•´ìƒë„ëŠ” `SM_param.width, SM_param.height` ì¡°ì ˆ  

<br>

`glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);`  
ë²”ìœ„ ë°”ê¹¥ì˜ ì²˜ë¦¬  

<br>

`glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);`  
Textureë¥¼ Access í–ˆì„ ë•Œ ê²°ê³¼ê°’ì€ RGB ê°’ì´ ì•„ë‹ˆë¼ 1.0ë˜ëŠ” 0.0
<br>

$`(s, t, r, l)`$
$`D_t`$: s, të¥¼ ê°€ì§€ê³  ê°€ì§€ê³  ì˜¨ ìƒ‰ê¹” ê°’

<br>

`textureProj(texture_unit_num, (s, t, r, q))`  
Projê°€ ë¶™ì€ ê²ƒì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ ì›ê·¼ ë‚˜ëˆ—ì…ˆì„ í•œ ë²ˆ í•´ì¤€ë‹¤.
<br>


```math
\begin{pmatrix}s\\t\\r\end{pmatrix} = \begin{pmatrix}\frac{S}{Q}\\\frac{T}{Q}\\\frac{R}{Q}\end{pmatrix}
```

ì € $`s, t`$ê°€ $`D_t`$ë¥¼ ë§Œë“¤ê³  ê·¸ê²ƒì„ $`r`$ê³¼ ì–´ë–»ê²Œ ë¹„êµí• ê¹Œ? í•˜ëŠ” ê²ƒì´ Texture Comparison Function Parameterë¡œ ì§€ì •í•´ì£¼ëŠ” ê²ƒì´ë‹¤. `GL_LEQUAL ë“±`  

<br>

<img src="Docs/Pasted image 20241029174241.png" width="450">
  

<br>

**(2) Shadow Map Application**  

<br>


```math
\begin{align}\begin{pmatrix}S\\T\\R\\Q\end{pmatrix} &= \begin{pmatrix}0.5 & 0&0&0.5\\0&0.5&0&0.5\\0&0&0.5&0.5\\0&0&0&1\end{pmatrix}\times M_{P_l}\times M_{V_l}\times \begin{pmatrix}x_w\\y_w\\z_w\\1\end{pmatrix} \\ \begin{pmatrix}s\\t\\r\end{pmatrix} &= \begin{pmatrix}\frac{S}{Q}\\\frac{T}{Q}\\\frac{R}{Q}\end{pmatrix}\end{align}
```


```math
\begin{align}S &= 0.5 x_c + 0.5w_c\\
T &= 0.5y_c + 0.5w_c \\ 
R &= 0.5z_c + 0.5w_c\\
Q &= w_c\end{align}
```


<br>


```math
\begin{align}s = 0.5 \frac{x_c}{w_c} + 0.5 \\
t = 0.5 \frac{y_c}{w_c} + 0.5\\
r = 0.5 \frac{z_c}{w_c} + 0.5\\\end{align}
```


<br>

ê·¸ëŸ¼ ì´ì œ ê·¸ë¦¼ìê°€ ì•„ë‹Œ, í‘œë©´ì„ ìš°ë‘˜íˆ¬ë‘˜í•˜ê²Œ ë³´ì´ê²Œ í•˜ëŠ” Normal Mappingì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì.  

<br>

#### ğŸ“• OpenGL 4 Shading Language Cookbook  
#### ğŸ“„ 2024.10.31 Paper  
#### Normal Mapping  
PBR ë•Œ í–ˆë˜ Normal Mapì´ ê¸°ì–µë‚˜ëŠ”ê°€?  
í™€ë¡œê·¸ë¨ ê°™ì€ Mapì´ ê¸°ì–µì´ ë‚  ê²ƒì´ë‹¤. ê·¸ê²ƒì´ Normal(ë²•ì„ ) ì •ë³´ê°€ ë‹´ê¸´ Normal Mapì´ê³  ì´ í…ìŠ¤ì²˜ë¥¼ ì‚¬ìš©í•´ í‘œë©´ì˜ ì„¸ë¶€ì ì¸ ë²•ì„  ë°©í–¥ì„ ì§€ì •í•˜ì—¬ ë¹›ì´ ì…ì‚¬í•  ë•Œë§ˆë‹¤ í‘œë©´ì˜ ì¡°ëª… ë°˜ì‘ì„ ì¡°ì •í•œë‹¤.  
ì¼ì¢…ì˜ ì°©ì‹œ í˜„ìƒ ê°™ì€ ê²ƒì´ë‹¤.  

<br>

<img src="https://www.updateme.cloud/download/Stonex/Cubefly/Guide/lib/UV%20Planar1.png" width="300">
 <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSP72A3wFZ0X5PfpKIXLgEGT9WBVobNHIlqYA&s" width="300">
  
ê° ë¬¼ì²´ë§ˆë‹¤   

<br>

<img src="Docs/Pasted image 20241031171857.png" width="300">
  

<br>

ì—¬ê¸°ì„œ ìƒˆë¡œìš´ ì¢Œí‘œê³„ì˜ ê°œë…ì´ ë‚˜ì˜¤ê²Œ ëœë‹¤.  
/ *Local Space(Coordinate) `= Tangent Space(Coordinate) = SL space(Coordinate)`*  
<img src="https://www.researchgate.net/publication/47861427/figure/fig8/AS:668606312509456@1536419575526/Normal-blue-tangent-red-and-binormal-green-are-computed-per-vertex-Thus-every.png" width="300">
  
Normal Mapì—ëŠ” ìœ„ ì¢Œí‘œ ì¤‘ Nì˜ ê°’ì´ RGB í˜•íƒœë¡œ ë“¤ì–´ìˆëŠ” ê²ƒì´ë‹¤.
<br>


```math
\begin{align}&\begin{pmatrix}n_x \\ n_y \\ n_z\end{pmatrix}\\
n_x = n \cdot T, n_y &s= n\cdot B, n_z = n\cdot N\end{align}
```

Nomal Mapì„ ì´ë¯¸ì§€í™”í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.  
<img src="https://learnopengl.com/img/advanced-lighting/normal_mapping_ground_normals.png" width="300">
  
ì´ì œ ì—¬ê¸°ì„œ ìƒ‰ê¹” ê³„ì‚°ì„ ìœ„í•´ í•„ìš”í•œ ìˆ˜í•™ì€ ë”± í•˜ë‚˜ì´ë‹¤.  
í•˜ë ¤ëŠ” ê²ƒì€ Normal Mapì˜ Normalë¡œ ì›ë˜ Normalì„ ëŒ€ì²´í•´ì„œ Shadingì„ í•˜ë ¤ëŠ” ê²ƒì´ê³ ,   
ìš°ë¦¬ê°€ ì•Œì•„ì•¼ë˜ëŠ” ê²ƒì€ MC/WC/ECì—ì„œ Normal Mapìœ¼ë¡œ ì£¼ì–´ì§„ Normal Vectorë¥¼ ì–´ë–»ê²Œ í‘œí˜„í•  ê²ƒì¸ê°€ ë¼ëŠ” ê²ƒì´ë‹¤. ì´ë¥¼ $`n^*`$ë¼ê³  í•˜ì.  
ê·¸ëŸ¼ ìš°ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‹ì„ ì„¸ìš°ë©´ ëœë‹¤. Texture ì¢Œí‘œì¶•ì— ë¬¼ì²´ì˜ Normalì˜ ìˆ˜ì„ ì„ ë‚´ë¦°ë‹¤ê³  ìƒê°í•˜ë©´ëœë‹¤.
<br>


```math
\begin{align}n_x = T \cdot n ^* \\ n_y = B \cdot n ^* \\ n_z = N \cdot n ^*\end{align}
```

ì´ì œ ì´ë¥¼ $`A\vec x = \vec b`$ë¡œ ë§Œë“¤ì–´ì„œ ì—­í–‰ë ¬ì„ ê³±í•˜ë©´ ë˜ëŠ”ë°, ìš°ë¦¬ê°€ ë‹¤ë£¨ëŠ” ê±´ AëŠ” Orthogonal Matrixë‹ˆê¹Œ ê·¸ëƒ¥ Transposeí•˜ë©´ ëœë‹¤. ë”°ë¼ì„œ ìµœì¢…ì ìœ¼ë¡œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
<br>


```math
\begin{pmatrix}n^*_x \\ n^*_y \\ n^*_z \end{pmatrix} = \begin{pmatrix}T &B & N\end{pmatrix} \begin{pmatrix}n_x \\ n_y \\ n_z\end{pmatrix}
```


<br>

ì´ì œ PaperğŸ“„ 133p.ì˜ ì‹¤ì œ ì½”ë“œë¥¼ ë³´ì.  
êµ³ì´ T B Në‹¤ ì•Œ í•„ìš” ì—†ì´ T->B->Nìœ¼ë¡œ ë‘˜ì”© ì§ì§€ì–´ì„œ ì™¸ì í•˜ë©´ ë‚˜ë¨¸ì§€ í•˜ë‚˜ë¥¼ ì•Œ ìˆ˜ ìˆìœ¼ë‹ˆ  
ë”°ë¼ì„œ ì´ ì½”ë“œì—ì„œëŠ” Attributeë¡œ Position, N, Texture ì¢Œí‘œ, Tê°€ ë“¤ì–´ê°€ìˆë‹¤. (BëŠ” N, Të¡œ êµ¬í•  ìˆ˜ ìˆìŒ)  

<br>

ğŸ“† 2024.11.05  
<img src="Docs/Pasted image 20241105170106.png" width="600">
  

<br>


<br>


<br>

-----------------------------------------------  

<br>

/ Z-Fighting(Depth-Fighting)  
Precision ì˜¤ì°¨ë¥¼ ë³´ì™„í•˜ê¸° ìœ„í•´ $`D_t`$ì— padding offsetì„ ë”í•˜ëŠ” ê²ƒ  
ë¬¼ì²´ë¥¼ Offset ë§Œí¼ ë¯¼ë‹¤ê³  ìƒê°  
<img src="Docs/Pasted image 20241031165600.png" width="300">
 <img src="Docs/Pasted image 20241031170016.png" width="150">
  
ì˜¤ë¥¸ìª½ ê·¸ë¦¼ê³¼ ê°™ì´ Driverì—ì„œëŠ” ì‚¼ê°í˜•ì˜ ê¸°ìš¸ê¸°ì— ë”°ë¼ ì§€ì •í•´ì¤„ Offsetì„ ë‹¤ë¥´ê²Œ ê³„ì‚°í•˜ê¸°ë„ í•œë‹¤.  

<br>

**Forward Rendering**: Rasterization Algorithm  
**Backword Rendering**: Ray Tracing  
**Deferred Rendering**: ìœ„ ë‘ ë Œë”ë§ ê¸°ë²•ì˜ ë‹¨ì  ë³´ì™„  
`ìì„¸í•œ ê²ƒì€ GPT ì°¸ê³ `  

<br>

9p. Resterization ì‹œ Linear Interpolationìœ¼ë¡œ ì„ í˜•ë³´ê°„ë˜ì–´ ì¢Œí‘œê°€ ê²°ì •ëœë‹¤.
<br>

$`(s_0, t_0), (s_1, t_1), (s_2, t_2)`$

<br>

# Deffered Rendering  

<br>

ì˜¤ëŠ˜ ìš°ë¦¬ëŠ” Forward Renderingê³¼ Deffered Renderingì˜ ì°¨ì´ì ì„ ë¹„êµí•´ë³¼ ê²ƒì´ë‹¤.  
Forward Renderingì´ë¼ëŠ” ê²ƒì€ ìš°ë¦¬ê°€ ì˜ ì•„ëŠ” pipelineì—ì„œ pixelì˜ ìƒ‰ê¹”ì„ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì´ë‹¤.  
- Vertex-lit Rendering: Shaderë¥¼ ì“°ì§€ ì•ŠëŠ” Fixed Function Pipeline  
- Forward Rendering: Shaderë¥¼ ì“¸ ìˆ˜ ìˆëŠ” Pipeline  
- Deferred Rendering: d  

<br>

<img src="https://cglearn.eu/images/acg/deferred/deferred-pipeline-1.png" width="200">
 <img src="https://cglearn.eu/images/acg/deferred/deferred-pipeline-2.png" width="400">
  
â–¶ Forward Rendering, Deferred Rendering  

<br>

Forward Renderingì˜ Pipelineì„ ê°„ë‹¨í•˜ê²Œ ë´ë³´ì.  
VS -> TS -> GS -> FF -> Raster -> FS -> Raster Operation -> FB  
- ê´‘ì›ì´ ë§ì„ ë•Œ FSì—ì„œ Ranster Operationìœ¼ë¡œ ë„˜ì–´ê°ˆ ë•Œ Floating Point ì—°ì‚°ì´ ë‚­ë¹„ëœë‹¤.  

<br>

Deferred Renderingì€ Forward Renderingì˜ Pipelineì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë˜, í•œ ë²ˆ ë” ë°˜ë³µí•œë‹¤.  
Pass Iì—ì„œëŠ” ì •ìƒì ìœ¼ë¡œ ë Œë”ë§ì„ í•˜ê³ , G-bufferë¼ëŠ” Dataë¥¼ ìƒì„±í•œë‹¤.  
Pass IIì—ì„œ Shading ê³„ì‚°ì„ í•˜ê²Œëœë‹¤.  
`Reference - Leran OpenGL`  
ì°¨ì´ì ì€ Pass Iì˜ ê²°ê³¼ë¥¼ FBê°€ ì•„ë‹Œ FBOì— ê·¸ë¦°ë‹¤.  
FBOì—ëŠ” Texture Imageë¥¼ ë¶™ì¼ ìˆ˜ ìˆë‹¤ê³  í–ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ì •ë³´ë¥¼ ë¶™ì—¬ì¤€ë‹¤.  

<br>

/ **G-buffer**  
<img src="Docs/Pasted image 20241107172312.png" width="450">
  
- Position: ì„¸ìƒì¢Œí‘œê³„ì—ì„œì˜ x, y, zê°’  
- Normal: ìš¸í‰ë¶ˆí‰í•œ ì •ë„  
- Albedo (RGB) + Specular (A): ê¸°ë³¸ ìƒ‰ê¹” + ì •ë°˜ì‚¬ ì •ë„  
- Depth Buffer: ì•ì— ìˆëŠ”ì§€ ë’¤ì— ìˆëŠ”ì§€  

<br>

ì •ìƒì ì¸ ë Œë”ë§ì´ë¼ë©´ ë‚´ ëˆˆì— ë³´ì´ëŠ” ë¬¼ì²´ë“¤ë§Œ ê·¸ë¦¬ê²Œ ë  ê²ƒì´ë‹¤.  
ë’¤ì— ìˆëŠ” ë¬¼ì²´ëŠ” Depth Bufferì—ì„œ ë‚ ë¼ê°„ë‹¤.  

<br>

ì¼ë‹¨ ì½”ë“œë¥¼ ë³´ë©° ì´í•´í•´ë³´ì.  
defferedì—ì„  min filterë„ fl_nearestë¡œ í•˜ê³  mag filterë„ íˆ nearestë¡œ í•œë‹¤. ì´ ë¶€ë¶„ ê½¤ ì¤‘ìš”í•˜ë‹ˆ ì˜ ê¸°ì–µí•˜ê³  ë„˜ì–´ê°€ì.  
ë‹¤ìŒ ì½”ë“œê°€ FBOì— RGB texture í•˜ë‚˜ë¥¼ ë¶™ì´ëŠ” í•˜ë‚˜ì˜ ë¸”ë¡ ê³¼ì •ì´ë‹¤.  
```cpp
glGenTextures(1, &gPosition);
glBundTexture(GL_TEXTURE_2D, gPosition);
// RGBA 16it floating point
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, -, GL_RGBA, GL_FLOAT, NULL);
glTexParameteri(GL_TEXTURE_2D, GL_TI+EXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTIRE_MAG_FILTER, GL_NEAREST);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, gNormal, 0);
```

<br>

ë§ˆì§€ë§‰ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ì´ Attachí•´ì¤€ë‹¤.  
```cpp
unsigned in attachements[3] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2 };
glDrawBuffer(3, attachments);
```

<br>

ì´ì œ Render Bufferì— Depth Buffer ì •ë³´ë¥¼ ì €ì¥í•œë‹¤.  
Render BufferëŠ” Pass Iì—ì„œ í•œ ë²ˆ ì“°ê³  ë²„ë¦´ê±°ê¸° ë•Œë¬¸ì— ì¢€ ë” ë³µì¡í•˜ê²Œ ìƒê²¼ì§€ë§Œ Textureì™€ëŠ” ë‹¤ë¥¸ í˜•ì‹ìœ¼ë¡œ ì €ì¥í•œë‹¤. ì‚¬ì‹¤ Textureë¥¼ ì¨ë„ ë˜ëŠ”ë°, ì—¬ëŸ¬ëª¨ë¡œ Writeê°€ ë” ë¹ ë¥´ê¸°ì— íš¨ìœ¨ì„ ìœ„í•´ ì´ë ‡ê²Œ í•˜ëŠ” ê²ƒ ê°™ë‹¤. `ì‚¬ì‹¤ ì»´í“¨í„°ì—ì„œëŠ” GPUê°€ ì›Œë‚™ ë¹ ë¥´ê¸° ë•Œë¬¸ì— ë­˜ ì“°ë˜ ìƒê´€ì—†ëŠ” ê²ƒ ê°™ë‹¤. `  
```cpp
glGenRenderbuffers(1, &rboDepth);
glBindRenderbuffer(GL_RENDERBUFFER, rboDepth);
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, SCR_WIDTH, SCR_HEIGHT);
glFramebufferRenderbuffer(GL_FRAMBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);

// check Frambuffer is complete
...

glBnidFrambuffer(GL_FRAMECUFFER, 0) // Systemì—ì„œ ì‚¬ìš©í•˜ëŠ” ê¸°ë³¸ Bufferì— ìµœì¢…ì ìœ¼ë¡œ Bind
/* Default Setting Complete!! */
```
ì´ì œ G-bufferì˜ ì„¸íŒ…ì´ ì™„ë£Œë˜ì—ˆë‹¤.  
ì´ì œ ë‹¤ìŒ Passì—ì„œ ìƒ‰ê¹” ê³„ì‚° ì‹œ ì´ë¥¼ ì‚¬ìš©í•˜ê²Œ ë  ê²ƒì´ë‹¤.  

<br>

ì´ë ‡ê²Œ í•œ ë²ˆ ë” Shadingì„ í•¨ìœ¼ë¡œì¨ ì „ì—ëŠ” ìƒ‰ê¹” ë‹¤ ê³„ì‚° í•´ë†“ê³  `ì•„; ë¯¸ì•ˆ ë„ˆ ë’¤ì— ìˆì—ˆë„¤.. ì£½ì–´ë¼!`  
í•˜ë˜ ê²Œ ì´ì œëŠ” Pass Iì—ì„œ ë¯¸ë¦¬ ì•ì¸ì§€ ë’¤ì¸ì§€ ì•Œê³  ê°€ì„œ ê·¸ ë¶€ë¶„ë§Œ ê³„ì‚°í•˜ê¸° ë•Œë¬¸ì— floating point ì—°ì‚°ì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤.  
ê°ê° ë‹¤ ì¥ë‹¨ì ì€ ìˆì§€ë§Œì„œë„ ì–¸ëœ» ë´ì„œëŠ” Deferred Renderingì´ ë” íš¨ìœ¨ì ìœ¼ë¡œ ë³´ì¸ë‹¤.  

<br>

ğŸ“† 2024.11.12  

<br>

<img src="Docs/Pasted image 20241112164120.png" width="600">
  

<br>

```cpp
//shader condiguration
shaderLightintPass.setInt("gPosition, 0");
// OpenGLì—ì„œ Textureë¥¼ ë„˜ê²¨ì£¼ëŠ” ë°©ì‹, 0ë²ˆ Texture Unitì— ë¶™ì—¬ì¤€ Texture Unitì— Access í•´ë¼.
shaderLightintPass.setInt("gNormal, 1");
shaderLightintPass.setInt("gAlbedo, 2");
```

<br>

reference: ğŸ“ CSE4170_ê°•ì˜ìë£Œ_6.pdf  

<br>

renderQuad()ì—ì„  ë¬¼ì²´ë¥¼ ê·¸ë¦¬ê¸° ì „ í•„ìš”í•œ Modeling, Viewing, Perspective ë³€í™˜ì„ í•˜ì§€ ì•Šê³  ìˆë‹¤.  
ê·¸ì—ë”°ë¼ Vertex Shaderì˜ ë‚´ìš©ë„ ì‚´ì§ ë‹¤ë¥´ë‹¤.  
ì›ë˜ Vertex Shaderì—ì„  MCì—ì„œ `M_M -> M_V -> M_P`ë¥¼ í•˜ì—¬ CCë¡œ ë³´ë‚´ì¤˜ì•¼ í•˜ëŠ”ë°
<br>


```math
\begin{pmatrix}-1 \\ -1 \\ 0 \\ 1\end{pmatrix}_{MC} \rightarrow \begin{pmatrix}-1 \\ -1\\0\\1\end{pmatrix}_{CC} \rightarrow PD\rightarrow\begin{pmatrix}-1\\-1\\0\\1\end{pmatrix}_{NDC}\rightarrow NDC \rightarrow RAS
```

$`[0.0, 1.0]\times [0.0, 1.0]`$ì— í•´ë‹¹í•˜ëŠ” WDCì—ì„œ (s, t)ì— í•´ë‹¹í•˜ëŠ” Texture ì¢Œí‘œì˜ ê°’ì„ ê°€ì ¸ì™€ì„œ Shadingì„ ìˆ˜í–‰í•œë‹¤.

<br>

ê·¼ë° CSE4070ì—ì„œ ë°°ìš´ëŒ€ë¡œ ì›ë˜ ì›ê·¼íˆ¬ì˜ì—ì„  CCì—ì„œ wê°€ 1ì´ ë  ìˆ˜ê°€ ì—†ì„í…ë°, ë¬´ìŠ¨ ì¼ì¼ê¹Œ?  
ì—¬ê¸°ì„  ì›ê·¼ íˆ¬ì˜ì´ ì•„ë‹ˆë¼, ì§êµ íˆ¬ì˜(Orthogonal Projection)ì„ ì‚¬ìš©í•˜ê³  ìˆëŠ” ê²ƒì´ë‹¤.  
<img src="https://i.ytimg.com/vi/dUJzpz8J9xw/maxresdefault.jpg" width="300">
  

<br>

M_V ì´ê²Œ ë‹¨ìœ„ í–‰ë ¬ì´ë¼ëŠ” ëœ»ì€ ì¹´ë©”ë¼ê°€ ì›ì ì— ìˆë‹¤ëŠ” ê²ƒì´ë‹¤. (WC = CC)  
M_M ë”°ë¼ì„œ ì´ê²ƒë„ ë‹¨ìœ„í–‰ë ¬ì´ ëœë‹¤.  

<br>

```vert
TexCoods = aTexCoords;
gl_Position = vec4(aPos, 1.0);
```
??  

<br>

```cpp
//diffuse
...
//specular
...
//attenuation
...
```

<br>

ì´ì œ Shading ê³„ì‚°ì´ ëë‚¬ë‹¤.  

<br>

/ **Forward Rendering(Without, With Early Depth Test) vs Deffered Rendering**  
ê·¼ë° ì´ê²Œ ì „í†µì ì¸ Forward Renderingë³´ë‹¤ ë­ê°€ ì¢‹ì€ê±¸ê¹Œ?  
(+) ë”± G-bufferë¥¼ ë§Œë“  ë‹¤ìŒ ëˆˆ ì•ì— ë³´ì´ëŠ” ë¬¼ì²´ì— ëŒ€í•´ì„œë§Œ ê³ ë¹„ìš©ì˜ Shading ê³„ì‚°ì„ ì§„í–‰í•œë‹¤.  

<br>

ìš°ë¦¬ê°€ ì•Œê³ ìˆëŠ” ì „í†µì ì¸ Rendering Pipelineì„ ë³´ì. `ê°•ì˜ìë£Œ 6 98p.`  
Pixelì˜ ìµœì¢… RGBAê°’ê³¼ Depth Zê°’, ê·¸ë¦¬ê³  Position ê°’ì´ ë“¤ì–´ì˜¤ë©´ ê·¸ ë‹¤ìŒì— Blendingì´ ì¼ì–´ë‚˜ì„œ ìµœì¢… pixel ê°’ì´ ê³„ì‚°ëœë‹¤. ì¦‰, Depth Testê°€ ëë‹¨ì—ì„œ ì¼ì–´ë‚œë‹¤.  

<br>

ë”°ë¼ì„œ ì´ Depth Testë¥¼ ì•ìª½ìœ¼ë¡œ ë„˜ê¸°ìë¼ëŠ” Ideaê°€ ë‚˜ì™”ëŠ”ë°, ì´ê°€ ë°”ë¡œ Early Depth Testì´ë‹¤.`Fragment Processing ì „ì— ì´ Depth Testë¥¼ í•˜ì.`  
ì§€ê¸ˆì€ ì´ ë°©ë²•ì´ ì •í˜•í™”ë˜ì–´ì„œ ì¸ìë¡œ ì§€ì •í•´ì¤˜ì„œ ì´ ê¸°ëŠ¥ì„ ì¼œê¸°ë§Œ í•˜ë©´ ëœë‹¤.  
(-) ê·¸ëŸ°ë° ì´ ê¸°ëŠ¥ì„ ì¼œë„ FragmentëŠ” í™”ë©´ìƒì— ëœë¤ìœ¼ë¡œ ë“¤ì–´ì˜¤ê¸° ë•Œë¬¸ì— ë’¤ì—ìˆëŠ” ê²ƒë¶€í„° ë“¤ì–´ì˜¤ê²Œ ë˜ë©´ ì–´ì°¨í”¼ ë‹¤ í†µê³¼ë˜ê²Œ ë˜ì–´ë²„ë¦°ë‹¤.  
Deffered Shadingì€ ì´ ë‹¨ì ê¹Œì§€ ë‹¤ ë³´ì™„í•œ ë°©ë²•ì¸ê²ƒì´ë‹¤.  

<br>

/ **A Larger Number of Lights**  
<img src="Docs/Pasted image 20241112174115.png" width="600">
  
ì—¬ê¸°ì„œ ë” ë‚˜ì•„ê°€ë©´, ê·¹í•œì˜ íš¨ìœ¨ì„ ì¶”êµ¬í•˜ëŠ” ê²Œì„ì—…ê³„ì—ì„  íŠ¹ì • ë²”ìœ„ê¹Œì§€ë§Œ ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ì§€ì—­ê´‘ì›ì€ ì•„ì˜ˆ ê³„ì‚°ì„ ì•ˆí•˜ê³  ë„˜ì–´ê°„ë‹¤.  
ê·¸ êµ¬ì²´ì ì¸ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. `reference: Learn OpenGL 360p.`
<br>


```math
\frac{5}{256} = \frac{i_{max}}{\text{Attenuation}}
```


<br>


<br>

$`\begin{cases}\frac{1}{k_{0i}+k_{1i}||VP_{pli}||+k_{2i}||VP_{pli}||^2},\ P_{pli}'s\ w \neq 0 \text{ (point light)} \\ 1.0,\ P_{pli}'s\ w = 0 \text{ (directional light)}\end{cases}`$

<br>

ê´‘ì›ë§ˆë‹¤ ê´‘ì›ì˜ ì¢Œí‘œ, ê´‘ì›ì˜ rgbê°’, ê·¸ë¦¬ê³  ìœ„ì™€ ê°™ì€ ê´‘ì›ì˜ attì‹ì´ ìˆë‹¤ê³  í–ˆì„ ë•Œ,   
ê´‘ì›ì˜ attê°’ì´ ì‚¬ìš©ìê°€ ì„¤ì •í•œ ê°’ë³´ë‹¤ ì‘ì•„ì§€ëŠ” distanceë¥¼ ê³„ì‚°í•´ì„œ ì´ distanceë³´ë‹¤ ë©€ë©´ ì•„ì˜ˆ ì´ ê´‘ì›ì€ ë¬´ì‹œí•œë‹¤.  

<br>

ì‹¤ì œ ê·¸ Distanceë¥¼ ê³„ì‚°í•˜ëŠ” ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. `360p. ê·¼í•´ ê³µì‹ ì°¸ê³ `  
```cpp
float radius = (-linear + sqrt(linear * linear - 4 *))..
```

<br>

ê·¸ë¦¬ê³  Fragment Shaderì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ ê±°ë¦¬ ê²€ì‚¬ë¥¼ í•˜ê³  ê´‘ì›ì„ ë¬´ì‹œí•œë‹¤.  
```cpp
for(int i = 0; i < NR_LIGHTS; ++i) {
	if (distance < lights[i].Radius) {
		// Process Shading
	}
	else {
		// Do not Process Shading
	}
}
```

<br>

ê·¸ëŸ°ë° ì—¬ê¸°ê°€ ìµœì í™”ì˜ ëì¼ê¹Œ? ì•„ë‹ˆë‹¤.  
ê²Œì„ ì—…ê³„ë¥¼ ë¬´ì‹œí•˜ì§€ ë§ˆë¼.. `ëˆì´ ë‹¬ë¦° ì½”ë”©ì€ ë‹¤ë¥´ë‹¤.`  

<br>

/ **SIMD with QUDA**  
reference: ğŸ“ CSEG5483_ê°•ì˜ìë£Œ_1 12p.  
ìš°ë¦¬ê°€ CSEG5483ì—ì„œ ì£¼êµ¬ì¥ì°½ ë°°ìš´ ê²ƒì²˜ëŸ¼ Shaderë¥¼ SIMDí•˜ê²Œ ëŒë ¤ ë”ìš± ë” ìµœì í™”í•œë‹¤.  
QUDAê°€ ë“±ì¥í•˜ê²Œ ëœ ê³„ê¸°ê°€ ê·¸ë˜í”½ í”„ë¡œê·¸ë˜ë°ì´ë¼ê³  í•  ìˆ˜ ìˆê² ë‹¤.  

<br>

(!) ê·¸ëŸ°ë° ì‹¤ì œ ì½”ë“œë¥¼ ë³´ë©´ forë¬¸ë„ ifë¬¸ì˜ ì¼ì¢…ì´ê³  ì•ˆì—ì„œ distance ê²€ì‚¬ë¥¼ í•˜ëŠ” ê²ƒë„ ifë¬¸ì´ë¼ ifë¬¸ì´ ì¤‘ì²©ë˜ì–´ SIMD í˜•íƒœë¡œ ëŒë¦¬ê¸°ê°€ ë§¤ìš° ê³¤ë€í•´ì§„ë‹¤.  
ë”°ë¼ì„œ ì‚¬ëŒë“¤ì€ ë‹¤ì‹œ ì´ `if (distance < lights[i].Radius)`ë¥¼ ì—†ì•¨ê¹Œ..? ë¥¼ ê³ ë¯¼í•œë‹¤.  
ì´ì™€ ê´€ë ¨í•œ ê²Œ ë°”ë¡œë°”ë¡œ Stencil Testì´ë‹¤.  

<br>


<br>

-------------------------------  

<br>

ğŸ“† 24.11.14 Presentation Day  

<br>

ğŸŸ¡  
Low Poly Model? `FBX file ë³€í™˜ ë° Import`  
.ppm -> .jpg or windowë¡œ ë°”ë¡œ í™•ì¸  
Ramping  
ì—°ì‚° ìµœì í™”: AABB ê²€ì‚¬  

<br>

ğŸŸ¡  
Blinn-Phong + (Spot + Light Attenuation) `Struct Spot, Attenuation`  
Sphere êµ´ì ˆë¥  2.4  
stbi_set_flip_vertically_on_load(1)  
OpenGLì€ Textureê°€ ì•„ë˜ì„œë¶€í„° ì €ì¥ì´ ëœë‹¤. (CSE4170 Project1 ì—ì„œ í™•ì¸í–ˆì—ˆìŒ)  

<br>

êµìˆ˜ë‹˜ æ›°:  
Pixelì—ë‹¤ Rayë¥¼ ìµœì†Œ 256ê°œì”© ì´ì„œ Renderingì„ í•´ì•¼ì§€ ì´ë¯¸ì§€ê°€ ë” ê¹¨ë—í•˜ê²Œ ë‚˜ì˜¨ë‹¤.  

<br>

ğŸŸ¡  

<br>

ğŸŸ¡  
Triangular Meshì— Bounding Box ì¶”ê°€  
Reflect Ray  
Refract Ray: ì „ë°˜ì‚¬ í™•ì¸, ë‚´ë¶€/ì™¸ë¶€ í™•ì¸  

<br>

êµìˆ˜ë‹˜ æ›°:  
ìƒ‰ìœ ë¦¬ ê·¸ë¦¼ì ìƒì„±ì„ í•˜ë ¤ë©´ Path Tracingì„ ì‚¬ìš©í•´ì•¼ í•¨  
í•´ìƒë„?  

<br>

ğŸŸ¡  
êµìˆ˜ë‹˜ æ›°:  
- Whitted Styleì˜ í•œê³„: ìœ ë¦¬ì˜ ê·¸ë¦¼ì, ë”°ë¼ì„œ ì ë‹¹íˆ ìœ ë¦¬ì˜ ê·¸ë¦¼ìëŠ” ë°ê²Œ í•´ì„œ ë³´ì™„í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í•œë‹¤.  
- Multisampling: ì˜í™” ê°™ì€ ë°ì„  Rayë¥¼ 256ê°œ ì”© ì˜ê¸°ë„ í•œë‹¤. ìµœì†Œ 16ê°œëŠ” ì´ì•¼ ìµœì†Œ ê¸°ì¤€ì„ ë§Œì¡±í•  ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.  
- Pixelì— ë”°ë¼ Addptiveí•˜ê²Œ ì˜ê¸°ë„ í•œë‹¤. `ì–´ë–¤ Pixelì€ 4ê°œ, ì–´ë–¤ Pixelì€ 16ê°œ..`  

<br>

ğŸŸ¡  
êµìˆ˜ë‹˜ æ›°:  
Relfectionìœ¼ë¡œ ë°˜ì‚¬ëœ Rayì—ì„œë„ Shadow Rayë¥¼ ì´ì•¼ Shadow ê³„ì‚° ê°€ëŠ¥  

<br>

ğŸŸ¡  
êµìˆ˜ë‹˜ æ›°:  
Self Intersection: ì ë°•ì´  

<br>

ğŸŸ¡  
êµìˆ˜ë‹˜ æ›°:  
- Triangular Mesh ê³„ì‚° ì‹œ tê°’ì´ ë§¤ìš° ì˜ˆë¯¼í•˜ê¸° ë•Œë¬¸ì— Epsilon ê°’ì„ ì‹¤í—˜ì„ í†µí•´ì„œ ì˜ ì•Œì•„ë‚´ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.  
- ë°˜íˆ¬ëª…í•œ ìœ ë¦¬êµ¬ì—ì„œ rayê°€ í†µê³¼í–ˆì„ ë•Œ Transparecyë¥¼ ê³„ì‚°í•˜ëŠ” ê³µì‹ì´ ìˆë‹¤.  
- Photon Mapping ê¸°ë²•  

<br>

ğŸŸ¡  
êµìˆ˜ë‹˜ æ›°:  

<br>


<br>

------------------------------------  

<br>

# Stencil Test  

<br>

reference: ğŸ“ OpenGL_4.4_Pipeline.pdf, ğŸ“ 2403CSE4170_ê°•ì˜ìë£Œ_5.pdf  

<br>

`CSE4170 ê°•ì˜ìë£Œ 5 86p.` 4ì‚¬ë¶„ë©´ì„ ë³´ë©´ ë‹¤ìŒì„ ë³¼ ìˆ˜ ìˆë‹¤.  
```
Stencil Test -> Depth Buffer Test -> Blending(RGBA)
```
Stencil TestëŠ” ì´ˆë³´ì ë‹¨ê³„ì—ì„  ì•„ì§ ì“¸ ì¼ì´ ë³„ë¡œ ì—†ëŠ”, ìƒë‹¹íˆ ì „ë¬¸ì ì¸ Testì´ë‹¤.  
Depth Buffer Testì—ì„œ `glDepthFunc(GL_LESS)`ëŠ” Franmentì˜ Depthê°’ì´ Depthë³´ë‹¤ ì‘ìœ¼ë©´ í†µê³¼ ì‹œí‚¤ë¼ëŠ” ëœ»ì´ë‹¤.  
Blendingì€ CSE4170ì˜ ì¶”ê°€ ê³¼ì œë¥¼ í•˜ë©° í•´ë³´ì•˜ì„ ê²ƒì´ë‹¤.  

<br>

[Framebuffer - OpenGL Wiki](https://www.khronos.org/opengl/wiki/framebuffer)  
ìœ„ ì‚¬ì´íŠ¸ë¥¼ ë´ë³´ë©´, COLOR BufferëŠ” ì—¬ëŸ¬ê°œ ë¶™ì¼ ìˆ˜ ìˆì§€ë§Œ, DEPTH Bufferì™€ STENCIL BufferëŠ” í•˜ë‚˜ì”©ë§Œ ë¶™ì¼ ìˆ˜ ìˆë‹¤.  
ë‘˜ì„ í•˜ë‚˜ë¡œ í•©ì³ì„œ ë¶™ì¼ìˆ˜ë„ ìˆë‹¤. `GL_DEPTH_STENCIL_ATTACHMENT`  

<br>

[Stencil Test - OpenGL Wiki](https://www.khronos.org/opengl/wiki/Stencil_Test)  
```
glStencilFunc(GLenum func, GLint ref, GLuint mask)
```
`glDepthFunc()`ì²˜ëŸ¼, Testì— ë“¤ì–´ì˜¤ëŠ” Fragmentë¥¼ ìƒí™©ì— ë”°ë¼ì„œ ì–´ë–»ê²Œ í•  ê²ƒì¸ì§€ë¥¼ ê²°ì •í•˜ëŠ” ê²ƒì´ë‹¤.  
ì°¸ê³ ë¡œ MaskëŠ” 8bitì´ë‹¤.  
`GL_LESS`ë¡œ ì˜ˆë¥¼ ë“¤ìë©´ ë‹¤ìŒê³¼ ê°™ì´ ì—°ì‚°ë˜ëŠ” ê²ƒì´ë‹¤.  
```
GL_LESS
Passes if (ref & mask) < (stencil & mask)
```

<br>

ë‹¤ìŒê³¼ ê°™ì€ í•¨ìˆ˜ë„ ìˆë‹¤. `ì´ë ‡ê²Œê¹Œì§€ í•œë‹¤ê³ ..? ì‹¶ì€ í•¨ìˆ˜ë‹¤.`  
```
glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
```
- `sfail`: Stencil Testì—ì„œ ì£½ëŠ” ê²½ìš°  
- `dpfail`: Depth Testì—ì„œ ì£½ëŠ” ê²½ìš°  
- `dppass`: ë‘˜ ë‹¤ í†µê³¼í•´ì„œ Blendingê¹Œì§€ ê°€ëŠ” ê²½ìš°  

<br>

ğŸ“„`5.advanced_lighting_deferred_shading_volu/8.2.deferred_shading.fs`ë¥¼ ë´ë³´ì.  
`/ A Larger Number of Lights`ì—ì„œ í–ˆë˜ ì–˜ê¸°ë¥¼ ìƒê¸°í•´ë³´ì.  

<br>

[Tutorial 37 - Deferred Shading - Part 3](https://www.ogldev.org/www/tutorial37/tutorial37.html)  
ë‹¤ìŒ ì‚¬ì´íŠ¸ë¥¼ ë³´ë©° Step by Stepìœ¼ë¡œ ìœ„ ê³¼ì •ì„ ì–´ë–»ê²Œ í•˜ëŠ”ì§€ ìì„¸íˆ ì‚´í´ë³´ì.  
ë°”ë¡œ ì—¬ê¸°ì„œ Stencil Testê°€ ì“°ì¸ë‹¤.  

<br>

<img src="https://www.ogldev.org/www/tutorial37/light_volume.jpg" width="200">
 <img src="Docs/Pasted image 20241119171947.png" width="202">
  <img src="Docs/Pasted image 20241119173449.png" width="199">
  

<br>

ì‹¤ì œë¡œ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ë™í•œë‹¤. `**ëŠ” ë¬¸ë²•ì´ ì•„ë‹ˆë¼ ê°•ì¡°í‘œì‹œ`  
```cpp
virtual void RenderSceneCB()  
{  
Â  Â  CalcFPS();  
  
Â  Â  m_scale += 0.05f;  
  
Â  Â  m_pGameCamera->OnRender();  
  
Â  Â Â **m_gbuffer.StartFrame();**  
  
Â  Â  DSGeometryPass();  
  
Â  Â  // We need stencil to be enabled in the stencil pass to get the stencil buffer  
Â  Â  // updated and we also need it in the light pass because we render the light  
Â  Â  // only if the stencil passes.  
Â  Â Â **glEnable(GL_STENCIL_TEST);  
  
Â  Â  for (unsigned int i = 0 ; i < ARRAY_SIZE_IN_ELEMENTS(m_pointLight); i++) {  
Â  Â  Â  Â  DSStencilPass(i);  
Â  Â  Â  Â  DSPointLightPass(i);  
Â  Â  }  
  
Â  Â  // The directional light does not need a stencil test because its volume  
Â  Â  // is unlimited and the final pass simply copies the texture.  
Â  Â  glDisable(GL_STENCIL_TEST);**  
  
Â  Â  DSDirectionalLightPass();  
  
Â  Â Â **DSFinalPass();**  
  
Â  Â  RenderFPS();  
  
Â  Â  glutSwapBuffers();  
}

void DSGeometryPass()  
{  
Â  Â  m_DSGeomPassTech.Enable();  
  
Â  Â Â **m_gbuffer.BindForGeomPass();**  
  
Â  Â  // Only the geometry pass updates the depth buffer  
Â  Â  glDepthMask(GL_TRUE);  
  
Â  Â  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  
  
Â  Â  glEnable(GL_DEPTH_TEST);  
  
Â  Â  Pipeline p;  
Â  Â  p.SetCamera(m_pGameCamera->GetPos(), m_pGameCamera->GetTarget(), m_pGameCamera->GetUp());  
Â  Â  p.SetPerspectiveProj(m_persProjInfo);  
Â  Â  p.Rotate(0.0f, m_scale, 0.0f);  
  
Â  Â  for (unsigned int i = 0 ; i < ARRAY_SIZE_IN_ELEMENTS(m_boxPositions) ; i++) {  
Â  Â  Â  Â  p.WorldPos(m_boxPositions[i]);  
Â  Â  Â  Â  m_DSGeomPassTech.SetWVP(p.GetWVPTrans());  
Â  Â  Â  Â  m_DSGeomPassTech.SetWorldMatrix(p.GetWorldTrans());  
Â  Â  Â  Â  m_box.Render();  
Â  Â  }  
  
Â  Â  // When we get here the depth buffer is already populated and the stencil pass  
Â  Â  // depends on it, but it does not write to it.  
Â  Â  glDepthMask(GL_FALSE);  // â˜… ìœ„ ê³¼ì •ì„ ì™„ë£Œí•œ ë‹¤ìŒ Depth Bufferë¥¼ Read-onlyë¡œ ë°”ê¾¼ë‹¤.
}

void DSStencilPass(unsigned int PointLightIndex)  
{  
Â  Â  m_nullTech.Enable();  
  
Â  Â  // Disable color/depth write and enable stencil  
Â  Â  m_gbuffer.BindForStencilPass();  
Â  Â  glEnable(GL_DEPTH_TEST);  
  
Â  Â  glDisable(GL_CULL_FACE);  
  
Â  Â  glClear(GL_STENCIL_BUFFER_BIT);  // 0ìœ¼ë¡œ ì´ˆê¸°í™”
  
Â  Â  // We need the stencil test to be enabled but we want it  
Â  Â  // to succeed always. Only the depth test matters.  
Â  Â  glStencilFunc(GL_ALWAYS, 0, 0);  // í•­ìƒ í†µê³¼

    // â˜… ì´ê²Œ ì£¼ìš” ë¶€ë¶„ì´ë‹¤.
Â  Â  glStencilOpSeparate(GL_BACK, GL_KEEP, GL_INCR_WRAP, GL_KEEP);  
Â  Â  glStencilOpSeparate(GL_FRONT, GL_KEEP, GL_DECR_WRAP, GL_KEEP); 
Â  Â  // Stencil Test, ê·¸ëƒ¥ ë‚´ë¹„ë‘  (GL_KEEP)
Â  Â  // Depth Test, Back Faceì—ì„  1 ì¤‘ê°€ì‹œí‚¤ê³  Front Faceì—ì„  1 ê°ì†Œì‹œí‚¨ë‹¤. (ê·¸ë¦¼ ì°¸ê³ )
  
Â  Â  Pipeline p;  
Â  Â  p.WorldPos(m_pointLight[PointLightIndex].Position);  
Â  Â  float BBoxScale = CalcPointLightBSphere(m_pointLight[PointLightIndex].Color,  
Â  Â  Â  Â  m_pointLight[PointLightIndex].DiffuseIntensity);  // ê°ê°ì˜ êµ¬ ì¤€ë¹„
Â  Â  p.Scale(BBoxScale, BBoxScale, BBoxScale);  // êµ¬ë§ˆë‹¤ ë¯¸ì¹˜ëŠ” ë²”ìœ„ê°€ ë‹¤ë¦„ (Scale)
Â  Â  p.SetCamera(m_pGameCamera->GetPos(), m_pGameCamera->GetTarget(), m_pGameCamera->GetUp());  
Â  Â  p.SetPerspectiveProj(m_persProjInfo);  
  
Â  Â  m_nullTech.SetWVP(p.GetWVPTrans());  
Â  Â  m_bsphere.Render();  
}

void DSPointLightPass(unsigned int PointLightIndex)  
{  
Â  Â  m_gbuffer.BindForLightPass();  
  
Â  Â  m_DSPointLightPassTech.Enable();  
Â  Â  m_DSPointLightPassTech.SetEyeWorldPos(m_pGameCamera->GetPos());  
  
Â  Â  glStencilFunc(GL_NOTEQUAL, 0, 0xFF);
Â  Â  // ê·¸ë¦¼ 3ì—ì„œ ì„¸íŒ…í•œ ref(0) ê°’ê³¼ ë¹„êµí•´ì„œ ê°™ìœ¼ë©´ ì£½ì—¬ë¼
Â  Â  // ì´ì œ ê´‘ì› ë²”ìœ„ ì•ˆì—ì„œë§Œ Shadingì´ ì¼ì–´ë‚œë‹¤. (Setup ì™„ë£Œ)

Â  Â  glDisable(GL_DEPTH_TEST);  
Â  Â  glEnable(GL_BLEND);  // Blending ê¸°ëŠ¥ ì¼œë¼ (Default êº¼ì ¸ìˆìŒ)
Â  Â  glBlendEquation(GL_FUNC_ADD);  
Â  Â  glBlendFunc(GL_ONE, GL_ONE);  
Â  Â  // CSE4170 ê°•ì˜ìë£Œ 6 117, 122p. ì°¸ê³ 
Â  Â  // Source Factor (1, 1, 1, 1), Destination Factor (1, 1, 1, 1)
Â  Â  // -> ê°ê°ì˜ ê´‘ì›ì— ëŒ€í•´ì„œ Shading ëœ Colorê°€ ëˆ„ì ëœë‹¤.
  
Â  Â  glEnable(GL_CULL_FACE);  
Â  Â  glCullFace(GL_FRONT);
Â  Â  // Front Face ì œê±°, ì•ˆ í•˜ë©´ ìƒ‰ì´ íƒ€ë²„ë¦°ë‹¤. FFì—ì„œë„ Shadingì´ í•œ ë²ˆ, BFì—ì„œë„ Shadingì´ í•œ ë²ˆ ì¼ì–´ë‚˜ê¸° ë•Œë¬¸ì´ë‹¤.
Â  Â  // Front Faceë¥¼ ì œê±°í•˜ëŠ” ì´ìœ ëŠ” ì¹´ë©”ë¼ ìœ„ì¹˜ ë•Œë¬¸ì´ë‹¤ (ì´ ë¶€ë¶„ ì˜ ëª¨ë¥´ê² ë‹¤)
Â  Â    
Â  Â  Pipeline p;  
Â  Â  p.WorldPos(m_pointLight[PointLightIndex].Position);  
Â  Â  float BBoxScale = CalcPointLightBSphere(m_pointLight[PointLightIndex].Color,  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  m_pointLight[PointLightIndex].DiffuseIntensity);  
Â  Â  p.Scale(BBoxScale, BBoxScale, BBoxScale);  
Â  Â  p.SetCamera(m_pGameCamera->GetPos(), m_pGameCamera->GetTarget(), m_pGameCamera->GetUp());  
Â  Â  p.SetPerspectiveProj(m_persProjInfo);  
Â  Â  m_DSPointLightPassTech.SetWVP(p.GetWVPTrans());  
Â  Â  m_DSPointLightPassTech.SetPointLight(m_pointLight[PointLightIndex]);  
Â  Â  m_bsphere.Render();  // ì´ì œ êµ¬ë¥¼ ê·¸ë¦¬ê¸°
Â  Â  glCullFace(GL_BACK);  
  
Â  Â  glDisable(GL_BLEND);  
}

virtual void RenderSceneCB()  
{  
Â  Â  CalcFPS();  
  
Â  Â  m_scale += 0.05f;  
  
Â  Â  m_pGameCamera->OnRender();  
  
Â  Â Â **m_gbuffer.StartFrame();**  
  
Â  Â  DSGeometryPass();  
  
Â  Â  // We need stencil to be enabled in the stencil pass to get the stencil buffer  
Â  Â  // updated and we also need it in the light pass because we render the light  
Â  Â  // only if the stencil passes.  
Â  Â Â **glEnable(GL_STENCIL_TEST);  
  
Â  Â  for (unsigned int i = 0 ; i < ARRAY_SIZE_IN_ELEMENTS(m_pointLight); i++) {  
Â  Â  Â  Â  DSStencilPass(i);  
Â  Â  Â  Â  DSPointLightPass(i);  
Â  Â  }  
  
Â  Â  // The directional light does not need a stencil test because its volume  
Â  Â  // is unlimited and the final pass simply copies the texture.  
Â  Â  glDisable(GL_STENCIL_TEST);**  
  
Â  Â  DSDirectionalLightPass();
Â  Â  // Directional LightëŠ” ìœ„ ê¸°ë²•ì´ ì ìš© ì•ˆë¼ì„œ ê± ì „ì²´ë¥¼ ê³„ì‚°í•œë‹¤.
  
Â  Â Â **DSFinalPass();**  
  
Â  Â  RenderFPS();  
  
Â  Â  glutSwapBuffers();  
}
```

<br>

# Optix  

<br>

í•„ìš” ì‚¬ì–‘: RTX GPU  
reference: ğŸ“ optix_quide_241022_A4.pdf  
[NVIDIA-Turing-Architecture-Whitepaper.pdf](https://images.nvidia.com/aem-dam/en-zz/Solutions/design-visualization/technologies/turing-architecture/NVIDIA-Turing-Architecture-Whitepaper.pdf)  

<br>

ì´ì œ ë³¸ê²©ì ìœ¼ë¡œ CPUê°€ ì•„ë‹Œ GPUë¡œ ëŒì•„ê°€ëŠ” Ray Tracerë¥¼ ë§Œë“¤ì–´ë³´ì.  

<br>

ë¨¼ì € NVDIA GPUì˜ ì—­ì‚¬ë¥¼ Briefí•˜ê²Œ ì‚´í´ë³´ì.  
```
Turing `RT Cores` -> Ampere -> Ada(Lovelace) -> Blackwell
```

<br>

RT Coreê°€ ì—¬ê¸°ì„œ ë¹ ì§ˆ ìˆ˜ëŠ” ì—†ë‹¤.  

<br>

`ğŸ“ NVIDIA Turing Architecture white paper.pdf 26p.`  
Graphics Pipelineì„ ì‚´í´ë³´ì.  
Vertex Shader, Geometry Shader, Fragment Shader + Compute Shader  
ì´ê²ƒ ë¼ë¦¬ëŠ” Graphic Memoryë¥¼ Shareí•˜ê¸° ë•Œë¬¸ì— ë¹ ë¥´ì§€ë§Œ VS, GS, FSëŠ” CUDAì™€ Dataë¥¼ ì£¼ê³ ë°›ëŠ”ë° ìƒë‹¹í•œ ì‹œê°„ì´ ê±¸ë¦°ë‹¤.  
ë”°ë¼ì„œ CUDAì™€ ë¹ ë¥´ê²Œ ì†Œí†µí•˜ë ¤ë©´ Compute Shaderë¡œ ë³‘ë ¬ ê³„ì‚°ì„ í•´ì•¼í•œë‹¤.  

<br>

ë‹¤ì‹œ Optix Guide `6p.`ë¡œ ëŒì•„ì™€ì„œ,  

<br>

`ğŸ“ RT_ê°•ì˜ìë£Œ_2.pdf 23p.`  
/ **BVH**  
Bounding Volumeì´ë€ Trianglesì™€ Rayì˜ êµì°¨ê³„ì‚° ì†ë„ ìµœì í™”ë¥¼ ìœ„í•´ Objectë¥¼ AABBë¡œ ë‘˜ëŸ¬ìŒ“ì•„ ë†“ì€ ê²ƒì´ë‹¤. `ë‹¤ë¥¸ ëª¨ì–‘ë„ ê°€ëŠ¥í•˜ì§€ë§Œ ìµœê·¼ì—” ê±°ì˜ ë‹¤ AABBë¥¼ ì”€`  
ê·¸ë¦¬ê³  ì´ë¥¼ Treeêµ¬ì¡°ë¡œ ë§Œë“¤ì–´ ê³„ì¸µêµ¬ì¡°ë¥¼ ë§Œë“  ê²ƒì´ Bounding Volume Hierarchyì´ë‹¤.  

<br>

ë¨¼ì € Rayë¥¼ ë‚˜íƒ€ë‚´ëŠ” Built-In Variableì„ ìƒê¸°í•˜ê³  ê°€ì.  
- e  
- d  
- tmin, tmax  

<br>

<img src="Docs/Pasted image 20241121171009.png" width="350">
  
`tmin`ê³¼ `tmax`ëŠ” ìœ„ ê·¸ë¦¼ì²˜ëŸ¼ ëŠ˜ì–´ë“¤ì—ˆë‹¤, ì¤„ì–´ë“¤ì—ˆë‹¤ í•˜ë©° BVH Traversalì— ë§¤ìš° ì¤‘ìš”í•˜ê²Œ ì“°ì¸ë‹¤.  

<br>

BVH Traversal  
```sudo
BVH_traversal(ray, node) {
	if (ray does not hit nodeâ€™s bv) return NULL;
	if (node is a leaf node) {
		intersect ray with every primitive in leaf;
		return the closest hit if any, or NULL otherwise;
	}
	else {
		hit_l= BVH_traversal(ray, left child node of node);
		hit_r= BVH_traversal(ray, right child node of node);
		return the closer of hit_land hit_r;
	}
}
```

<br>

kd-Tree Traversal  
```cpp
void Traverse() {
	( t_near, t_far ) = ( Epsilon, ray.t_max );
	( t_near, t_far ) = Clip(t_near,t_far);
	node = rootNode; if (t_near > t_far) return; // ray misses bounding box of object while (1) { while (!node.IsLeaf()) { // traverse â€™til next leaf d = (node.split- ray.org[node.dim]) / ray.dir[node.dim]; if (d <= t_near) { // case one, d <= t_near <= t_far-> cull front side node = BackSideSon(node);
	} else if (d >= t_far) {
	// case two, t_near <= t_far <= d -> cull back side node = FrontSideSon(node); } else { // case three: traverse both sides in turn stack.push(BackSideSon(node),d,t_far); ( node, t_far ) = ( FrontSideSon(node), d ); } } // have a leaf now IntersectAllTrianglesInLeaf(node); if (t_far <= ray.t_closesthit) return; // early ray termination if (stack is empty) return; // noting else to traverse any more...
	( node, t_near, t_far ) = stack.pop(); } }
```

<br>

ì´ì œ ë‹¤ì‹œ Optix Manualë¡œ ëŒì•„ì™€ì„œ ì´ì œ ë‹¤ìŒ ìë£Œë¥¼ ë³´ë©° Ray Tracing Pipelineì— ëŒ€í•œ ê°œë…ì„ ì •í™•íˆ ì¡ê³  ë„˜ì–´ê°€ì.  

<br>

<img src="Docs/Pasted image 20241121172029.png" width="300">
  
<img src="Docs/Pasted image 20241121171457.png">
  

<br>

Traversalì„ í•  ë•Œ Leaf Nodeì— ë„ë‹¬í–ˆì„ ë•Œ êµì°¨ ê³„ì‚°ì„ í•˜ê²Œ ë˜ëŠ” Geometry Primitiveì˜ ì¢…ë¥˜ëŠ” ë‹¤ìŒê³¼ê°™ë‹¤.  
ì‚¼ê°í˜•, êµ¬, ìœ¡ë©´ì²´, ê¸°í•˜í•™ì  ë„í˜•, ì‹¬ì§€ì–´ ì—°ê¸°ë„ ê°€ëŠ¥í•˜ë‹¤. `ì—°ê¸°ëŠ” ê·¸ë¥¼ ê°ì‹¸ëŠ” AABBì˜ í˜•íƒœ`  
- Q) ì—°ê¸° ê°™ì€ ê²½ìš°ëŠ” ì–´ë–»ê²Œ íƒìƒ‰í•˜ë‚˜? A) ìš°ë¦¬ê°€ í”„ë¡œê·¸ë¨ì„ ì§œì•¼í•˜ëŠ”ë° ì•„ì£¼ ì‚´ì§ë§Œ ì–˜ê¸°í•˜ìë©´ í”„ë ‰íƒˆì„ ì´ìš©í•œë‹¤.  

<br>

ì´ Primitiveë“¤ê³¼ êµì°¨ê³„í•œì„ í•´ì£¼ëŠ” ê²ƒì´ **Intersection Shader**ì´ë‹¤.  
- â˜… ìœ„ Primitive ì¤‘ì—ì„œ "ì‚¼ê°í˜•"ë§Œ Intersection Shaderê°€ Defaultë¡œ ì œê³µëœë‹¤. `Built-in, ìœ„ ê·¸ë¦¼ì˜ ì´ˆë¡ìƒ‰ì— í•´ë‹¹í•˜ëŠ” ë¶€ë¶„`  

<br>

**No Intersection**: AABBì™€ëŠ” êµì°¨í–ˆëŠ”ë° ê·¸ ì•ˆì˜ Primitiveì™€ëŠ” êµì°¨í•˜ì§€ ì•ŠëŠ” ê²½ìš°  
**Closest Hit?**: ì§€ê¸ˆê¹Œì§€ ì°¾ì€ êµì°¨ì  ì¤‘ì— ê°€ì¥ ê°€ê¹Œì´ ìˆëŠ”ê°€? ë°”ë¡œ ì—¬ê¸°ì„œ tmin, tmaxê°€ ì“°ì¸ë‹¤.  
**Opaque?**: ë³µì¡í•œ Geometryë¥¼ ë®ê³ ìˆëŠ” Primitiveì— Rayê°€ ë„ë‹¬í–ˆì„ ë•Œ ê°€ë¦¬í‚¤ëŠ” ê³³ì— ì‹¤ì œë¡œ Geometryê°€ ìˆëŠ”ì§€ íŒë‹¨í•˜ëŠ” ê²ƒ  
<img src="Docs/Pasted image 20241121173235.png" width="350">
  
**Any-Hit Shader**ëŠ” Opaqueí•˜ì§€ ì•Šì„ ë•Œë§Œ ì“°ì¸ë‹¤.  

<br>

ì´ì œ ë¹„ë¡œì†Œ Traversalì´ ëë‚˜ë©´, ê·¸ì œì•¼ **Closet-Hit Shader**ì™€ **Miss-Shader**ê°€ ì“°ì¸ë‹¤.  
- Closest-Hit ShaderëŠ” ì‹¤ì œ Shading ê³„ì‚°ì„ í–‰í•´ì£¼ëŠ” ê²ƒì´ê³   
- Miss-ShaderëŠ” ë§ì§€ ì•Šì•˜ìœ¼ë‹ˆê¹Œ ë°°ê²½ìƒ‰ìœ¼ë¡œ ì¹ í•´ì£¼ë©´ ëœë‹¤.  

<br>

ì´ì œ ì˜ˆì œ ì½”ë“œë¥¼ ë´ë³´ì.  
`ğŸ“„ optixWhitted.sln`  
Optixì—ì„  Intersection Shaderë¼ëŠ” ê²ƒì„ ì§€ì •í•´ì£¼ê¸° ìœ„í•´ ê¼­ `__intersection__`ì´ë¼ëŠ” ì–´ë¯¸ë¥¼ ë„£ì–´ì•¼ í•œë‹¤.  
```
extrn "C" __global__void __intersetcion__sphere_shell()
```

<br>

Intersectionì´ ì‰¬ìš¸ ê²ƒ ê°™ì€ê°€?  
ë‹¹ì¥ ë‘êº¼ìš´ ìœ ë¦¬ ê²¹ìœ¼ë¡œ ë˜ì–´ìˆëŠ” êµ¬ë¥¼ ìƒê°í•´ë³´ì.  
ë²Œì¨ë¶€í„° Intersectionì´ ë³µì¡í•´ì§„ë‹¤. ì‹¤ì œ ì½”ë“œë„ ìƒë‹¹íˆ ë”ëŸ¬ìš´ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.  

<br>

ì´ì œ ë³¸ê²©ì ìœ¼ë¡œ ë‹¤ìŒ ì‚¬ì§„ì„ ë‚˜íƒ€ë‚´ëŠ” í”„ë¡œê·¸ë¨ì„ ì‚´í´ë³´ë©° OptiXì— ëŒ€í•´ì„œ ë°°ì›Œë³´ì.  

<br>

<img src="https://sites.williams.edu/scientephic/files/2015/10/Nvidia_Optix_CUDA_GPU_Raytracing_Whitted_Hi-Res_01.jpg" width="450">
  

<br>

OptiXëŠ” NVIDIAê°€ ê°œë°œí•œ GPU ê°€ì† ê´‘ì„  ì¶”ì  ì—”ì§„ìœ¼ë¡œ, ê´‘ì„  ì¶”ì  ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„ì„ ë‹¨ìˆœí™”í•˜ê³  ì„±ëŠ¥ì„ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•´ ì„¤ê³„ëœ í”Œë«í¼ì´ë‹¤.  
Turner Whittedì˜ 1980ë…„ Rendering ì²˜ëŸ¼ ë°˜ì‚¬, êµ´ì ˆ, ê·¸ë¦¼ìë¥¼ í¬í•¨í•œ ë¬¼ë¦¬ì ìœ¼ë¡œ ì •í™•í•œ ê´‘ì„  ì¶”ì  ì¥ë©´ì„ êµ¬í˜„í•˜ëŠ” ë° ê°•ë ¥í•œ ë„êµ¬ë¡œ ì‚¬ìš©ëœë‹¤.  

<br>

<img src="Docs/Pasted image 20241121171457.png">
  
ì•ì—ì„œ í–ˆë˜ ìœ„ Pipelineì„ ë¨¸ë¦¿ì†ì— í™•ì‹¤íˆ ë„£ê³  ê°€ì.  

<br>

[NVIDIA OptiX 8.1](https://raytracing-docs.nvidia.com/optix8/index.html)  

<br>

CUDA Coreë‘ RT Core ë‘˜ ë‹¤ ì“´ë‹¤.  
- CUDA Core: SIMD í˜•íƒœì˜ Inst ê°€ì†  
- RT Core: VBH ê°€ì†  

<br>

#### `createContext()`  
> ìµœì´ˆì˜ Context ìƒì„±  

<br>

`ğŸ“„ Whitted.cpp`  
```
1003  sbt: Shader bundung Table
1004  ë¬¶ì–´ë‚¼ í”½ì…€ë“¤ì˜ í•´ìƒë„ ì •ë³´, width
1005  ë¬¶ì–´ë‚¼ í”½ì…€ë“¤ì˜ í•´ìƒë„ ì •ë³´, height
1007  Depth
```

<br>

`ğŸ“„ camera.cu`  
raygen shaderê°€ ì •ì˜ë˜ì–´ìˆë‹¤.   

<br>

`optixGetLaunchIndex()`: `[i][j][k] := (x, y, z=1 (Depth) )`  

<br>

[Device API - optixTrace](https://raytracing-docs.nvidia.com/optix8/api/group__optix__device__api.html#ga11c7984d825b2a597e26a2a902386bbc)  
`optixTrace(params.handle, ray_origin ray_direction, params.scene_epsilon, 1e16f, OprixVisibilityMask(1), OPTIX_RAY_FLAG_NONE, whitted::RAY_TYPE_RADIANCE, shitted::RAU_TUPE_COUNT, whitted::RAY_TYPE_RADIANCE, float3_as_args(prd.result), reinterpret_cast<insigned int&>(prd.improtance), reinterpret_cast<unsigned int&>(prd.depth));`  
- `params.handle`: BVHì— ëŒ€í•œ Pointer  
-   
- `whitted::RAY_TYPE_COUNT`  
- `whitted:RAY_TYPE_RADIANCE`: í—ˆê³µì„ ëš«ê³  ì§€ë‚˜ê°”ì„ ë•Œ   

<br>

ë³´ë©´ Parameterê°€ ìƒë‹¹íˆ ë§ì€ë°, ì•ë¶€ë¶„ì˜ Paramë“¤ì€ ê³ ì •ëœ Attribute ê°’ì´ê³  ì•„ë˜ì˜ Paramì€ ê°’ì´ ê³ ì •ë˜ì§€ ì•ŠëŠ” Rayì˜ Payloadì— í•´ë‹¹í•œë‹¤.  
- `reinterpret_cast<unsigned int&>(prd.depth)`: Payload, Rayë¡œ ê³„ì‚°ëœ ì •ë³´ë¥¼ ë°›ì•„ì˜¤ëŠ” ê²ƒ, Attribute(orig, dir ë“±)ì™€ í—·ê°ˆë¦¬ì§€ ë§ì.  
- `prd.result`: Payload, RGBA ê²°ê³¼ê°’ì„ ë°›ì•„ í”½ì…€ì— ìƒ‰ì„ ì¹ í•  ìš©ë„  
- `importance`: Payload, Rayë¥¼ ì–¸ì œ ëŠì–´ë²„ë¦´ ê²ƒì¸ê°€  

<br>

ì¼ë‹¨ `params.handle`ì™€ ê´€ë ¨í•˜ì—¬ BVHë¥¼ ì–´ë–»ê²Œ ë§Œë“¤ì§€ë¶€í„° ì‹œì‘í•˜ì.  

<br>

/ **Making BVH (Accelaration Sturcture)**  
ê°€ì¥ ì²˜ìŒìœ¼ë¡œ ì¥ë©´ì— ëŒ€í•´ì„œ BVHë¥¼ ë§Œë“¤ì–´ì•¼ í•œë‹¤.  

<br>

Vulkanì—ì„  ë‹¤ìŒê³¼ ê°™ê³ ,  
- TLAS(Top-Level Acceleration Structure)  
- BLAS(Bottom-Level Acceleration Structure)  
OptiXì—ì„  ë‹¤ìŒê³¼ ê°™ë‹¤.  
- GAS(Geometry Acceleration Structure)  
- IAS(Instance Acceleration Structure)  

<br>

Vulkan  
<img src="Docs/Pasted image 20241126171046.png" width="600">
  
BLASí•˜ë‚˜ë¥¼ ê°–ê°€ì§€ Modeling ë³€í™˜ì„ í†µí•´ TLAS_1, TLAS_2, TLAS_3..ì„ ë§Œë“ ë‹¤.  
BLASë¥¼ ì„¸ìƒì—ë‹¤ ë°°ì¹˜í•  ë•Œ ì–´ë–¤ ë³€í™˜ì„ í†µí•´ TLASë¡œ ë°°ì¹˜í• ì§€ì— ëŒ€í•œ ì •ë³´ê°€ ê°ê°ì˜ TLASì— ë¶™ì–´ìˆë‹¤.  

<br>

OptiX  
<img src="https://raytracing-docs.nvidia.com/optix8/guide/pages/img/traversables_graph.jpg" width="450">
  
ë‹¤ìŒê³¼ ê°™ì´ BVHë¥¼ ë‹¨ìˆœí•˜ê²Œ Two-Levelë¡œ í•˜ëŠ” Vulkanë³´ë‹¤ ë‹¤ì†Œ ë³µì¡í•˜ê²Œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.  

<br>

OptiXì—ì„œ Acceleraton Structureë¥¼ ì œê³µí•˜ëŠ” Geometryë“¤ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.  
```OptiX8.1 Programming Guide 5. Acceleration Structures
The following build input types are supported:

Instance acceleration structures
OPTIX_BUILD_INPUT_TYPE_INSTANCES
OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS

A geometry acceleration structure containing built-in triangles
OPTIX_BUILD_INPUT_TYPE_TRIANGLES // ì‚¼ê°í˜•

A geometry acceleration structure containing built-in curve primitives
OPTIX_BUILD_INPUT_TYPE_CURVES // ì»¤ë¸Œ(ë¨¸ë¦¬ì¹´ë½..?)

A geometry acceleration structure containing built-in spheres
OPTIX_BUILD_INPUT_TYPE_SPHERES // êµ¬

A geometry acceleration structure containing custom primitives
OPTIX_BUILD_INPUT_TYPE_CUSTOM_PRIMITIVES // ë‚´ ë§˜ëŒ€ë¡œ ì»¤ìŠ¤í…€
```
ìš°ë¦¬ê°€ ë³¼ ì˜ˆì œ ì½”ë“œì—ì„  ë‹¤ë¥¸ ê±´ ì•ˆ ì“°ê³  `OPTIX_BUILD_INPUT_TYPE_CUSTOM_PRIMITIVES` ì¦‰, ì»¤ìŠ¤í…€ Acceleration Structureë¥¼ ì“°ê³ ìˆë‹¤. ì´ StructureëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë§Œë“¤ì–´ì§„ë‹¤.  
- ë¶€ê°€ì ì¸ ì •ë³´ì—†ì´ AABBë§Œ í˜•ì„±í•œë‹¤. `x_min, x_max, y_min, y_max, z_min, z_max`  
- ì¶©ëŒ ì‹œ AABB ì•ˆì—ì„œì˜ ì¶©ëŒ ì—¬ë¶€ëŠ” ìš°ë¦¬ê°€ ì§ì ‘ ì§  Intersection Shaderê°€ í•„ìš”í•˜ë‹¤.  

<br>

#### `createGeometry()`  
> Acceleration Sturcture êµ¬ì¶•  

<br>

ì´ì œ ë³¸ê²©ì ìœ¼ë¡œ ë´ë³¼ê¹Œ?  
`ğŸ“„ Whitted.cpp`  
```
917  cudaë¥¼ ìµœì´ˆë¡œ í˜¸ì¶œí•˜ë©´ ìë™ì ìœ¼ë¡œ Contextë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤. cudaFree(NULL)ì€ ì•„ë¬´ ì˜ë¯¸ ì—†ìŒ
925  OptiX Contexë¥¼ ë§Œë“¤ ë•Œ ë¨¼ì € Cuda Contextë¥¼ ë§Œë“¤ê³  ì´ë¥¼ ê°™ì´ ì „ë‹¬í•´ì•¼í•œë‹¤.
1111  ì—¬ê¸°ì„œ Acceleration Structureë¥¼ ë§Œë“ ë‹¤.

createGeometry()
388 AABB Typeì˜ Arrayë¥¼ ë§Œë“¤ê³  ìˆë‹¤ OBJ_COUNTëŠ” ì „ì²´ Sceneì„ êµ¬ì„±í•˜ëŠ” ë¬¼ì²´ì˜ ê°œìˆ˜, ì—¬ê¸°ì„  3ê°œì´ë‹¤. sphere_bound()ëŠ” êµ¬ì— ëŒ€í•œ min maxë¥¼ ê³„ì‚°í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë‹¤.
393-399  cuda í•¨ìˆ˜ë¥¼ ì¨ì„œ CPUì—ì„œ GPU, ì¦‰Deviceë¡œ ë³´ë‚´ì£¼ê³  ìˆë‹¤.

// Setup AABB build Input
405  0ë²ˆ ë¬¼ì²´(ë¶ˆíˆ¬ëª… êµ¬)ì— ëŒ€í•´ì„œëŠ” anyhit shader ë¶€ë¥´ì§€ ë§ˆë¼. (Pipeline ìƒê¸°)
407  1ë²ˆ ë¬¼ì²´(glass êµ¬)ì— ëŒ€í•´ì„œëŠ” anyhit shaderë¥¼ í•œ ë²ˆë§Œ ë¶ˆëŸ¬ë¼.
409  2ë²ˆ ë¬¼ì²´ì—(ë¶ˆíˆ¬ëª… ë°”ë‹¥) ëŒ€í•´ì„œëŠ” anyhit shader ë¶€ë¥´ì§€ ë§ˆë¼.

...

// "ë­"ì— ëŒ€í•´ì„œ Acceleration Sturctureë¥¼ ë§Œë“¤ì–´ë¼ = Build Input
423  ì•„ê¹Œ ë³¸ Acceleration Structure Type ì¤‘ ë‚´ë§˜ëŒ€ë¡œ íƒ€ì„
ë‚´ ë§˜ëŒ€ë¡œ íƒ€ì…ì— ì–´ë–¤ ì •ë³´ë¥¼ ë„£ì–´ì•¼ í•˜ëŠ”ì§€ëŠ” OptixBuildInputCustomPrimitiveArrauì˜ ì •ì˜ë¥¼ ë³´ì.
- d_aabb: AABB í¬ì¸í„°
- numSbtRecords: Intersection Shader, Closest Shader, Anyhit Shaderë¥¼ ê°ê°ì˜ ë¬¼ì²´ë§ˆë‹¤ ë¶™ì—¬ì£¼ê³  ë§ê³  í•´ì•¼í•˜ëŠ”ë°, ì¼ë‹¨ ì—¬ê¸°ì„œëŠ” ê°ê°ì˜ ë¬¼ì²´ë§ˆë‹¤ ë”°ë¡œë”°ë¡œ ì„¸ ì¢…ë¥˜ë¥¼ ì“°ê² ë‹¤ê³  ì§€ì •í•˜ê³  ìˆë‹¤. í•˜ë‚˜ë§Œ ì“°ê³  ì‹¶ìœ¼ë©´ NULLë¡œ ì§€ì •í•´ì£¼ë©´ ëœë‹¤.
Primary Ray Shadow Ray
- d_sbt_index: ë¬¼ì²´ ìˆœì„œëŒ€ë¡œ ì–´ë–¤ indexì˜ sbtRecordë¥¼ ì“¸ì§€ ì§€ì •í•´ì£¼ëŠ” ê²ƒ

```

<br>

ìœ„ d_sbt_indexë¥¼ ì–´ë–»ê²Œ 
<br>


```math
\begin{align}
\text{sbt-index}& = \text{sbt-instance-offset}\\
    &+ (\text{sbt-geometry-acceleration-structure-index} \times \text{sbt-stride-from-trace-call}) \\
    &+ \text{sbt-offset-from-trace-call}
\end{align}
```


<br>

ì´ ì½”ë“œë¥¼ ì˜ˆë¡œ ë“¤ë©´ Glass Sphereì— Primary Rayê°€ ë¶€ë”ªí˜”ë‹¤ê³  ì¹˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ê°’ì´ ë“¤ì–´ê°€ ìˆë‹¤.
<br>


```math
\text{sbt-index} = 0 + 1 \times 2 + 0
```

ê°ê°ì˜ í•­ì— ì–´ë–¤ ê°’ì´ ë“¤ì–´ê°ˆ ì§€ëŠ” `optixTrace()` í•¨ìˆ˜ì—ì„œ ì§€ì •í•´ì¤„ ìˆ˜ ìˆë‹¤..  

<br>

ì´í•´ê°€ ì˜ ê°€ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒ Programming Guideë¥¼ ë³´ì.  
[7.3 - Acceleration structures](https://raytracing-docs.nvidia.com/optix8/guide/index.html#shader_binding_table#accelstruct-sbt)  
<img src="Docs/Pasted image 20241128173204.png" width="600">
  
ìœ„ í‘œëŠ” ìš°ë¦¬ê°€ í•˜ëŠ” ì˜ˆì œ ì½”ë“œì™€ ë‹¬ë¦¬ Build Inputì´ í•˜ë‚˜ê°€ ì•„ë‹Œ ê²½ìš°ì´ë‹¤.  

<br>

Shader Bingding Tableì˜ ContentëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.  
```
SBT
[0]
PR: Color Shader { IS, AS, CS }  // { Intersection Shader, Anyhit Shader, Closest Shader }
SR: Shadow Shader { IS, AS< CS }

[1]
PR: Color Shader { IS, AS, CS }
SR: Shadow Shader { IS, AS, CS }

[2]
PR: Color Shader { IS, AS, CS }
SR: Shadow Shader { IS, AS, CS }
```
ì–´ë–¤ ë¬¼ì²´ëŠ” `SBT[0]`ìœ¼ë¡œ ê³„ì‚°í•˜ê³ , ì–´ë–¤ ë¬¼ì²´ëŠ” `SBT[1]`ë¡œ ê³„ì‚°í•˜ê³ .. í•˜ë¼ëŠ” ê²ƒì´ë‹¤.  

<br>

Ray Type `whitted::RAY_TYPE_RADIANCE`  
- Primary Ray: Rayê°€ ë•Œë ¸ì„ ë•Œ ìƒì„±í•˜ëŠ” ìƒ‰ê¹”ì„ ì•Œì•„ë‚´ê¸° ìœ„í•œ Ray  
- Shadow Ray: ê´‘ì›ì„ í–¥í•´ ë•Œë ¤ì„œ ê·¸ë¦¼ì ìƒì„± ì—¬ë¶€ë¥¼ ì•Œì•„ë‚´ëŠ” Ray  

<br>

ê°ê°ì˜ shaderë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ëŠ” OptiXì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë˜ì–´ìˆë‹¤.  
- raygenRecored  
- missRecordBase  
- hitgroupRecoredBase  

<br>

ë§¤ í”„ë ˆì„ë§ˆë‹¤ OptiXLaunnchê°€ ë“¤ì–´ê°€ê²Œ ëœë‹¤. ì´ë¥¼ ì´ë£¨ê³  ìˆëŠ” ì£¼ìš” ìš”ì†Œì— ëŒ€í•œ ì„¤ëª…ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.  
- pipeline: í˜„ì¬ ì“¸ Raytracing Pipeline  
- stream: CUDA Stream ì§€ì •  
- sbt: Shader Binding Table  

<br>

`ğŸ“„ Whitted.cpp`  
```
435  ì••ì¶•ê¸°ëŠ¥ (ì‚¼ê°í˜•ì´ 3000ë§Œê°œë‹¤.. ì´ëŸ´ ë•Œ ì“°ëŠ”ê±°ì§€ ì´ ì˜ˆì œëŠ” ê·¸ëƒ¥ ë„£ì€ ê²ƒ ë¿)

440  buildGas()

// buildGas()
358  output Dataë¥¼ ì••ì¶•í–ˆì„ ë•Œ ì˜ˆìƒë˜ëŠ” ì‚¬ì´ì¦ˆ
366  ì•”ì¶• í›„ì˜ ì‚¬ì´ì¦ˆê°€ í™•ì‹¤íˆ ì°¨ì´ê°€ ë‚  ê²½ìš°ì—ë§Œ ì••ì¶•í•´ë¼
```

<br>


<br>

ìš°ë¦¬ëŠ” ì´ì œ ê²¨ìš° OptiXì—ì„œ ì“¸ Ray Tracing Pipelineì„ ì–´ë–»ê²Œ êµ¬ì¶•í•  ê²ƒì¸ì§€ì— ëŒ€í•´ì„œ ì´ì•¼ê¸° í•´ë³¼ ê²ƒì´ë‹¤.  
ê·¸ê²ƒì€ ìœ„ Ray Tracing Pipeline ê·¸ë¦¼ì—ì„œ ë³´ì•˜ë˜ Acceleration Structure Traversla Loopê°€ ì‘ë™í•  ìˆ˜ ìˆë„ë¡ Pipelineì„ êµ¬ì¶•í•˜ë¼ëŠ” ê²ƒì´ë‹¤.  

<br>

#### ğŸ“— HW3  
Learn OpenGL Code 8.1, 8.2  
êµ¬ì— í•´ë‹¹í•˜ëŠ” ë‹¤ë©´ì²´ ëª¨ë¸ì´ í•„ìš”í•¨. `ì‚¼ê°í˜•ìœ¼ë¡œ ì´ë£¨ì–´ì§„ êµ¬`  
- Trangle info: x, y, z, x, y, z, x, y, z /  
- normal: ...  
Instancing  
: IAS(Instance Accleration Structure), GASí•˜ë‚˜ë¡œ Më³€í™˜ë§Œ í†µí•´ì„œ ë¬´í•œ ë³µì œ (Crowd)  

<br>

ë‹¤ì‹œ ì½”ë“œë¡œ ëŒì•„ì™€ì„œ,  
#### `createPipeline()`  
> Ray Tracing Pipeline êµ¬ì¶•  

<br>

optixPipelineCreate()  
ê° ë¬¼ì²´ë“¤ì„ ë‹¤ë£¨ê¸° ìœ„í•œ Shader Programë“¤ì„ ë¯¸ë¦¬ ì»´íŒŒì¼ ì‹œì¼œì„œ pipeline compile optionsì™€ pipeline link optoinë¥¼ ì§€ì •í•´ì¤€ í›„ `optixPipelineCreate()`ë¡œ Pipeline êµ¬ì¶•  
- Shader Array: Shader Programì´ ë“¤ì–´ê°€ ìˆëŠ” ë°°ì—´  
- Compile Option: Traverseí•˜ëŠ” Geometry ì¢…ë¥˜ì— ë”°ë¼ Optimize  
- Link Option: Rayì˜ Max ë°˜ì‚¬ Depth, hmaxTraceDepthê°€ ë°”ë¡œ ì—¬ê¸°ì„œ ì§€ì •ëœë‹¤.  

<br>

LaunchParams params ì–´ë”” ê°€ë©´ ìˆê³  ì‚¬ì´ì¦ˆëŠ” ëª‡ì´ë¼ê³  ì•Œë ¤ì¤€ë‹¤.  

<br>

BVH  
- Build: ì²˜ìŒë¶€í„° ë‹¤ì‹œ ë‹¤ ë¹Œë“œí•œë‹¤.  
- Update: Physical Simulation ì‹œ Vertexì— ë³€í˜•ì´ ì¼ì–´ë‚˜ë©´ Tree êµ¬ì¡°ëŠ” ê±°ì˜ ê·¸ëŒ€ë¡œ ìœ ì§€í•œ ì±„ ë¶€ë¶„ì ìœ¼ë¡œ ë³€í˜• ê°€ëŠ¥í•˜ë„ë¡ í•œë‹¤.  
í•˜ì§€ë§Œ ê³„ì† Updateí• ìˆ˜ë¡ Traversal ë¹„ìš©ì´ ì»¤ì§€ê¸° ë•Œë¬¸ì— Updateí•˜ë‹¤ Buildí•˜ê³  ë‹¤ì‹œ ê³„ì† Updateí•˜ëŠ” ì‹ìœ¼ë¡œ í•œë‹¤.  

<br>

`optixDynamicGeometry.cpp`ë¥¼ ì°¸ê³ í•˜ë©´ ëœë‹¤.  
```
446  ì²˜ë¯•ì— ë§Œë“¤ ë•Œ Build í•œ ë²ˆ í•œë‹¤. ALLOW_UPDATE Optionì„ ì¼œì¤˜ì•¼ í•œë‹¤.
421  ë§¤ Frame ë‹¹ ë³€í™”ê°€ ì¼ì–´ë‚˜ë©´ Updateí•œë‹¤.
```

<br>

ğŸ“— HW4  
Updateí•˜ëŠ” ë™ì ì¸ ë¬¼ì²´: Ben ê°™ì€ ê±¸ ì‚½ì…  

<br>

UVW := XY-Z  

<br>

Launch Parameter`param`ë¥¼ ë§¤ Frame Setup í•œ ë’¤ launchSubFrameì„ í˜¸ì¶œí•œë‹¤.  

<br>

Supersampling: í”½ì…€ ë‹¹ Rayë¥¼ ì—¬ëŸ¬ ë²ˆ ì˜ê² ë‹¤.  
- Regular: ê° í”½ì…€ë‹¹ ê²©ìë¬´ëŠ¬ë¡œ ì˜ë¼ì„œ Rayë¥¼ ë³´ë‚¸ ë‹¤ìŒ Weightë¥¼ ì£¼ëŠ” ê²ƒ  
- Stochastic: í”½ì…€ì— Random ìœ„ì¹˜ì— Rayë¥¼ ë³´ë‚¸ë‹¤.  
ìš°ë¦¬ ëˆˆì€ ê·œì¹™ì ì¸ aliasì— ë” ë¯¼ê°í•˜ê¸° ë•Œë¬¸ì— Stochasticì´ ë” ìì—°ìŠ¤ëŸ¬ìš´ ë°©ë²•ìœ¼ë¡œ ì„ í˜¸ëœë‹¤.  
<img src="https://pbr-book.org/4ed/Sampling_and_Reconstruction/pha08f16.svg" width="300">
  <img src="Docs/Pasted image 20241205172215.png" width="150">
  
â–¶ Jitter, Poisson Disk, Stratified Jitter  

<br>

`camera.cu`  
```
69  ë“¤ì–´ì˜¨ ê±° ê·¸ëƒ¥ í‰ê·  ë‚´ë©´ì„œ Accumulation Bufferì— ëˆ„ì  í•˜ê³ ìˆë‹¤.
```
- `lerp(A, B, t)` = $`(1 - t)A + tB`$  
- $`\frac{nA + B}{n+1} = (1-\frac{1}{n+1})A + \frac{1}{n+1}B = (1-t)A + tB`$  

<br>

/ Polygon Model  
ë¨¼ì € ë‹¤ìŒ ì½”ë“œë¥¼ ë³´ì.  
[optix7course/example07_firstRealModel at master Â· ingowald/optix7course](https://github.com/ingowald/optix7course/tree/master/example07_firstRealModel)  
`SampleRendere.cpp`  
GAS ë§Œë“¤ ë•Œ ê°ê°ì˜ ëª¨ë¸ì— ëŒ€í•´ì„œ For Loopì´ ë„ëŠ”ë° Vertex Bufferë‘ Index Buffer ì½ì–´ë“¤ì´ê³   
- Vertex Buffer: `x y z, x y z, ...`  
- Index Buffer: `3 5 7, 3 6 11, ...`  
`121-129` Vertex Buffer, Index Buffer Setting  
`135` SBT Entryê°€ í•˜ë‚˜ì´ë¯€ë¡œ ë‹¤ë¥¸ Parameter ì„¤ì •ì„ ì•ˆí•´ì¤˜ë„ ëœë‹¤. `=0`  

<br>

ê·¸ëŸ¼ Polygon Modelì€ ì–´ë–»ê²Œ í• ê¹Œ?  
SBTRecord: Shader Binding Tableì˜ ê°ê°ì˜ ì›ì†Œ  

<br>

[Optix 7 - Shader binding table](https://velog.io/@sunbei00/Optix-7-Shader-binding-table)  

<br>

#### `createSBT()`  
> Shader Binding Table ì¤€ë¹„  

<br>

Shader Binding Table(SBT)  

<br>

```cpp
tyoedef struct OptixShaderBindingTable {
	CUdeviceptr raygenRecord;
	
	cudeviceptr missRecordBase;
	unsigned int missRecordStrideInBytes;
	unsigned int missRecordCount;
	
	// â˜… Hit group (Intersection Shader, Any-hit Shader, Closest-hit shader)
	cudeviceptr hitgroupRecordBase;
	unsigned int hitgroupRecordStrideInBytes;
	unsigned int hitgroupRecordCount;
};

// ---------------------------------------
//   reco0 |  reco1  |  reco2  |  reco3..
// --------------------------------------- RecordCount
// { Stride }
```

<br>

```
// Ray type = { 0, 1 } = { Primary Ray, Shadow Ray }
// GAS = { Metal Sphere, Glass Spere, Floor }

Metal Sphere    0
				1
Glass Sphere    0
				1
Floor           0
				1
```

<br>

Shader Binding Table Record  
```
// Header = 32byte

header `optixSbtRecordPackHeader(state.???group, ...)`
IS: __intersection__ spere
SH: __slosesthit__metal_radiance
AH: nullptr

data `???group_records[sbt_table_idx].data`
// ì•„ë¬´ê±°ë‚˜ íƒ€ì…ì˜ ë‹¤ì–‘í•œ ì¶”ê°€ ì •ë³´ë“¤ (ê¸¸ì´, ë†’ì´ ë“±)
```
- ê°ê°ì˜ Recordì— ëŒ€í•´ Header Packing`header` -> Geometry Setting`data`ì´ ì´ë£¨ì–´ì§„ë‹¤.  

<br>

```
// Device Memory
------+------+------+-------
------+------+------+-------
Launch Params      SBT
```

<br>

```
60  optixReportIntersection(t, 0, float_as_args(n), __float_as_uint(a1), __float_as_uint(a2))
// tê°’ì— ë”°ë¼ ìœ ë¦¬ êµ¬ ì•ˆì—ì„œ ì–´ë–¤ ì¢…ë¥˜ì˜ êµ´ì ˆ/ë°˜ì‚¬ê°€ ì¼ì–´ë‚˜ëŠ”ì§€ ë¶„ë¥˜
```
- Intersection Shaderì—ì„œëŠ” í•´ë‹¹ Intersectionì´ ì–´ë–¤ ê²ƒì¸ì§€ ì•Œì•„ë‚¼ ì •ë³´ë“¤ì„ ì „ë‹¬í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.  
- ì´ Intersection Shaderê°€ ìƒí™©ì— ë”°ë¼ì„  ì•ì„œ ë°°ì› ë˜ ê²ƒì²˜ëŸ¼ Any Hit Shaderë¥¼ ë¶€ë¥¼ ìˆ˜ë„ ìˆë‹¤.  
- Closest-Hit Shader  

<br>

```cpp
// Floorì˜ ì²´í¬ë¬´ëŠ¬ë¥¼ ë§Œë“ ë‹¤.

float2 texcoord = make_float2(__uint_as_float(optixGetAttribute_3()), __uint_as_float(optixGetAttribute, 4()));
float2 t = textcoord * checker.inv)checker_size;
tx = floorf(t.x);
ty = floorf(t.y);

int which_check = (static_cast<int>(t.x) + static_cast<int>(t.y)) & 1;

if (which_check) {
	Kd = checker.Kd1;
	Ka = checkerKa1;
	Ks = checker.Ks1;
	Kr = checker.Kr1;
	phong_exp = checker.phong_exp1;
}

// 4 5 6 7 8 9
// 3 4 5 6 7 8
// 2 3 4 5 6 7
// 1 2 3 4 5 6
// 0 1 2 3 4 5
// ì™€ 1ë¡œ Bit-wiseì—°ì‚°ì„ í•œë‹¤.

// ë­”ê°€ ê³ ëŠ¥í•´ë³´ì´ëŠ” ì½”ë“œë‹¤..

..
world_normal // IAS - ëª¨ë¸ë§ ì¢Œí‘œê³„ì—ì„œ ì„¸ìƒ ì¢Œí‘œê³„ë¡œ ë‹¤ì‹œ ë³´ë‚´ì£¼ê³  ìˆë‹¤.
faceforward(world_normal, )
```

<br>

Primary Ray (importance = 1.0, depth = 0)ë¥¼ ì²˜ìŒì— ìœë‹¤.  
- `importance`: `new_importance = prd_importance * luminance(p_Kr)`  
- `depth`: ë¹›ì´ ë°˜ì‚¬ëœ íšŸìˆ˜  
ì—¬ê¸°ì„œ p_Krì´ë€ RGBê°’ì„ í•©í•˜ì—¬ Gray Scaleì„ ì ìš©í•œ ê²ƒìœ¼ë¡œ, ë¹›ì´ ë°˜ì‚¬ëœ ì„¸ê¸°, ì¦‰ ê´‘ë„ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤ê³  ìƒê°í•˜ë©´ ë˜ê² ë‹¤.  
ë¹›ì´ ë°˜ì‚¬ë  ë•Œë§ˆë‹¤ ë¹›ì˜ Importanceì™€ depthê°€ ì—…ë°ì´íŠ¸ ëœë‹¤.  
ì´ importanceì™€ depthë¥¼ ê°€ì§€ê³  Rayë¥¼ ë˜ ì ì§€ ë§ì§€ ê²°ì •í•œë‹¤.  

<br>

ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê³„ì‚°í•œë‹¤.  
`reculs += p_Kr * traceRay(origin, direction, depth, new_importance)`  

<br>

Miss í–ˆë‹¤ëŠ” ê²ƒì€ ìƒˆë¡œìš´ ë²„ì „ì˜ OptiXì— íƒ‘ì¬ë˜ì–´ìˆëŠ” featureë¥¼ ì´ìš©í•˜ì—¬ Background Colorì™€ ë¹„êµí•˜ì—¬ ì•Œì•„ë‚¸ë‹¤.  

<br>

ë‹¤ìŒ ì½”ë“œëŠ” ë¬´ì—‡ì„ ì˜ë¯¸í• ê¹Œ?  
```cpp
const vool do_refine = fbsf(root1) > (10.0f * radius);
```
<img src="Docs/Pasted image 20241212164924.png" width="200">
 ë‹¤ìŒ ê·¸ë¦¼ì˜ ë‘ ë²ˆì§¸ ê°™ì€ ê²½ìš°ì´ë‹¤.  

<br>

/ Metal Sphere ë°˜ì‚¬
<br>

$`t\in [t_{min}, t_{max})`$
optixReportIntersectionì—ì„œ ë•Œë¦° ê±¸ ì°¾ê³  `t_min`ê³¼ `t_max`ê°€ ë“¤ì–´ì˜¨ë‹¤.  
hitKind ì •ë³´ì™€ í•¨ê»˜ Rayì— ëŒ€í•œ Attributeë¥¼ í†µí•´ì„œ Reportí•œë‹¤.  
- Any-Hit í˜¸ì¶œ O  
- optixIgnoreIntersection: `t_max`ê°€ ë¬¼ì²´ì˜ ìœ„ì¹˜ë¡œ ì—…ë°ì´íŠ¸ë¥¼ í•¨ `1`  
- optixTerminateRay `2`  
- NULL `ì•„ë¬´ê²ƒë„ ì•ˆ ë¶€ë¦„`, True Return(ì•„ë¬´ê²ƒë„ ì•ˆ í–ˆë‹¤ëŠ” ëœ») `3`  
- Any-hit í˜¸ì¶œ X  
- NULL `ì•„ë¬´ê²ƒë„ ì•ˆ ë¶€ë¦„`, True Return(ì•„ë¬´ê²ƒë„ ì•ˆ í–ˆë‹¤ëŠ” ëœ») `4`  

<br>

/ Glass Sphere ë°˜ì‚¬  
<img src="Docs/Pasted image 20241212173140.png" width="300">
  
â‘  OO (Outside Outside)  
â‘¡ IO (Inside Outside)  
â‘¢ II (Inside Inside)  
â‘£ OI (Outside Inside)  

<br>

`bear_attuenuation`: Absorption íš¨ê³¼, ìœ ë¦¬ì˜ ê°€ì¥ìë¦¬ë¡œ ê°ˆ ìˆ˜ë¡ ì§„í•´ë³´ì´ëŠ” íš¨ê³¼  

<br>

/ Triangle Mesh `ğŸ“„ optixMeshViewer`  
- `ğŸ“„ whitted.cu`  
- t, hitKind, attribute (($`\alpha, \beta`$), baryCentric Coord)  
- ì‚¼ê°í˜•ì„ ë•Œë¦¬ë©´ ëª‡ ë²ˆì§¸ ì‚¼ê°í˜•ì„ ë•Œë ¸ëŠ”ì§€ Indexë¡œ ë°›ì•„ì˜¬ ìˆ˜ ìˆë‹¤.  
- ê·¸ë ‡ê²Œ ì‚¼ê°í˜•ì˜ ê¼­ì§“ì  `p0, p1, p2`ë¥¼ ë°›ì•„ì™€ $`p = (1 - \alpha - \beta)\cdot p_0 + \alpha\cdot p_1 + \beta\cdot p_2`$ë¥¼ ê³„ì‚°í•œë‹¤.  

<br>


<br>

# Volume Rendering Equation  

<br>


```math
\begin{align}\text{Absorption} + \text{Out-Scattering} &+ \text{Emission} + \text{In-Scattering} \\
= \text{Extinction} &+ \text{Emission} + \text{In-Scattering}\end{align}
```

/ Absorption
<br>


```math
\begin{align}L(S^*) &= L_o \cdot e^{-\int^{S^*}_0\sigma_a(s)ds}\\&=L_o\cdot T(S^*)\end{align}
```

/ Out-Scattering
<br>


```math
L(S^*) = L_o\cdot e^{-\int^{S^*}_0\sigma_s(s)ds}
```

/ Extinction  

<br>


```math
L(S^*) = L_o\cdot e^{-\int^{S^*}_0\sigma_t(s)ds}
```

/ Emission  

<br>


```math
L(S^*) = L_o + \int^{S^*}_0g(s)ds
```

/ In-Scattering  

<br>


```math
L(S^*) = L_o + \int^{S^*}_0s(s)ds
```


<br>
